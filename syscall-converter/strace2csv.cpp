/*
 * Copyright (c) 2015-2016 Leixiang Wu
 * Copyright (c) 2015-2016 Shubhi Rani
 * Copyright (c) 2015-2016 Sonam Mandal
 * Copyright (c) 2015-2016 Erez Zadok 
 * Copyright (c) 2011-2012 Jack Ma
 * Copyright (c) 2011-2012 Vasily Tarasov
 * Copyright (c) 2011-2012 Santhosh Kumar Koundinya
 * Copyright (c) 2011-2012 Geoff Kuenning
 * Copyright (c) 2011-2012 Stony Brook University
 * Copyright (c) 2011-2012 Harvey Mudd College
 * Copyright (c) 2011-2012 The Research Foundation of SUNY
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 *
 * strace2csv converts system call traces generated by 
 * command strace to CSV traces in a format that is defined in 
 * strace.spec.
 *
 * TODO:
 * Converts various units in system call trace 
 * formats to the units defined by the SNIA standard. 
 * E.g., time is converted to Tfracs, offset and I/O size to bytes, etc.
 *
 * This tool is usually invoked by a strace2ds script after strace is 
 * executed to record system calls of an application. 
 *
 * The tool produces a new CSV file that is then feed to a 
 * csv2ds tool.
 *
 * Usage: strace2csv-converter <input_file> <output_file>
 * <output_file> name of the CSV output file
 * <input_file> name of the strace input file
 */

#include <fstream>
#include <iostream>

extern bool process_row(const std::string &in_row, std::string &out_row);

/*
 * This function prints out the usage
 * information to error stream.
 *
 * @para pgmname: the name of this program.
 */
void show_usage(const char *pgmname) {
  std::cerr << "Usage:   " << pgmname << " <input file> <output file>\n";
  std::cerr << "Example: " << pgmname << " /foo/bar /foo/baz\n";
}

int main(int argc, char *argv[]) {
  const char *in_file_name;
  const char *out_file_name;
  std::ifstream in_file;
  std::ofstream out_file;
  std::string in_row;
  std::string out_row;
  int row_num = 0;
  int ret = EXIT_SUCCESS;
  
  if (argc < 3) {
    show_usage(argv[0]);
    return EXIT_FAILURE;
  }
  in_file_name = argv[1];
  out_file_name = argv[2];
  in_file.open(in_file_name, std::ios_base::in);
  if (!in_file.is_open()) {
    std::cerr << "Unable to open input file '" << in_file_name << "'.\n";
    ret = EXIT_FAILURE;
    goto cleanup;
  }
  out_file.open(out_file_name, std::ios_base::out);
  if (!out_file.is_open()) {
    std::cerr << "Unable to open output file '" << out_file_name << "'.\n";
    ret = EXIT_FAILURE;
    goto cleanup;
  }  
  // Each line is a record in input file, so read the file line by line
  while(getline(in_file, in_row)) {
    row_num++;
    if (!process_row(in_row, out_row)) {
      std::cerr << "Error processing record " << in_row << ".\n";
      std::cerr << "The error record is at row " << row_num << ".\n";
      exit(EXIT_FAILURE);
    } 
    out_file << out_row << "\n";
  }
 cleanup:
  if (in_file.is_open()) {
    in_file.close();
  }
  if (out_file.is_open()) {
    out_file.close();
  }
  /* Delete the out file if we are not successful */
  if (ret != EXIT_SUCCESS) {
    remove(out_file_name); /* Don't handle errors here */
  } 
  return ret;
}
