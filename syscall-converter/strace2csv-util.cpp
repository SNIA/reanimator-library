/*
 * Copyright (c) 2015-2016 Leixiang Wu
 * Copyright (c) 2015-2016 Shubhi Rani
 * Copyright (c) 2015-2016 Sonam Mandal
 * Copyright (c) 2015-2016 Erez Zadok 
 * Copyright (c) 2011-2012 Jack Ma
 * Copyright (c) 2011-2012 Vasily Tarasov
 * Copyright (c) 2011-2012 Santhosh Kumar Koundinya
 * Copyright (c) 2011-2012 Geoff Kuenning
 * Copyright (c) 2011-2012 Stony Brook University
 * Copyright (c) 2011-2012 Harvey Mudd College
 * Copyright (c) 2011-2012 The Research Foundation of SUNY
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 *
 * This source file provides utility functions for strace2csv.
 * These utility are going to be needed and used by strace2csv program.
 * These functions are usually invoked by strace2csv program to help 
 * itself converting system call traces generated by command strace
 * to CSV traces in a format that is defined in strace.spec.
 */

#include <iostream>
#include <vector>
#include <sstream>
#include <string>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

#include <boost/algorithm/string.hpp>
#include <boost/tokenizer.hpp>

bool process_ret_info(const std::string &ret_info,
                      std::vector<std::string> &ret_fields);
int errno_lookup(const std::string &errno_symbol);
bool process_sys_call_info(const std::string &sys_call_info, 
			   std::vector<std::string> &sys_call_fields);
void remove_spaces_after_comma(std::string &sys_call_csv_args);
bool process_open_args(std::string &sys_call_csv_args);
bool process_open_flags(const std::string &flags_arg, 
			std::vector<std::string> &flags_vector);
bool process_mode(const std::string &mode_arg,
		  std::vector<std::string> &mode_vector);
bool process_lseek_args(std::string &sys_call_csv_args);

/*
 * The input expected by csv2ds: <extent name>, <fields>.
 * However, traces generated by strace is are ordered as follows:
 * relative_timestamp syscall(args) = return_val
 * Example: 0.000061 close(3)                  = 0
 * Therefore, this function will converts traces generated by 
 * strace to CSV traces.
 * 
 * @param in_row: string object where the strace record is stored.
 *                The contents in the string are fixed.
 * @param out_row: string object where the CSV record is stored.
 *                 Basically, the result will be stored in this string.
 * @return: true if the row is processed succesfully, false otherwise.
 * 
 * Consult the SNIA POSIX System Call Trace format specification document 
 * strace man page for more details about the format.
 */
bool process_row(const std::string &in_row, std::string &out_row) {
  // Check to see if it reaches end of trace file.
  if (in_row.find("exited") != std::string::npos)
    return true;
  
  /* 
   * Split return information and system call information.
   * The input fields are ordered as follows.
   * relative_timestamp syscall(args) = return_val
   */
  std::string splitter = " = ";
  size_t found = in_row.rfind(splitter);
  // Check to make sure the sys call trace record is valid.
  if (found == std::string::npos) {
    std::cerr << "SYS: Malformed record: '" << in_row << "'. = is missing.\n";
    return false;
  }
  
  // Get system call information and return information
  std::string sys_call_info = in_row.substr(0, found);
  // Eliminate leading and trailing spaces
  boost::trim(sys_call_info);
  // A vector to hold all system call fields - name, time, args, etc..
  std::vector<std::string> sys_call_fields;
  if (process_sys_call_info(sys_call_info, sys_call_fields) == false) {
    return false;
  }
  std::string ret_info = in_row.substr(found + splitter.size());
  // A vector to store all return information - return value and errno
  std::vector<std::string> ret_info_fields;
  if (process_ret_info(ret_info, ret_info_fields) == false) {
    return false;
  }
  // The starting index of return info should be index 2.
  sys_call_fields.insert(sys_call_fields.begin()+2, ret_info_fields.begin(),
			 ret_info_fields.end());
  
  /*
   * Right now we don't need to worry about this. So comment it out.
   * DataSeries expects the time in Tfracs. One tfrac is 1/(2^32) of a
   * second 
   uint64_t rel_timestamp = (uint64_t)(atof(fields[0].c_str()) *
   (((uint64_t)1)<<32));
   // Make sure timestamp is valid.
   if (rel_timestamp < 0) {
   clog << "SYS: Malformed relative timestamp: '" << fields[0] << "'.";
   clog << "Timestamp less than 0.\n";
   return false;
   }
  */

  // Now, combine all fields into a CSV string
  out_row = boost::algorithm::join(sys_call_fields, ",");
  return true;
}


/*
 * Extract return fields from traces
 * that are generated by strace and store those
 * values into a vector.
 *
 * @param ret_info: string object where the return
 *                      information is stored.
 * @param ret_fields: vector object where the return fields
 *                    are going to be stored.
 *                    position 0: return value
 *                    position 1: errno num
 * @return: true if ret info is parsed succesfully, false otherwise.
 */
bool process_ret_info(const std::string &ret_info,
		      std::vector<std::string> &ret_info_fields) {
  // Split return values, errno symbol, and error string
  std::vector<std::string> ret_fields;
  boost::split(ret_fields, ret_info,
	       boost::is_any_of(" \t"), boost::token_compress_on);
  if (ret_fields.size() < 1) {
    std::cerr << "'" << ret_info << "' has too few return info.\n";
    return false;
  }
  // Store return value in 1st position
  ret_info_fields.push_back(ret_fields[0]);
  // Check to see if there is an errno
  if (ret_fields.size() > 1) {
    // Store errno num in 2nd position if there is an errno
    int errno_num = errno_lookup(ret_fields[1]);
    ret_info_fields.push_back(std::to_string(errno_num));
  } else {
    // Store 0 as the errno num which means that there is no errno
    ret_info_fields.push_back("0");
  }
  return true;
}

/*
 * Lookup the given errno symbol that strace captured and
 * converts it to errno number. Then return the errno number
 * Right now, it does simple if statements to determine errno.
 * Adding a new errno simply requires you to add the if statement
 * in the following function.
 *
 * @param errno_symbol: string object where the errno symbol is stored
 * @return: errno number that corresponds ot given errno symbol
 */
int errno_lookup(const std::string &errno_symbol) {
  if (errno_symbol == "ENOENT") {
    return ENOENT;
  } else if (errno_symbol == "EACCES") {
    return EACCES;
  } else if (errno_symbol == "EBADF") {
    return EBADF;
  }
  return ENOENT;
}

/*
 * Extract system call arguments, name, time, etc
 * from the given system call information and store
 * those values into a vector.
 * 
 * @param sys_call_info: string object where the system call
 *                       information is stored.
 *                       format: timestamp syscall(args)
 * @param sys_call_fields: vector object where the sys call fields are stored.
 *                         position 0: sys call name
 *                         position 1: time_called
 *                         position 2: sys call arguments in CSV format.
 * @return: true if sys call info is parsed succesfully, false otherwise.
 */
bool process_sys_call_info(const std::string &sys_call_info,
			   std::vector<std::string> &sys_call_fields) {
  // Find first '(' and last of ')' because parentheses may appear in the argument
  size_t left_paren_index = sys_call_info.find_first_of("(");
  size_t right_paren_index = sys_call_info.find_last_of(")");
  // Without '(' or ')' characters in the record, it is invalid.
  if (left_paren_index == std::string::npos || right_paren_index == std::string::npos) {
    std::cerr << "'" << sys_call_info << "' doesn't have ( or ).\n";
    return false;
  }
  // Get system call time and name
  std::string sys_call_time_and_name = sys_call_info.substr(0, left_paren_index);
  
  // Split system call name and time stamp
  std::vector<std::string> fields;
  boost::split(fields, sys_call_time_and_name, boost::is_any_of(" \t"), boost::token_compress_on);
  if (fields.size() < 2) {
    std::cerr << "'" << sys_call_info << "' doesn't have time called or sys call name.\n";
    return false;
  }
  std::string time_called = fields[0];
  std::string sys_call_name = fields[1];
  
  // IMPORTANT: order matters!!
  sys_call_fields.push_back(sys_call_name);
  sys_call_fields.push_back(time_called);
  
  // Everything within '(' and ')' is our argument information of this system call.
  std::string sys_call_csv_args = sys_call_info.substr(left_paren_index + 1,
						       right_paren_index - left_paren_index - 1);
  
  // Remove the space after comma in sys call arguments
  remove_spaces_after_comma(sys_call_csv_args);
  // Process open and lseek system call arguments.
  if (sys_call_name == "open" && process_open_args(sys_call_csv_args) == false) {
    return false;
  } else if (sys_call_name == "lseek" && process_lseek_args(sys_call_csv_args) == false) {
    return false;
  }

  sys_call_fields.push_back(sys_call_csv_args);
  return true;
}

/*
 * In strace system call trace, system call arguments have following
 * format:(arg1, arg2, arg3, arg4, ...)
 * Having spaces after every comma can cause some troubles since
 * boost CSV tokenizer doesn't ignore leading and trailing whitespace.
 * Therefore, this function removes spaces after comma in system
 * call arguments string and return the modified string.
 * 
 * @param sys_call_csv_args: string object that is going to modified.
 *                           It changes to a string that has system call
 *                           arguments without spaces after comma.
 */
void remove_spaces_after_comma(std::string &sys_call_csv_args) {
  size_t length = sys_call_csv_args.size();
  for (size_t letter_index = 0;
       letter_index < length;
       letter_index++) {
    char letter = sys_call_csv_args[letter_index];
    // Test to see whether the letter is an opening quote?
    if (letter == '"' && letter_index - 1 >= 0 &&
	sys_call_csv_args[letter_index - 1] != '\\') {
      // Let's find the closing quote.
      size_t closing_quote_index = letter_index + 1;
      bool closing_quote_found = false;
      while (!closing_quote_found) {
	// Skip all the characters that are not '"'
	while (closing_quote_index < length &&
	       sys_call_csv_args[closing_quote_index] != '"') {
	  closing_quote_index++;
	}
	// Let's test to make sure it is a closing quote
	if (closing_quote_index >= length) {
	  std::cerr << "Closing quote is missing!" << std::endl;
	} else if (sys_call_csv_args[closing_quote_index - 1] != '\\') {
	  // It is a closing quote and update looping index.
	  letter_index = closing_quote_index;
	  closing_quote_found = true;
	} else {
	  closing_quote_index++;
	}
      }
    } else if (letter == ',') {
      // Now, we know the quote isn't inside of quotes and remove spaces after comma
      size_t space_index = letter_index + 1;
      while (space_index < length && sys_call_csv_args[space_index] == ' ') {
	// It is ', ', so we delete the space.
	sys_call_csv_args.erase(sys_call_csv_args.begin() + space_index);
	length = sys_call_csv_args.size();
      }
    } else {
      // Do nothing
    }
  }
}

/*
 * Converts open system call arguments that are in strace
 * format (path,flags,mode|none) to arguments that are in 
 * SNIA POSIX System Call Trace format (path,O_RDONLY,O_WR_ONLY,...) which
 * is the standard I/O trace format.
 *
 * @param sys_call_csv_args: string object where the SNIA format system call
 *                           arguments are going to be stored.
 *                           Originally:format: path,flags,mode|none
 *                           After function succesfully executed:
 *                           path,0,0,1,0,...
 * @return: true if open args are parsed succesfully, false otherwise.
 */
bool process_open_args(std::string &sys_call_csv_args) {
  // Parse CSV traced open arguments
  boost::tokenizer<boost::escaped_list_separator<char> > args_tokenizer(sys_call_csv_args);
  std::vector<std::string> sys_call_args;
  // Store CSV arguments into a vector
  sys_call_args.assign(args_tokenizer.begin(), args_tokenizer.end());
  // Make sure open trace has more than 1 argument.
  if (sys_call_args.size() < 2) {
    std::cerr << "'" << sys_call_csv_args << "' has too few arguments.\n";
    return false;
  }
  
  // Get each argument and store it in a variable
  std::string path_name = sys_call_args[0];
  std::string flags_arg = sys_call_args[1];
  
  /*
   * Flags vector contains all individual flag
   * The vector is ordered as follows:
   * flag_read_only,flag_write_only,flag_read_and_write,flag_append,..
   * Example: 0,0,1,0,1,...
   */
  std::vector<std::string> flags_vector;
  if (process_open_flags(flags_arg, flags_vector) == false) {
    return false;
  }
  
  /* 
   * The vector is represented as follows:
   * mode_R_user,mode_W_user,...
   * Example: 777,1,1,...
   */
  std::vector<std::string> mode_vector(9,"0");
  // Assume this is two arguments open sys call
  std::string mode_arg = "0";
  // Check to see if modes are set in this open sys call.
  if (sys_call_args.size() == 3) {
    mode_arg = sys_call_args[2];
    // Get modes and store them into mode_vector
    if (process_mode(mode_arg, mode_vector) == false) {
      return false;
    }
  }
  
  // Combine open system call arguments into a CSV string
  std::stringstream csv_args_stream;
  csv_args_stream << path_name << ","
		  << boost::algorithm::join(flags_vector, ",") << ","
		  << mode_arg << "," << boost::algorithm::join(mode_vector, ",");
  sys_call_csv_args = csv_args_stream.str();
  return true;
}

/*
 * The CSV open flags argument ouput expected by csv2ds is:
 * flag_read_only,flag_write_only,flag_read_and_write,flag_append,..
 * However, the flag argument generated by strace is O_RDONLY|O_WRONLY...
 * Thus, this function extracts individual open flag
 * (ex. O_RDONLY,O_WRONLY,...) 
 * from the given system call flags arguments and store the flags 
 * value and those individual open flags into a vector.
 * 
 * @param flags_arg: string object where the system call flags argument
 *                   is stored
 * @param flags_vector: vector object where individual flags are stored
 *                      position 0 is for flags value
 *                      position 1 is for O_RDONLY
 *                      position 2 is for O_WRONLY
 *                      ...
 * @return: true if sys call flags argument is divided succesfully, false otherwise.
 *
 * Note: Consult the SNIA POSIX System Call Trace format specification 
 * document and open for more details.
 */
bool process_open_flags(const std::string &flags_arg,
			std::vector<std::string> &flags_vector) {
  std::vector<std::string> flags_arg_vector;
  // Split the flags argument into a vector.
  boost::split(flags_arg_vector, flags_arg, boost::is_any_of("|"), boost::token_compress_on);
  
  /* 
   * The vector is ordered as follows:
   * flags value,flag_read_only,flag_write_only,flag_read_and_write,flag_append,..
   * Example: 0x100,0,0,1,0,1,...
   * Processing a new flag requires you to expand the size of the vector
   * and add an if statement in here.
   * Note: remeber to fix this function documentation if you add another flag.
   */
  flags_vector.assign(19, "0");
  
  // This stores the starting index of individual flag.
  int i = 1;
  // This stores flags value.
  int flags_val = 0;
  for (std::string flag : flags_arg_vector) {
    if (flag.compare("O_RDONLY") == 0) {
      flags_val |= O_RDONLY;
      flags_vector[i+0] = "1";
      //flag_map["O_RDONLY"] = 1;
    } else if (flag.compare("O_WRONLY") == 0) {
      flags_val |= O_WRONLY;
      flags_vector[i+1] = "1";
      //flag_map["O_WRONLY"] = 1;
    } else if (flag.compare("O_RDWR") == 0) {
      flags_val |= O_RDWR;
      flags_vector[i+2] = "1";
      //flag_map["O_RDWR"] = 1;
    } else if (flag.compare("O_APPEND") == 0) {
      flags_val |= O_APPEND;
      flags_vector[i+3] = "1";
      //flag_map["O_APPEND"] = 1;
    } else if (flag.compare("O_ASYNC") == 0) {
      flags_val |= O_ASYNC;
      flags_vector[i+4] = "1";
      //flag_map["O_ASYNC"] = 1;
    } else if (flag == "O_CLOEXEC") {
      flags_val |= O_CLOEXEC;
      flags_vector[i+5] = "1";
      //flag_map["O_CLOEXEC"] = 1;
    } else if (flag.compare("O_CREAT") == 0) {
      flags_val |= O_CREAT;
      flags_vector[i+6] = "1";
      //flag_map["O_CREAT"] = 1;
    } else if (flag.compare("O_DIRECT") == 0) {
      flags_val |= O_DIRECT;
      flags_vector[i+7] = "1";
      //flag_map["O_DIRECT"] = 1;
    } else if (flag.compare("O_DIRECTORY") == 0) {
      flags_val |= O_DIRECTORY;
      flags_vector[i+8] = "1";
      //flag_map["O_DIRECTORY"] = 1;
    } else if (flag.compare("O_EXCL") == 0) {
      flags_val |= O_EXCL;
      flags_vector[i+9] = "1";
      //flag_map["O_EXCL"] = 1;
    } else if (flag.compare("O_LARGEFILE") == 0) {
      flags_val |= O_LARGEFILE;
      flags_vector[i+10] = "1";
      //flag_map["O_LARGEFILE"] = 1;
    } else if (flag.compare("O_NOATIME") == 0) {
      flags_val |= O_NOATIME;
      flags_vector[i+11] = "1";
      //flag_map["O_NOATIME"] = 1;
    } else if (flag.compare("O_NOCTTY") == 0) {
      flags_val |= O_NOCTTY;
      flags_vector[i+12] = "1";
      //flag_map["O_NOCTTY"] = 1;
    } else if (flag.compare("O_NOFOLLOW") == 0) {
      flags_val |= O_NOFOLLOW;
      flags_vector[i+13] = "1";
      //flag_map["O_NOFOLLOW"] = 1;
    } else if (flag.compare("O_NONBLOCK") == 0) {
      flags_val |= O_NONBLOCK;
      flags_vector[i+14] = "1";
      //flag_map["O_NONBLOCK"] = 1;
    } else if (flag.compare("O_NDELAY") == 0) {
      flags_val |= O_NDELAY;
      flags_vector[i+15] = "1";
      //flag_map["O_NDELAY"] = 1;
    } else if (flag.compare("O_SYNC") == 0) {
      flags_val |= O_SYNC;
      flags_vector[i+16] = "1";
      //flag_map["O_SYNC"] = 1;
    } else if (flag.compare("O_TRUNC") == 0) {
      flags_val |= O_TRUNC;
      flags_vector[i+17] = "1";
      //flag_map["O_TRUNC"] = 1;
    } else {
      std::cerr << "Unknown flag: '" << flag << "'.\n";
      return false;
    }
  }
  // Store flags value as the first value in the vector.
  flags_vector[0] = std::to_string(flags_val);
  return true;
}

/*
 * The format of mode in strace is xxxx.
 * Example: 0777,0666,0700
 * Rightmost digit represents others permission
 * Second of rightmost digit represents group permission
 * Second of leftmost digit represents user permission
 * However, the standard system call trace CSV format should be
 * 0,0,0,1,1,... where each entry indicates whether corresponding
 * permission is granted.
 * Adding a new permission requires you to set starting_index variable
 * to a value that is mutiple of 3.
 * 
 * This function extracts individual mode (read, write, and execute permission
 * for each user) from the given system call mode argument and store
 * those individual mode into a vector.
 * 
 * @param mode_arg: string object where the system call mode argument
 *                   is stored
 * @param mode_vector: vector object where individual mode is stored
 *                     mode_vector[0] -> user read permission
 *                     mode_vector[1] -> user write permission
 *                     mode_vector[2] -> user execute permission
 *                     mode_vector[3] -> group read permission
 *                     ...
 *                     owner_start_index = 0 for user, 3 for group, 6 for others
 * @return: true if sys call mode argument is divided succesfully, false otherwise.
 * 
 * Note: Consult the Open man page for more details about mode.
 */
bool process_mode(const std::string &mode_arg,
		       std::vector<std::string> &mode_vector) {
  for (int i = 3; i > 0; i--) {
    /*
     * others_permission -> mode_arg.at(mode_arg.length()-1);
     * group_permission -> mode_arg.at(mode_arg.length()-2);
     * user_permission -> mode_arg.at(mode_arg.length()-3);
     */
    char c_permission = mode_arg.at(mode_arg.length() - i);
    if (isdigit(c_permission)) {
      /*
       * mode_vector[0] -> user read permission
       * mode_vector[1] -> user write permission
       * mode_vector[2] -> user execute permission
       * mode_vector[3] -> group read permission
       * ...
       * owner_start_index = 0 for user, 3 for group, 6 for others
       */
      int start_index = 0;
      switch(i) {
      case 3:
	// User
	start_index = 0;
	break;
      case 2:
	// Group
	start_index = 3;
	break;
      case 1:
	// Others
	start_index = 6;
	break;
      }
      
      int permission = c_permission - '0';
      switch(permission) {
      case 0:
	// no permission
	mode_vector[0 + start_index] = "0";
	mode_vector[1 + start_index] = "0";
	mode_vector[2 + start_index] = "0";
	break;
      case 1:
	// execute permission
	mode_vector[0 + start_index] = "0";
	mode_vector[1 + start_index] = "0";
	mode_vector[2 + start_index] = "1";
	break;
      case 2:
	// write permission
	mode_vector[0 + start_index] = "0";
	mode_vector[1 + start_index] = "1";
	mode_vector[2 + start_index] = "0";
	break;
      case 3:
	// execute and write permission
	mode_vector[0 + start_index] = "0";
	mode_vector[1 + start_index] = "1";
	mode_vector[2 + start_index] = "1";
	break;
      case 4:
	// read permission
	mode_vector[0 + start_index] = "1";
	mode_vector[1 + start_index] = "0";
	mode_vector[2 + start_index] = "0";
	break;
      case 5:
	// read and execute permission
	mode_vector[0 + start_index] = "1";
	mode_vector[1 + start_index] = "0";
	mode_vector[2 + start_index] = "1";
	break;
      case 6:
	// read and write permission
	mode_vector[0 + start_index] = "1";
	mode_vector[1 + start_index] = "1";
	mode_vector[2 + start_index] = "0";
	break;
      case 7:
	// read, write, and execute permission
	mode_vector[0 + start_index] = "1";
	mode_vector[1 + start_index] = "1";
	mode_vector[2 + start_index] = "1";
	break;
      default:
	// error, unknown permission
	std::cerr << "Unknown permission: '" << c_permission << "'.\n";
	return false;
      }
    } else {
      std::cerr << "Unknown permission: '" << c_permission << "'.\n";
      return false;
    }
  }
  return true;
}

/*
 * Converts lseek system call arguments that are in strace
 * format (descriptor, offset, SEEK_SET|CUR|END) to arguments that are in 
 * SNIA POSIX System Call Trace format (descriptor,offset,0|1|2) which
 * is the standard I/O trace format.
 *
 * @param sys_call_csv_args: string object where the SNIA format system call
 *                           arguments are going to be stored.
 *                           Originally:format: fd,offset,SEEK_SET
 *                           After this function succesfully executed:
 *                           fd,offset,0|1|2
 * @return: true if lseek args are parsed succesfully, false otherwise.
 */
bool process_lseek_args(std::string &sys_call_csv_args) {
  // Parse CSV traced open arguments.
  boost::tokenizer<boost::escaped_list_separator<char> > args_tokenizer(sys_call_csv_args);
  std::vector<std::string> sys_call_args;
  // Store arguments into a sys_call_args vector.
  sys_call_args.assign(args_tokenizer.begin(), args_tokenizer.end());
  // Make sure this traced lseek sys call has three arguments.
  if (sys_call_args.size() != 3) {
    std::cerr << "'" << sys_call_csv_args << "' has too few arguments.\n";
    return false;
  }
  
  // Get whence argument
  std::string whence_str = sys_call_args[2];
  // Determine whence and replace SEEK_XXX with a number.
  if (whence_str == "SEEK_SET") {
    sys_call_args[2] = "0";
  } else if (whence_str == "SEEK_CUR") {
    sys_call_args[2] = "1";
  } else if (whence_str == "SEEK_END") {
    sys_call_args[2] = "2";
  } else {
    std::cerr << "Unknown whence: '" << whence_str << "'.\n";
    return false;
  }
  // Combine lseek arguments into a CSV string
  sys_call_csv_args = boost::algorithm::join(sys_call_args, ",");
  return true;
}
