/*
 * Copyright (c) 2015-2016 Leixiang Wu
 * Copyright (c) 2015-2016 Shubhi Rani
 * Copyright (c) 2015-2016 Sonam Mandal
 * Copyright (c) 2015-2016 Erez Zadok 
 * Copyright (c) 2011-2012 Jack Ma
 * Copyright (c) 2011-2012 Vasily Tarasov
 * Copyright (c) 2011-2012 Santhosh Kumar Koundinya
 * Copyright (c) 2011-2012 Geoff Kuenning
 * Copyright (c) 2011-2012 Stony Brook University
 * Copyright (c) 2011-2012 Harvey Mudd College
 * Copyright (c) 2011-2012 The Research Foundation of SUNY
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 *
 * This source file provides utility functions for strace2csv.
 * These utility are going to be needed and used by strace2csv program.
 * These functions are usually invoked by strace2csv program to help 
 * itself converting system call traces generated by command strace
 * to CSV traces in a format that is defined in strace.spec.
 */

#include <iostream>
#include <vector>
#include <sstream>
#include <string>
#include <regex>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

#include <boost/algorithm/string.hpp>
#include <boost/tokenizer.hpp>

bool process_ret_info(const std::string &ret_info,
                      std::vector<std::string> &ret_fields);
int errno_lookup(const std::string &errno_symbol);
bool process_sys_call_info(const std::string &sys_call_info, 
			   std::vector<std::string> &sys_call_fields);
void remove_spaces_after_comma(std::string &sys_call_csv_args);
bool process_open_args(std::string &sys_call_csv_args);
bool process_open_flags(const std::string &flags_arg, 
			std::vector<std::string> &flags_vector);
bool process_mode(const std::string &mode_arg,
		  std::vector<std::string> &mode_vector);
bool process_lseek_args(std::string &sys_call_csv_args);
bool process_stat_args(std::string &sys_call_csv_args);
bool split_stat_args(std::string &sys_call_args);
bool process_stat_mode(std::string &stat_mode_string);
bool get_stat_fields(std::vector<std::string> &sys_call_args);
bool convert_timeStamp_to_epoch(std::string timestamp,
                                std::string &epoch);
bool process_mkdir_args(std::string &sys_call_csv_args);

/*
 * The input expected by csv2ds: <extent name>, <fields>.
 * However, traces generated by strace is are ordered as follows:
 * relative_timestamp syscall(args) = return_val
 * Example: 0.000061 close(3)                  = 0
 * Therefore, this function will converts traces generated by 
 * strace to CSV traces.
 * 
 * @param in_row: string object where the strace record is stored.
 *                The contents in the string are fixed.
 * @param out_row: string object where the CSV record is stored.
 *                 Basically, the result will be stored in this string.
 * @return: true if the row is processed succesfully, false otherwise.
 * 
 * Consult the SNIA POSIX System Call Trace format specification document 
 * strace man page for more details about the format.
 */
bool process_row(const std::string &in_row, std::string &out_row) {
  /* 
   * Split return information and system call information.
   * The input fields are ordered as follows.
   * relative_timestamp syscall(args) = return_val
   */
  std::string splitter = " = ";
  size_t found = in_row.rfind(splitter);
  // Check to make sure the sys call trace record is valid.
  if (found == std::string::npos) {
    /*
     * Check to see if it reaches the last line of trace file.
     * It looks like 'time_called +++ exited with 1 +++'
     */
    std::regex last_line_regex(".*+++ exited with .* +++$");

    if (std::regex_match(in_row, last_line_regex)) {
      // Set output row to an empty string - append nothing to CSV output file.
      out_row = "";
      return true;
    } else {
      std::cerr << "Malformed record: '" << in_row << "'. = is missing.\n";
      return false;
    }
  }
  
  // Get system call information and return information
  std::string sys_call_info = in_row.substr(0, found);
  // Eliminate leading and trailing spaces
  boost::trim(sys_call_info);
  // A vector to hold all system call fields - name, time, args, etc..
  std::vector<std::string> sys_call_fields;
  if (process_sys_call_info(sys_call_info, sys_call_fields) == false) {
    return false;
  }
  std::string ret_info = in_row.substr(found + splitter.size());
  // A vector to store all return information - errno and return value
  std::vector<std::string> ret_info_fields;
  if (process_ret_info(ret_info, ret_info_fields) == false) {
    return false;
  }
  // The starting index of return info should be index 2.
  sys_call_fields.insert(sys_call_fields.begin()+2, ret_info_fields.begin(),
			 ret_info_fields.end());
  
  /*
   * Right now we don't need to worry about this. So comment it out.
   * DataSeries expects the time in Tfracs. One tfrac is 1/(2^32) of a
   * second 
   uint64_t rel_timestamp = (uint64_t)(atof(fields[0].c_str()) *
   (((uint64_t)1)<<32));
   // Make sure timestamp is valid.
   if (rel_timestamp < 0) {
   clog << "SYS: Malformed relative timestamp: '" << fields[0] << "'.";
   clog << "Timestamp less than 0.\n";
   return false;
   }
  */

  // Now, combine all fields into a CSV string
  out_row = boost::algorithm::join(sys_call_fields, ",") + "\n";
  return true;
}


/*
 * Extract return fields from traces
 * that are generated by strace and store those
 * values into a vector.
 *
 * @param ret_info: string object where the return
 *                      information is stored.
 * @param ret_fields: vector object where the return fields
 *                    are going to be stored.
 *                    position 0: errno num
 *                    position 1: return value
 *                    position 2: unique id
 * @return: true if ret info is parsed succesfully, false otherwise.
 */
bool process_ret_info(const std::string &ret_info,
		      std::vector<std::string> &ret_info_fields) {
  // Split return values, errno symbol, and error string
  std::vector<std::string> ret_fields;
  boost::split(ret_fields, ret_info,
	       boost::is_any_of(" \t"), boost::token_compress_on);
  if (ret_fields.size() < 1) {
    std::cerr << "'" << ret_info << "' has too few return info.\n";
    return false;
  }
  // Check to see if there is an errno
  if (ret_fields.size() > 1) {
    // Store errno num in 2nd position if there is an errno
    int errno_num = errno_lookup(ret_fields[1]);
    ret_info_fields.push_back(std::to_string(errno_num));
  } else {
    // Store 0 as the errno num which means that there is no errno
    ret_info_fields.push_back("0");
  }
  // Store return value in 2nd position
  ret_info_fields.push_back(ret_fields[0]);
  // This variable is defined in strace2csv.cpp
  extern int64_t row_num;
  ret_info_fields.push_back(std::to_string(row_num));
  return true;
}

/*
 * Lookup the given errno symbol that strace captured and
 * converts it to errno number. Then return the errno number
 * Right now, it does simple if statements to determine errno.
 * Adding a new errno simply requires you to add the if statement
 * in the following function.
 *
 * @param errno_symbol: string object where the errno symbol is stored
 * @return: errno number that corresponds ot given errno symbol
 */
int errno_lookup(const std::string &errno_symbol) {
  if (errno_symbol == "ENOENT") {
    return ENOENT;
  } else if (errno_symbol == "EACCES") {
    return EACCES;
  } else if (errno_symbol == "EBADF") {
    return EBADF;
  }
  return ENOENT;
}

/*
 * Extract system call arguments, name, time, etc
 * from the given system call information and store
 * those values into a vector.
 * 
 * @param sys_call_info: string object where the system call
 *                       information is stored.
 *                       format: timestamp syscall(args)
 * @param sys_call_fields: vector object where the sys call fields are stored.
 *                         position 0: sys call name
 *                         position 1: time_called
 *                         position 2: sys call arguments in CSV format.
 * @return: true if sys call info is parsed succesfully, false otherwise.
 */
bool process_sys_call_info(const std::string &sys_call_info,
			   std::vector<std::string> &sys_call_fields) {
  // Find first '(' and last of ')' because parentheses may appear in the argument
  size_t left_paren_index = sys_call_info.find_first_of("(");
  size_t right_paren_index = sys_call_info.find_last_of(")");
  // Without '(' or ')' characters in the record, it is invalid.
  if (left_paren_index == std::string::npos || right_paren_index == std::string::npos) {
    std::cerr << "'" << sys_call_info << "' doesn't have ( or ).\n";
    return false;
  }
  // Get system call time and name
  std::string sys_call_time_and_name = sys_call_info.substr(0, left_paren_index);
  
  // Split system call name and time stamp
  std::vector<std::string> fields;
  boost::split(fields, sys_call_time_and_name, boost::is_any_of(" \t"), boost::token_compress_on);
  if (fields.size() < 2) {
    std::cerr << "'" << sys_call_info << "' doesn't have time called or sys call name.\n";
    return false;
  }
  std::string time_called = fields[0];
  std::string sys_call_name = fields[1];
  
  // IMPORTANT: order matters!!
  sys_call_fields.push_back(sys_call_name);
  sys_call_fields.push_back(time_called);
  
  // Everything within '(' and ')' is our argument information of this system call.
  std::string sys_call_csv_args = sys_call_info.substr(left_paren_index + 1,
						       right_paren_index - left_paren_index - 1);
  
  // Remove the space after comma in sys call arguments
  remove_spaces_after_comma(sys_call_csv_args);
  // Process open and lseek system call arguments.
  if (sys_call_name == "open" && process_open_args(sys_call_csv_args) == false) {
    return false;
  } else if (sys_call_name == "lseek" && process_lseek_args(sys_call_csv_args) == false) {
    return false;
  } else if (sys_call_name == "mkdir" && process_mkdir_args(sys_call_csv_args) == false) {
    return false;
  } else if (sys_call_name == "stat" && process_stat_args(sys_call_csv_args) == false) {
    return false;
  }

  sys_call_fields.push_back(sys_call_csv_args);
  return true;
}

/*
 * In strace system call trace, system call arguments have following
 * format:(arg1, arg2, arg3, arg4, ...)
 * Having spaces after every comma can cause some troubles since
 * boost CSV tokenizer doesn't ignore leading and trailing whitespace.
 * Therefore, this function removes spaces after comma in system
 * call arguments string and return the modified string.
 * 
 * @param sys_call_csv_args: string object that is going to modified.
 *                           It changes to a string that has system call
 *                           arguments without spaces after comma.
 */
void remove_spaces_after_comma(std::string &sys_call_csv_args) {
  size_t length = sys_call_csv_args.size();
  for (size_t letter_index = 0;
       letter_index < length;
       letter_index++) {
    char letter = sys_call_csv_args[letter_index];
    // Test to see whether the letter is an opening quote?
    if (letter == '"' && letter_index - 1 >= 0 &&
	sys_call_csv_args[letter_index - 1] != '\\') {
      // Let's find the closing quote.
      size_t closing_quote_index = letter_index + 1;
      bool closing_quote_found = false;
      while (!closing_quote_found) {
	// Skip all the characters that are not '"'
	while (closing_quote_index < length &&
	       sys_call_csv_args[closing_quote_index] != '"') {
	  closing_quote_index++;
	}
	// Let's test to make sure it is a closing quote
	if (closing_quote_index >= length) {
	  std::cerr << "Closing quote is missing!" << std::endl;
	} else if (sys_call_csv_args[closing_quote_index - 1] != '\\') {
	  // It is a closing quote and update looping index.
	  letter_index = closing_quote_index;
	  closing_quote_found = true;
	} else {
	  closing_quote_index++;
	}
      }
    } else if (letter == ',') {
      // Now, we know the quote isn't inside of quotes and remove spaces after comma
      size_t space_index = letter_index + 1;
      while (space_index < length && sys_call_csv_args[space_index] == ' ') {
	// It is ', ', so we delete the space.
	sys_call_csv_args.erase(sys_call_csv_args.begin() + space_index);
	length = sys_call_csv_args.size();
      }
    } else {
      // Do nothing
    }
  }
}

/*
 * Converts open system call arguments that are in strace
 * format (path,flags,mode|none) to arguments that are in 
 * SNIA POSIX System Call Trace format (path,O_RDONLY,O_WR_ONLY,...) which
 * is the standard I/O trace format.
 *
 * @param sys_call_csv_args: string object where the SNIA format system call
 *                           arguments are going to be stored.
 *                           Originally:format: path,flags,mode|none
 *                           After function succesfully executed:
 *                           path,0,0,1,0,...
 * @return: true if open args are parsed succesfully, false otherwise.
 */
bool process_open_args(std::string &sys_call_csv_args) {
  // Parse CSV traced open arguments
  boost::tokenizer<boost::escaped_list_separator<char> > args_tokenizer(sys_call_csv_args);
  std::vector<std::string> sys_call_args;
  // Store CSV arguments into a vector
  sys_call_args.assign(args_tokenizer.begin(), args_tokenizer.end());
  // Make sure open trace has more than 1 argument.
  if (sys_call_args.size() < 2) {
    std::cerr << "'" << sys_call_csv_args << "' has too few arguments.\n";
    return false;
  }
  
  // Get each argument and store it in a variable
  std::string path_name = sys_call_args[0];
  std::string flags_arg = sys_call_args[1];
  
  /*
   * Flags vector contains all individual flag
   * The vector is ordered as follows:
   * flag_read_only,flag_write_only,flag_read_and_write,flag_append,..
   * Example: 0,0,1,0,1,...
   */
  std::vector<std::string> flags_vector;
  if (process_open_flags(flags_arg, flags_vector) == false) {
    return false;
  }
  
  /* 
   * The vector is represented as follows:
   * mode_R_user,mode_W_user,...
   * Example: 0777,1,1,...
   */
  std::vector<std::string> mode_vector(12,"0");
  // Assume this is two arguments open sys call
  std::string mode_arg = "0";
  // Check to see if modes are set in this open sys call.
  if (sys_call_args.size() == 3) {
    mode_arg = sys_call_args[2];
    // Get modes and store them into mode_vector
    if (process_mode(mode_arg, mode_vector) == false) {
      return false;
    }
  }
  
  // Combine open system call arguments into a CSV string
  std::stringstream csv_args_stream;
  csv_args_stream << path_name << ","
		  << boost::algorithm::join(flags_vector, ",") << ","
		  << mode_arg << "," << boost::algorithm::join(mode_vector, ",");
  sys_call_csv_args = csv_args_stream.str();
  return true;
}

/*
 * The CSV open flags argument ouput expected by csv2ds is:
 * flag_read_only,flag_write_only,flag_read_and_write,flag_append,..
 * However, the flag argument generated by strace is O_RDONLY|O_WRONLY...
 * Thus, this function extracts individual open flag
 * (ex. O_RDONLY,O_WRONLY,...) 
 * from the given system call flags arguments and store the flags 
 * value and those individual open flags into a vector.
 * 
 * @param flags_arg: string object where the system call flags argument
 *                   is stored
 * @param flags_vector: vector object where individual flags are stored
 *                      position 0 is for flags value
 *                      position 1 is for O_RDONLY
 *                      position 2 is for O_WRONLY
 *                      ...
 * @return: true if sys call flags argument is divided succesfully, false otherwise.
 *
 * Note: Consult the SNIA POSIX System Call Trace format specification 
 * document and open for more details.
 */
bool process_open_flags(const std::string &flags_arg,
			std::vector<std::string> &flags_vector) {
  std::vector<std::string> flags_arg_vector;
  // Split the flags argument into a vector.
  boost::split(flags_arg_vector, flags_arg, boost::is_any_of("|"), boost::token_compress_on);
  
  /* 
   * The vector is ordered as follows:
   * flags value,flag_read_only,flag_write_only,flag_read_and_write,flag_append,..
   * Example: 0x100,0,0,1,0,1,...
   * Processing a new flag requires you to expand the size of the vector
   * and add an if statement in here.
   * Note: remeber to fix this function documentation if you add another flag.
   */
  flags_vector.assign(19, "0");
  
  // This stores the starting index of individual flag.
  int i = 1;
  // This stores flags value.
  int flags_val = 0;
  for (std::string flag : flags_arg_vector) {
    if (flag.compare("O_RDONLY") == 0) {
      flags_val |= O_RDONLY;
      flags_vector[i+0] = "1";
      //flag_map["O_RDONLY"] = 1;
    } else if (flag.compare("O_WRONLY") == 0) {
      flags_val |= O_WRONLY;
      flags_vector[i+1] = "1";
      //flag_map["O_WRONLY"] = 1;
    } else if (flag.compare("O_RDWR") == 0) {
      flags_val |= O_RDWR;
      flags_vector[i+2] = "1";
      //flag_map["O_RDWR"] = 1;
    } else if (flag.compare("O_APPEND") == 0) {
      flags_val |= O_APPEND;
      flags_vector[i+3] = "1";
      //flag_map["O_APPEND"] = 1;
    } else if (flag.compare("O_ASYNC") == 0) {
      flags_val |= O_ASYNC;
      flags_vector[i+4] = "1";
      //flag_map["O_ASYNC"] = 1;
    } else if (flag == "O_CLOEXEC") {
      flags_val |= O_CLOEXEC;
      flags_vector[i+5] = "1";
      //flag_map["O_CLOEXEC"] = 1;
    } else if (flag.compare("O_CREAT") == 0) {
      flags_val |= O_CREAT;
      flags_vector[i+6] = "1";
      //flag_map["O_CREAT"] = 1;
    } else if (flag.compare("O_DIRECT") == 0) {
      flags_val |= O_DIRECT;
      flags_vector[i+7] = "1";
      //flag_map["O_DIRECT"] = 1;
    } else if (flag.compare("O_DIRECTORY") == 0) {
      flags_val |= O_DIRECTORY;
      flags_vector[i+8] = "1";
      //flag_map["O_DIRECTORY"] = 1;
    } else if (flag.compare("O_EXCL") == 0) {
      flags_val |= O_EXCL;
      flags_vector[i+9] = "1";
      //flag_map["O_EXCL"] = 1;
    } else if (flag.compare("O_LARGEFILE") == 0) {
      flags_val |= O_LARGEFILE;
      flags_vector[i+10] = "1";
      //flag_map["O_LARGEFILE"] = 1;
    } else if (flag.compare("O_NOATIME") == 0) {
      flags_val |= O_NOATIME;
      flags_vector[i+11] = "1";
      //flag_map["O_NOATIME"] = 1;
    } else if (flag.compare("O_NOCTTY") == 0) {
      flags_val |= O_NOCTTY;
      flags_vector[i+12] = "1";
      //flag_map["O_NOCTTY"] = 1;
    } else if (flag.compare("O_NOFOLLOW") == 0) {
      flags_val |= O_NOFOLLOW;
      flags_vector[i+13] = "1";
      //flag_map["O_NOFOLLOW"] = 1;
    } else if (flag.compare("O_NONBLOCK") == 0) {
      flags_val |= O_NONBLOCK;
      flags_vector[i+14] = "1";
      //flag_map["O_NONBLOCK"] = 1;
    } else if (flag.compare("O_NDELAY") == 0) {
      flags_val |= O_NDELAY;
      flags_vector[i+15] = "1";
      //flag_map["O_NDELAY"] = 1;
    } else if (flag.compare("O_SYNC") == 0) {
      flags_val |= O_SYNC;
      flags_vector[i+16] = "1";
      //flag_map["O_SYNC"] = 1;
    } else if (flag.compare("O_TRUNC") == 0) {
      flags_val |= O_TRUNC;
      flags_vector[i+17] = "1";
      //flag_map["O_TRUNC"] = 1;
    } else {
      std::cerr << "Unknown flag: '" << flag << "'.\n";
      return false;
    }
  }
  // Store flags value as the first value in the vector.
  flags_vector[0] = std::to_string(flags_val);
  return true;
}

/*
 * The format of mode in strace is xxxx.
 * Example: 0777,0666,0700
 * Rightmost digit represents others permission
 * Second of rightmost digit represents group permission
 * Second of leftmost digit represents user permission
 * However, the standard system call trace CSV format should be
 * 0,0,0,1,1,... where each entry indicates whether corresponding
 * permission is granted.
 * Adding a new permission requires you to set starting_index variable
 * to a value that is mutiple of 3.
 * 
 * This function extracts individual mode (read, write, and execute permission
 * for each user) from the given system call mode argument and store
 * those individual mode into a vector.
 * 
 * @param mode_arg: string object where the system call mode argument
 *                   is stored
 * @param mode_vector: vector object where individual mode is stored
 *                     mode_vector[0] -> user read permission
 *                     mode_vector[1] -> user write permission
 *                     mode_vector[2] -> user execute permission
 *                     mode_vector[3] -> group read permission
 *                     ...
 *                     owner_start_index = 0 for user, 3 for group, 6 for others
 * @return: true if sys call mode argument is divided succesfully, false otherwise.
 * 
 * Note: Consult the Open man page for more details about mode.
 */
bool process_mode(const std::string &mode_arg,
		       std::vector<std::string> &mode_vector) {
  for (int i = 4; i > 0; i--) {
    /*
     * others_permission -> mode_arg.at(mode_arg.length()-1);
     * group_permission -> mode_arg.at(mode_arg.length()-2);
     * user_permission -> mode_arg.at(mode_arg.length()-3);
     * set_permission -> mode_arg.at(mode_arg.length()-4);
     */
    char c_permission = mode_arg.at(mode_arg.length() - i);
    if (isdigit(c_permission)) {
      /*
       * mode_vector[0] -> user read permission
       * mode_vector[1] -> user write permission
       * mode_vector[2] -> user execute permission
       * mode_vector[3] -> group read permission
       * ...
       * owner_start_index = 0 for set-user-ID, 3 user, 6 for group, 9 for others
       */
      int start_index = 0;
      switch(i) {
      case 4:
	// set-user-id
	start_index = 0;
	break;
      case 3:
	// User
	start_index = 3;
	break;
      case 2:
	// Group
	start_index = 6;
	break;
      case 1:
	// Others
	start_index = 9;
	break;
      }

      int permission = c_permission - '0';
      switch(permission) {
      case 0:
	// no permission
	mode_vector[0 + start_index] = "0";
	mode_vector[1 + start_index] = "0";
	mode_vector[2 + start_index] = "0";
	break;
      case 1:
	// execute permission
	mode_vector[0 + start_index] = "0";
	mode_vector[1 + start_index] = "0";
	mode_vector[2 + start_index] = "1";
	break;
      case 2:
	// write permission
	mode_vector[0 + start_index] = "0";
	mode_vector[1 + start_index] = "1";
	mode_vector[2 + start_index] = "0";
	break;
      case 3:
	// execute and write permission
	mode_vector[0 + start_index] = "0";
	mode_vector[1 + start_index] = "1";
	mode_vector[2 + start_index] = "1";
	break;
      case 4:
	// read permission
	mode_vector[0 + start_index] = "1";
	mode_vector[1 + start_index] = "0";
	mode_vector[2 + start_index] = "0";
	break;
      case 5:
	// read and execute permission
	mode_vector[0 + start_index] = "1";
	mode_vector[1 + start_index] = "0";
	mode_vector[2 + start_index] = "1";
	break;
      case 6:
	// read and write permission
	mode_vector[0 + start_index] = "1";
	mode_vector[1 + start_index] = "1";
	mode_vector[2 + start_index] = "0";
	break;
      case 7:
	// read, write, and execute permission
	mode_vector[0 + start_index] = "1";
	mode_vector[1 + start_index] = "1";
	mode_vector[2 + start_index] = "1";
	break;
      default:
	// error, unknown permission
	std::cerr << "Unknown permission: '" << c_permission << "'.\n";
	return false;
      }
    } else {
      std::cerr << "Unknown permission: '" << c_permission << "'.\n";
      return false;
    }
  }
  return true;
}

/*
 * Converts lseek system call arguments that are in strace
 * format (descriptor, offset, SEEK_SET|CUR|END) to arguments that are in 
 * SNIA POSIX System Call Trace format (descriptor,offset,0|1|2) which
 * is the standard I/O trace format.
 *
 * @param sys_call_csv_args: string object where the SNIA format system call
 *                           arguments are going to be stored.
 *                           Originally:format: fd,offset,SEEK_SET
 *                           After this function succesfully executed:
 *                           fd,offset,0|1|2
 * @return: true if lseek args are parsed succesfully, false otherwise.
 */
bool process_lseek_args(std::string &sys_call_csv_args) {
  // Parse CSV traced open arguments.
  boost::tokenizer<boost::escaped_list_separator<char> > args_tokenizer(sys_call_csv_args);
  std::vector<std::string> sys_call_args;
  // Store arguments into a sys_call_args vector.
  sys_call_args.assign(args_tokenizer.begin(), args_tokenizer.end());
  // Make sure this traced lseek sys call has three arguments.
  if (sys_call_args.size() != 3) {
    std::cerr << "'" << sys_call_csv_args << "' has too few arguments.\n";
    return false;
  }
  
  // Get whence argument
  std::string whence_str = sys_call_args[2];
  // Determine whence and replace SEEK_XXX with a number.
  if (whence_str == "SEEK_SET") {
    sys_call_args[2] = "0";
  } else if (whence_str == "SEEK_CUR") {
    sys_call_args[2] = "1";
  } else if (whence_str == "SEEK_END") {
    sys_call_args[2] = "2";
  } else {
    std::cerr << "Unknown whence: '" << whence_str << "'.\n";
    return false;
  }
  // Combine lseek arguments into a CSV string
  sys_call_csv_args = boost::algorithm::join(sys_call_args, ",");
  return true;
}

/*
 * This function splits the stat sys call arguments and store them
 * in a vector.
 * sys call arguments are in format:
 *"Filename",{st_dev=makedev(252,0),st_ino=145210,st_mode=S_IFREG|0664,
 *            st_nlink=1,st_uid=1000,...}
 * @param sys_call_args: string object of system call arguments
 *
 * @param parsed_string_vector: string vector having tokenized sys call 
 *                              arguments. Vector will contain elements as:
 *                              "Filename"
 *                              st_dev=makedev(252,0)
 *                              st_ino=145210
 *                              ...
 *
 * @return: Return true if arguments are splitted successfully, 
 *          otherwise false.
 */
bool split_stat_args(std::string &sys_call_args, 
                     std::vector<std::string> &parsed_string_vector) {
  size_t index = 0;
  size_t last_index = 0;

  // First store the path of filename inquired by stat system call.
  size_t comma = sys_call_args.find_first_of(",");
  parsed_string_vector.push_back(sys_call_args.substr(0, comma));

  // Extract the substring representing struct stat buffer in strace.
  size_t left_curly_braces = sys_call_args.find_first_of("{");
  size_t right_curly_braces = sys_call_args.find_first_of("}");

  std::string stat_buffer_args = sys_call_args.substr(left_curly_braces + 1,
                                                      right_curly_braces - 
                                                      left_curly_braces - 1);

  size_t length = stat_buffer_args.size();

  // Now store each field of stat buffer in vector
  do {
    if (stat_buffer_args[index] == ',') {
      std::string args = stat_buffer_args.substr(last_index, index-last_index);
      // If opening bracket is found, continue until closing bracket is not found 
      if (args.find("(") != std::string::npos) {
        while (stat_buffer_args[index] != ')')
          index++;
        index++;
        args = stat_buffer_args.substr(last_index, index-last_index);
      }
      parsed_string_vector.push_back(args);
      last_index = index+1;
      }
    index++;
  } while (index < length);

  parsed_string_vector.push_back(stat_buffer_args.substr(last_index, index));

  return true;
}

/*
 * The format of timestamp in strace is YYYY/MM/DD-Hr:Min:Sec
 *
 * This function converts the timestamp relative to the Unix epoch.
 *
 * @param timestamp: string object representing timestamp format captured
 *                   in strace.
 *
 * @param epoch: string object representing timestamp relative to the
 *               Unix epoch.
 *
 * @return: Returns true if converted successfully, otherwise false.
 */
bool convert_timeStamp_to_epoch(std::string timestamp, 
                                std::string &epoch) {
  struct tm tm;
  time_t t_of_day;

  memset(&tm, 0, sizeof(struct tm));
  if(strptime(timestamp.c_str(), "%Y/%m/%d-%H:%M:%S", &tm) == NULL)
    return false;

  t_of_day = mktime(&tm);
  epoch = std::to_string(t_of_day);
  return true;
}

/*
 * The format of mode in strace is IS_TYPE|xxxx.
 * Example: ISREG|0777
 * 
 * This function extracts file type and file mode for each user from the 
 * given system call mode argument and returns the bitwise OR of file type
 * and file mode.
 * 
 * @param stat_mode_string: string object where the system call mode argument
 *                          is stored in format IS_TYPE|xxxx and is converted
 *                          as bitwise OR of IS_TYPE and xxxx.
 *                          
 * @return: Returns true if conversion is successful, otherwise false.  
 */

bool process_stat_mode(std::string &stat_mode_string) {
  std::vector<std::string> stat_mode_vector;
  int stat_mode;
  std::string file_type;
  long int file_mode;
  
  // Split the mode field of stat struture into a vector.
  boost::split(stat_mode_vector, stat_mode_string, boost::is_any_of("|"), boost::token_compress_on);
  
  if (stat_mode_vector.size() != 2) {
    std::cerr << "Stat mode argument is in wrong format" << std::endl;
    return false;
  }

  // Store file type
  file_type = stat_mode_vector[0];

  // Store file mode in octal
  char *file_mode_buffer = new char[stat_mode_vector[1].length() + 1];
  std::strcpy(file_mode_buffer, stat_mode_vector[1].c_str());
  int base = 8;
  file_mode = std::strtoul(file_mode_buffer, NULL, base);
  
  if (file_type.compare("S_IFSOCK") == 0) {
    //socket file
    stat_mode = (0140000 & 0170000) | file_mode;
  } else  if (file_type.compare("S_IFLNK") == 0) {
    //symbolic link
    stat_mode = (0120000 & 0170000) | file_mode;
  } else  if (file_type.compare("S_IFREG") == 0) {
    //regular file
    stat_mode = (0100000 & 0170000) | file_mode;
  } else  if (file_type.compare("S_IFBLK") == 0) {
    //block device
    stat_mode = (0060000 & 0170000) | file_mode;
  } else  if (file_type.compare("S_IFDIR") == 0) {
    //directory
    stat_mode = (0040000 & 0170000) | file_mode;
  } else  if (file_type.compare("S_IFCHR") == 0) {
    //character device
    stat_mode = (0020000 & 0170000) | file_mode;
  } else  if (file_type.compare("S_IFIFO") == 0) {
    //FIFO
    stat_mode = (0010000 & 0170000) | file_mode;
  } else {
    std::cerr << "Unknown file type.." << std::endl;
    return false;
  }

  stat_mode_string = std::to_string(stat_mode);
  return true;
}

/* Extacts the values of different fields of stat strucure and combine them
 * into a vector. The vector is ordered as: {st_inode, st_mode, st_nlink,
 * st_uid, st_gid, st_blksize, st_blocks, st_size, st_atime, st_mtime,
 * st_ctime}.
 *
 * @param sys_call_args : Each element of vector contains the different fields 
 *                        and their repective values. 
 *
 * @param stat_buf_vector: The values of different fields of stat structure are
 *                         Originally formated as: {st_ino=145210,st_mode=
 *                                                  IFREG|0664,st_nlink=1,...}
 *                         After completion, it converts it to a vector as:
 *                         {145310,33204,1,....}.
 *
 * @return: true if the values of each struct stat field is fetched, 
 * otherwise false; 
 */
bool get_stat_fields(std::vector<std::string> &sys_call_args,
                     std::vector<std::string> &stat_buf_vector) {
  for (unsigned int i=1; i<sys_call_args.size(); ++i) {
    std::vector<std::string> stat_fields_vector;
    std::string epoch;
    // Split and fetch the fields of stat argument into a vector.
    boost::split(stat_fields_vector, sys_call_args[i], boost::is_any_of("="), 
                 boost::token_compress_on); 
    
    if (stat_fields_vector[0].compare("st_dev") == 0) {
      std::vector<std::string> st_dev_vector;
      st_dev_vector = boost::split(st_dev_vector, stat_fields_vector[1], 
                      boost::is_any_of(",()"));
      // Call makedev function to get the value of st_dev field.
      dev_t st_dev = makedev(std::stoi(st_dev_vector[1]), 
                             std::stoi(st_dev_vector[2]));
      stat_buf_vector.push_back(std::to_string(st_dev));
    } else if (stat_fields_vector[0].compare("st_mode") == 0) {
      if(!process_stat_mode(stat_fields_vector[1]))
        return false;
      stat_buf_vector.push_back(stat_fields_vector[1]);
    } else if ((stat_fields_vector[0].compare("st_ino") == 0) || 
              (stat_fields_vector[0].compare("st_nlink") == 0) ||
              (stat_fields_vector[0].compare("st_uid") == 0) ||
              (stat_fields_vector[0].compare("st_gid") == 0) ||
              (stat_fields_vector[0].compare("st_size") == 0) ||
              (stat_fields_vector[0].compare("st_blksize") == 0) ||
              (stat_fields_vector[0].compare("st_blocks") == 0)) {
      stat_buf_vector.push_back(stat_fields_vector[1]);
    } else if ((stat_fields_vector[0].compare("st_ctime") == 0) ||
              (stat_fields_vector[0].compare("st_atime") == 0) ||
              (stat_fields_vector[0].compare("st_mtime") == 0)) {
      if (!convert_timeStamp_to_epoch(stat_fields_vector[1], epoch))
        return false;
      stat_buf_vector.push_back(epoch);
    } else {
      std::cerr << "Unknown field in stat buffer" << std::endl;
      return false;
    }
  }
  return true;
}

/*
 * Converts stat system call arguments that are in strace format to arguments
 * that are in SNIA POSIX System Call Trace format which is a standard IO 
 * trace format.
 * strace format: (pathname, {st_ino=145310,st_mode=IFREG|0664,st_nlink=1, ...}) 
 * SNIA POSIX format: (pathname, stat_result_ino, stat_result_mode, ...)
 *
 * @param sys_call_csv_args: string object where the SNIA format system call
 *                           arguments are going to be stored.
 *                           Originally format: pathname, {st_ino=145310,
 *                                              st_mode=IFREG|0664, ...}
 *                           After this function succesfully executed:
 *                           "pathname",33204,1764
 *
 * @return: true if stat args are parsed succesfully, false otherwise.
 */
bool process_stat_args(std::string &sys_call_csv_args) {
  std::vector<std::string> sys_call_args;

  // Store arguments into a sys_call_args vector.
  if (!split_stat_args(sys_call_csv_args, sys_call_args))
    return false;

  // Make sure this traced stat sys call has 13 arguments.
  if (sys_call_args.size() != 13) {
    std::cerr << "SYS: Malformed record: '" << sys_call_csv_args << "'. Too few arguments.\n";
    return false;
  }
 
  // Get arguments and store each one into a vector.
  std::string path_name = sys_call_args[0];
  std::vector<std::string> stat_fields_vector;
  
  if (!get_stat_fields(sys_call_args, stat_fields_vector))
    return false;

  // Combine stat arguments into a CSV string
  std::stringstream csv_args_stream;
  csv_args_stream << path_name << "," << boost::algorithm::join(stat_fields_vector, ",");
  sys_call_csv_args = csv_args_stream.str();
  return true;
}

/*
 * Converts mkdir system call arguments that are in strace format to arguments
 * that are in SNIA POSIX System Call Trace format which is a standard IO 
 * trace format.
 * strace format: (pathname, mode) 
 * SNIA POSIX format: (given_pathname, mode_value)
 *
 * @param sys_call_csv_args: string object where the SNIA format system call
 *                           arguments are going to be stored.
 *
 * @return: true if stat args are parsed succesfully, false otherwise.
 */

bool process_mkdir_args(std::string &sys_call_csv_args) {
  // Parse CSV traced mkdir arguments
  boost::tokenizer<boost::escaped_list_separator<char> > args_tokenizer(sys_call_csv_args);
  std::vector<std::string> sys_call_args;
  // Store CSV arguments into a vector
  sys_call_args.assign(args_tokenizer.begin(), args_tokenizer.end());
  // Make sure mkdir trace has 2 argument.
  if (sys_call_args.size() != 2) {
    std::cerr << "'" << sys_call_csv_args << "' has too few arguments.\n";
    return false;
  }

  // Get each argument and store it in a variable
  std::string path_name = sys_call_args[0];
  /* 
   * The vector is represented as follows:
   * mode_R_user,mode_W_user,...
   * Example: 0,0,...
   */
  std::string mode_arg = sys_call_args[1];
  std::vector<std::string> mode_vector(9,"0");
  // Get modes and store them into mode_vector
  if (process_mode(mode_arg, mode_vector) == false) {
    return false;
  }

  // Combine mkdir system call arguments into a CSV string
  std::stringstream csv_args_stream;
  csv_args_stream << path_name << "," << mode_arg << "," 
                  << boost::algorithm::join(mode_vector, ",");
  sys_call_csv_args = csv_args_stream.str();
  return true;
}
