diff --git a/Makefile.am b/Makefile.am
index 4f8904e..896c7f8 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -12,7 +12,8 @@ filebench_SOURCES = eventgen.c fb_avl.c fb_localfs.c \
 		    eventgen.h  fb_random.h  fileset.h  fsplug.h \
 		    ipc.h   multi_client_sync.h  parsertypes.h  stats.h \
 		    utils.h config.h fb_avl.h filebench.h flowop.h gamma_dist.h \
-		    misc.h procflow.h threadflow.h vars.h posset.h ioprio.h flag.h
+		    misc.h procflow.h threadflow.h vars.h posset.h ioprio.h flag.h \
+		    fb_cvar.c fb_cvar.h
 
 EXTRA_DIST = LICENSE
 
diff --git a/cvars/Makefile b/cvars/Makefile
new file mode 100644
index 0000000..b1f925c
--- /dev/null
+++ b/cvars/Makefile
@@ -0,0 +1,58 @@
+.PHONEY : all
+all : utils rand-distributions
+
+.PHONEY : utils
+utils : mtwist tokens test
+
+.PHONEY :mtwist
+mtwist :
+	cd utils/mtwist; ${MAKE}
+
+.PHONEY : tokens
+tokens :
+	cd utils/tokens; ${MAKE}
+
+.PHONEY : test
+test :
+	cd utils/test; ${MAKE}
+
+.PHONEY : rand-distributions
+rand-distributions :
+	cd rand-empirical; ${MAKE}
+	cd rand-erlang; ${MAKE}
+	cd rand-exponential; ${MAKE}
+	cd rand-lognormal; ${MAKE}
+	cd rand-normal; ${MAKE}
+	cd rand-triangular; ${MAKE}
+	cd rand-uniform; ${MAKE}
+	cd rand-weibull; ${MAKE}
+
+.PHONEY : clean
+clean :	clean-utils clean-rand-distributions
+
+.PHONEY : clean-rand-distributions
+clean-rand-distributions :
+	cd rand-empirical; ${MAKE} clean 
+	cd rand-erlang; ${MAKE} clean
+	cd rand-exponential; ${MAKE} clean
+	cd rand-lognormal; ${MAKE} clean
+	cd rand-normal; ${MAKE} clean
+	cd rand-triangular; ${MAKE} clean
+	cd rand-uniform; ${MAKE} clean
+	cd rand-weibull; ${MAKE} clean
+
+.PHONEY : clean-utils
+clean-utils : clean-mtwist clean-tokens clean-test
+
+.PHONEY : clean-mtwist
+clean-mtwist :
+	cd utils/mtwist; ${MAKE} clean
+
+.PHONEY : clean-tokens
+clean-tokens :
+	cd utils/tokens; ${MAKE} clean
+
+.PHONEY : clean-test
+clean-test:
+	cd utils/test; ${MAKE} clean
+ 
\ No newline at end of file
diff --git a/cvars/rand-empirical/.cvsignore b/cvars/rand-empirical/.cvsignore
new file mode 100644
index 0000000..6b519a5
--- /dev/null
+++ b/cvars/rand-empirical/.cvsignore
@@ -0,0 +1 @@
+librand-empirical.so.0.1.1
diff --git a/cvars/rand-empirical/Makefile b/cvars/rand-empirical/Makefile
new file mode 100644
index 0000000..3cf88d8
--- /dev/null
+++ b/cvars/rand-empirical/Makefile
@@ -0,0 +1,24 @@
+CC=gcc
+CFLAGS=-g -O0 -Wall -DDEBUG
+MAJOR_VERSION=0.1
+MINOR_VERSION=1 # Release number.
+FILEBENCHDIR=/usr/local/share
+CVAR_NAME=rand-empirical
+
+.PHONEY : all
+all : ${CVAR_NAME}
+
+${CVAR_NAME} : ${CVAR_NAME}.h ${CVAR_NAME}.c
+	${CC} ${CFLAGS} -I../utils -I../utils/tokens -I../utils/mtwist -fPIC -c \
+	  ${CVAR_NAME}.c
+	${CC} ${CFLAGS} -shared -Wl,-soname,lib${CVAR_NAME}.so.${MAJOR_VERSION} \
+	  -Wl,--no-undefined \
+	  -o lib${CVAR_NAME}.so.${MAJOR_VERSION}.${MINOR_VERSION} -lc -lm \
+	  ../utils/mtwist/mtwist.o ../utils/mtwist/randistrs.o \
+	  ../utils/tokens/cvar_tokens.o ${CVAR_NAME}.o
+	cp lib${CVAR_NAME}.so.${MAJOR_VERSION}.${MINOR_VERSION} \
+	  ${FILEBENCHDIR}/filebench/cvars/
+
+.PHONEY : clean
+clean :
+	rm -f ${CVAR_NAME}.o lib${CVAR_NAME}.so.${MAJOR_VERSION}.${MINOR_VERSION}
diff --git a/cvars/rand-empirical/rand-empirical.c b/cvars/rand-empirical/rand-empirical.c
new file mode 100644
index 0000000..13256d5
--- /dev/null
+++ b/cvars/rand-empirical/rand-empirical.c
@@ -0,0 +1,256 @@
+/*
+ * iosize-empirical.c
+ *
+ * Author: Gajanana (gajanana@gfsl.cs.stonybrook.edu)
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <errno.h>
+
+#include <mtwist.h>
+#include <randistrs.h>
+
+#include <cvar.h>
+#include <cvar_trace.h>
+#include <cvar_tokens.h>
+
+#include "rand-empirical.h"
+
+void *cvar_alloc_handle(const char *cvar_parameters,
+		void *(*cvar_malloc)(size_t size), void (*cvar_free)(void *cvar_ptr))
+{
+	cvar_token_t *list_head;;
+	cvar_token_t *t;
+	handle_t handle;
+	handle_t *state = NULL;
+	int ret = 0;
+
+	cvar_trace("entry");
+
+	/* Tokenize parameters supplied by filebench. */
+	list_head = NULL;
+	ret = tokenize(cvar_parameters, DEFAULT_PARAMETER_DELIMITER,
+			DEFAULT_KEY_VALUE_DELIMITER, &list_head);
+	if (ret)
+		goto out;
+
+	/* Get the location of the file storing the cumulative distribution function*/
+	t = find_token(list_head, CDF_FILENAME);
+	if (t && t->value) {
+		t->used = 1;
+		memcpy(handle.cdf_filename, t->value, MAX_FILENAME_LEN);
+		handle.cdf_filename[MAX_FILENAME_LEN] = '\0';
+	} else {
+		cvar_log_error("Missing file path");
+		goto out;
+	}
+
+	handle.values = NULL;
+	handle.cdfs = NULL;
+	handle.size = 0;
+
+	cvar_trace("cdf_filename = %s", handle.cdf_filename);
+
+	/* Seed the state. */
+	mts_seed32(&handle.state, 0);
+
+	/* All set. Now allocate space for the handle in the shared segment and
+	 * copy the state over. */
+	state = (handle_t *) cvar_malloc(sizeof(handle_t));
+	if (!state) {
+		cvar_log_error("Out of memory");
+		goto out;
+	}
+
+	*state = handle;
+
+out:
+	free_tokens(list_head);
+
+	cvar_trace("exit");
+	return state;
+}
+
+int cvar_revalidate_handle(void *cvar_handle)
+{
+	handle_t *h = (handle_t *) cvar_handle;
+	char *line_buff = NULL;
+	size_t line_buff_size;
+	FILE *fp = NULL;
+	int i;
+	char *cdf_start = NULL;
+	int ret = -1;
+	int capacity = 1;
+	void *mem = NULL;
+
+	mts_mark_initialized(&h->state);
+	cvar_trace("state handle marked as initialized");
+
+	h->values = (long *) malloc(capacity * sizeof(long));
+	if (!h->values) {
+	  cvar_log_error("Out of memory");
+	  goto out;
+	}
+	cvar_trace("h->values array allocated");
+
+	h->cdfs = (double *) malloc(capacity * sizeof(double));
+	if (!h->cdfs) {
+	  cvar_log_error("Out of memory");
+	  goto out;
+	}
+	cvar_trace("h->cdfs array allocated");
+
+	fp = fopen(h->cdf_filename, "r");
+	if (!fp) {
+	  cvar_log_error("Unable to open cdf file '%s': %s.", h->cdf_filename,
+	      strerror(errno));
+	  goto out;
+	}
+	cvar_trace("Cumulative Distrbution Function file %s opened", h->cdf_filename);
+
+	line_buff_size = 512;
+	line_buff = (char *) malloc(line_buff_size * sizeof(char));
+	if (!line_buff) {
+	  cvar_log_error("Out of memory");
+	  goto out;
+	}
+
+	for (i = 0; getline(&line_buff, &line_buff_size, fp) != -1; i++) {
+	  if (i == capacity) {
+	    capacity *= 2;
+
+	    mem = realloc(h->values, capacity * sizeof(long));
+	    if (!mem) {
+	      cvar_log_error("Out of memory");
+	      goto out;
+	    }
+	    h->values = (long *) mem;
+
+	    mem = realloc(h->cdfs, capacity * sizeof(double));
+	    if (!mem) {
+	      cvar_log_error("Out of memory");
+	      goto out;
+	    }
+	    h->cdfs = (double *) mem;
+	  }
+
+	  h->values[i] = strtol(line_buff, &cdf_start, 10);
+	  h->cdfs[i] = strtod(cdf_start + 1, NULL);
+	}
+	cvar_trace("%d entries found in CDF file", i);
+
+	h->size = i;
+
+	if (h->size == 0) {
+	  cvar_log_error("No entries found in file");
+	  goto out;
+	}
+
+	mem = realloc(h->values, (h->size + 1) * sizeof(long));
+	if (!mem) {
+	  cvar_log_error("Unable to shrink memory");
+	  goto out;
+	}
+	h->values = (long *) mem;
+
+	mem = realloc(h->cdfs, (h->size + 1) * sizeof(double));
+	if (!mem) {
+	  cvar_log_error("Unable to shrink memory");
+	  goto out;
+	}
+	h->cdfs = (double *) mem;
+
+	cvar_trace("CDF load complete");
+
+	/* All is well! */
+	ret = 0;
+
+out:
+  if (fp)
+    fclose(fp);
+
+  if (ret) {
+    if (h->values)
+      free(h->values);
+
+    if (h->cdfs)
+      free(h->cdfs);
+  }
+
+  if (line_buff)
+    free(line_buff);
+
+	return ret;
+}
+
+int cvar_next_value(void *cvar_handle, double *value)
+{
+	handle_t *h = (handle_t *) cvar_handle;
+	double rv;
+	int start, end, mid;
+
+	if (!h) {
+		cvar_log_error("NULL cvar_handle");
+		return -1;
+	}
+
+	if (!value) {
+		cvar_log_error("NULL value");
+		return -1;
+	}
+
+	if (h->size == 1) {
+	  *value = h->values[0];
+	  return 0;
+	}
+
+	rv = mts_ldrand(&h->state);
+	start = 0;
+	end = h->size - 1;
+
+	while(1) {
+	  if ((start + 1) == end) {
+	    if ((end == 1) && (h->cdfs[0] >= rv)) {
+	      *value = (double) h->values[0];
+	    } else if ((start == (h->size - 2)) &&
+	        (h->cdfs[h->size - 1] <= rv)) {
+	      *value = (double) h->values[h->size - 1];
+	    } else {
+	      *value = (double) h->values[end];
+	    }
+
+	    break;
+	  }
+
+	  mid = start + ((end - start) / 2) + 1;
+	  if ((mid % 2) == 1) {
+	    if (h->cdfs[mid - 1] > rv) {
+	      end = mid - 1;
+	    } else if (h->cdfs[mid] < rv) {
+	      start = mid;
+	    } else {
+	      /* We found what we are looking for */
+        *value = (double) h->values[mid];
+        break;
+	    }
+	  } else {
+	    if (h->cdfs[mid - 1] > rv) {
+	      end = mid - 1;
+	    } else if (h->cdfs[mid + 1] < rv) {
+	      start = mid + 1;
+	    } else {
+	      /* We found what we were looking for */
+	      if (h->cdfs[mid] < rv) {
+	        *value = (double) h->values[mid + 1];
+	      } else {
+	        *value = (double) h->values[mid];
+	      }
+	      break;
+	    }
+	  }
+	}
+
+	return 0;
+}
diff --git a/cvars/rand-empirical/rand-empirical.h b/cvars/rand-empirical/rand-empirical.h
new file mode 100644
index 0000000..92e7152
--- /dev/null
+++ b/cvars/rand-empirical/rand-empirical.h
@@ -0,0 +1,26 @@
+/*
+ * iosize-empirical.h
+ *
+ * Author: Gajanana (gajanana@gfsl.cs.stonybrook.edu)
+ */
+
+#ifndef _RAND_EMPIRICAL_H
+#define _RAND_EMPIRICAL_H
+
+#include <mtwist.h>
+
+/* Parameters recognized by this variable. */
+#define CDF_FILENAME "cdf_filename"
+
+#define MAX_FILENAME_LEN  256
+
+/* The handle that will be returned to Filebench. */
+typedef struct handle {
+	mt_state state;
+	char cdf_filename[MAX_FILENAME_LEN + 1];
+	long *values;
+	double *cdfs;
+	int size;
+} handle_t;
+
+#endif /* _RAND_EMPIRICAL_H */
diff --git a/cvars/rand-erlang/.cvsignore b/cvars/rand-erlang/.cvsignore
new file mode 100644
index 0000000..634dae6
--- /dev/null
+++ b/cvars/rand-erlang/.cvsignore
@@ -0,0 +1 @@
+librand-erlang.so*
diff --git a/cvars/rand-erlang/Makefile b/cvars/rand-erlang/Makefile
new file mode 100644
index 0000000..2828cc8
--- /dev/null
+++ b/cvars/rand-erlang/Makefile
@@ -0,0 +1,24 @@
+CC=gcc
+CFLAGS=-g -O0 -Wall -DDEBUG
+MAJOR_VERSION=0.1
+MINOR_VERSION=1 # Release number.
+FILEBENCHDIR=/usr/local/share
+CVAR_NAME=rand-erlang
+
+.PHONEY : all
+all : ${CVAR_NAME}
+
+${CVAR_NAME} : ${CVAR_NAME}.h ${CVAR_NAME}.c
+	${CC} ${CFLAGS} -I../utils -I../utils/tokens -I../utils/mtwist -fPIC -c \
+	  ${CVAR_NAME}.c
+	${CC} ${CFLAGS} -shared -Wl,-soname,lib${CVAR_NAME}.so.${MAJOR_VERSION} \
+	  -Wl,--no-undefined \
+	  -o lib${CVAR_NAME}.so.${MAJOR_VERSION}.${MINOR_VERSION} -lc -lm \
+	  ../utils/mtwist/mtwist.o ../utils/mtwist/randistrs.o \
+	  ../utils/tokens/cvar_tokens.o ${CVAR_NAME}.o
+	cp lib${CVAR_NAME}.so.${MAJOR_VERSION}.${MINOR_VERSION} \
+	  ${FILEBENCHDIR}/filebench/cvars/
+
+.PHONEY : clean
+clean :
+	rm -f ${CVAR_NAME}.o lib${CVAR_NAME}.so.${MAJOR_VERSION}.${MINOR_VERSION}
diff --git a/cvars/rand-erlang/rand-erlang.c b/cvars/rand-erlang/rand-erlang.c
new file mode 100644
index 0000000..842c8c1
--- /dev/null
+++ b/cvars/rand-erlang/rand-erlang.c
@@ -0,0 +1,156 @@
+/*
+ * rand-erlang.c
+ *
+ * Custom variable that returns random numbers following the Erlang
+ * distribution.
+ *
+ * Author: Santhosh Kumar Koundinya (santhosh@fsl.cs.sunysb.edu)
+ */
+
+#include <stdio.h>
+#include <mtwist.h>
+#include <randistrs.h>
+#include <cvar.h>
+#include <cvar_trace.h>
+#include <cvar_tokens.h>
+#include "rand-erlang.h"
+
+void *cvar_alloc_handle(const char *cvar_parameters,
+		void *(*cvar_malloc)(size_t size), void (*cvar_free)(void *cvar_ptr))
+{
+	cvar_token_t *list_head;;
+	cvar_token_t *t;
+	handle_t handle;
+	handle_t *state = NULL;
+	int ret = 0;
+
+	cvar_trace("entry");
+
+	/* Tokenize parameters supplied by filebench. */
+	list_head = NULL;
+	ret = tokenize(cvar_parameters, DEFAULT_PARAMETER_DELIMITER,
+			DEFAULT_KEY_VALUE_DELIMITER, &list_head);
+	if (ret)
+		goto out;
+
+	/* Get the value of shape and rate. */
+	t = find_token(list_head, RER_SHAPE);
+	if (t && t->value) {
+		t->used = 1;
+		handle.shape = atoi(t->value);
+	} else
+		handle.shape = RER_SHAPE_DEFAULT;
+
+	t = find_token(list_head, RER_RATE);
+	if (t && t->value) {
+		t->used = 1;
+		handle.rate = atof(t->value);
+	} else
+		handle.rate = RER_RATE_DEFAULT;
+
+	cvar_trace("shape = %d, rate = %lf", handle.shape, handle.rate);
+
+	/* Validate parameters. */
+	if (handle.shape < 0) {
+		cvar_log_error("Invalid parameter value: shape = %d. shape is a "
+				"non-zero positive integer", handle.shape);
+		goto out;
+	}
+
+	if (handle.rate < 0) {
+		cvar_log_error("Invalid parameter value: rate = %lf. rate is a "
+				"non-zero positive rational number", handle.rate);
+		goto out;
+	}
+
+	t = unused_tokens(list_head);
+	if (t) {
+		cvar_log_error("Unsupported parameter %s", t->key);
+		goto out;
+	}
+
+	/* Seed the state. */
+	mts_goodseed(&handle.state);
+
+	/* All set. Now allocate space for the handle in the shared segment and
+	 * copy the state over. */
+	state = (handle_t *) cvar_malloc(sizeof(handle_t));
+	if (!state) {
+		cvar_log_error("Out of memory");
+		goto out;
+	}
+
+	*state = handle;
+
+out:
+	free_tokens(list_head);
+
+	cvar_trace("exit");
+	return state;
+}
+
+int cvar_revalidate_handle(void *cvar_handle)
+{
+	handle_t *h = (handle_t *) cvar_handle;
+
+	mts_mark_initialized(&h->state);
+
+	return 0;
+}
+
+int cvar_next_value(void *cvar_handle, double *value)
+{
+	handle_t *h = (handle_t *) cvar_handle;
+
+	if (!h) {
+		cvar_trace("NULL cvar_handle");
+		return -1;
+	}
+
+	if (!value) {
+		cvar_trace("NULL value");
+		return -1;
+	}
+
+	*value = rds_erlang(&h->state, h->shape, h->rate);
+
+	return 0;
+}
+
+const char *cvar_usage()
+{
+	int offset;
+
+	if (usage[0])
+		return usage;
+
+	offset = 0;
+
+	offset += snprintf(usage + offset, USAGE_LEN - offset,
+			"\tparameter\tdefault\n");
+	offset += snprintf(usage + offset, USAGE_LEN - offset,
+			"\t---------\t-------\n");
+
+	offset += snprintf(usage + offset, USAGE_LEN - offset,
+			"\t%s\t\t%d\n", RER_SHAPE, RER_SHAPE_DEFAULT);
+	offset += snprintf(usage + offset, USAGE_LEN - offset,
+			"\t%s\t\t%.1f\n", RER_RATE, RER_RATE_DEFAULT);
+
+	offset += snprintf(usage + offset, USAGE_LEN - offset,
+			"Use '%c' to delimit parameters and '%c' to delimit key-value "
+			"pairs.\n", DEFAULT_PARAMETER_DELIMITER,
+			DEFAULT_KEY_VALUE_DELIMITER);
+
+	offset += snprintf(usage + offset, USAGE_LEN - offset,
+			"Example: '%s%c%d%c%s%c%.1f'",
+			RER_SHAPE, DEFAULT_KEY_VALUE_DELIMITER, RER_SHAPE_DEFAULT,
+			DEFAULT_PARAMETER_DELIMITER,
+			RER_RATE, DEFAULT_KEY_VALUE_DELIMITER, RER_RATE_DEFAULT);
+
+	return usage;
+}
+
+const char *cvar_version()
+{
+	return VERSION;
+}
diff --git a/cvars/rand-erlang/rand-erlang.h b/cvars/rand-erlang/rand-erlang.h
new file mode 100644
index 0000000..e812dbe
--- /dev/null
+++ b/cvars/rand-erlang/rand-erlang.h
@@ -0,0 +1,37 @@
+/*
+ * rand-erlang.h
+ *
+ * Custom variable that returns random numbers following the Erlang
+ * distribution.
+ *
+ * Author: Santhosh Kumar Koundinya (santhosh@fsl.cs.sunysb.edu)
+ */
+
+#ifndef _RAND_ERLANG_H
+#define _RAND_ERLANG_H
+
+#include <mtwist.h>
+
+/* Parameters recognized by this variable. */
+#define RER_SHAPE	"shape"
+#define RER_RATE	"rate"
+
+/* Parameter defaults. */
+#define RER_SHAPE_DEFAULT	1
+#define RER_RATE_DEFAULT	1.0
+
+#define VERSION	"0.1.1 (alpha)"
+
+/* The handle that will be returned to Filebench. */
+typedef struct handle {
+	mt_state state;
+	int shape;
+	double rate;
+} handle_t;
+
+/* Static buffer to hold the usage string */
+#define USAGE_LEN	2048
+
+char usage[USAGE_LEN + 1] = {0};
+
+#endif /* _RAND_ERLANG_H */
diff --git a/cvars/rand-exponential/.cvsignore b/cvars/rand-exponential/.cvsignore
new file mode 100644
index 0000000..d6f895d
--- /dev/null
+++ b/cvars/rand-exponential/.cvsignore
@@ -0,0 +1 @@
+librand-exponential.so*
diff --git a/cvars/rand-exponential/Makefile b/cvars/rand-exponential/Makefile
new file mode 100644
index 0000000..1b95d27
--- /dev/null
+++ b/cvars/rand-exponential/Makefile
@@ -0,0 +1,24 @@
+CC=gcc
+CFLAGS=-g -O0 -Wall -DDEBUG
+MAJOR_VERSION=0.1
+MINOR_VERSION=1 # Release number.
+FILEBENCHDIR=/usr/local/share
+CVAR_NAME=rand-exponential
+
+.PHONEY : all
+all : ${CVAR_NAME}
+
+${CVAR_NAME} : ${CVAR_NAME}.h ${CVAR_NAME}.c
+	${CC} ${CFLAGS} -I../utils -I../utils/tokens -I../utils/mtwist -fPIC -c \
+	  ${CVAR_NAME}.c
+	${CC} ${CFLAGS} -shared -Wl,-soname,lib${CVAR_NAME}.so.${MAJOR_VERSION} \
+	  -Wl,--no-undefined \
+	  -o lib${CVAR_NAME}.so.${MAJOR_VERSION}.${MINOR_VERSION} -lc -lm \
+	  ../utils/mtwist/mtwist.o ../utils/mtwist/randistrs.o \
+	  ../utils/tokens/cvar_tokens.o ${CVAR_NAME}.o
+	cp lib${CVAR_NAME}.so.${MAJOR_VERSION}.${MINOR_VERSION} \
+	  ${FILEBENCHDIR}/filebench/cvars/
+
+.PHONEY : clean
+clean :
+	rm -f ${CVAR_NAME}.o lib${CVAR_NAME}.so.${MAJOR_VERSION}.${MINOR_VERSION}
diff --git a/cvars/rand-exponential/rand-exponential.c b/cvars/rand-exponential/rand-exponential.c
new file mode 100644
index 0000000..ccda5d5
--- /dev/null
+++ b/cvars/rand-exponential/rand-exponential.c
@@ -0,0 +1,136 @@
+/*
+ * rand-exponential.c
+ *
+ * Custom variable implementation that returns exponentially distributed random
+ * numbers.
+ *
+ * Author: Santhosh Kumar Koundinya (santhosh@fsl.cs.sunysb.edu)
+ */
+
+#include <stdio.h>
+#include <mtwist.h>
+#include <randistrs.h>
+#include <cvar.h>
+#include <cvar_trace.h>
+#include <cvar_tokens.h>
+#include "rand-exponential.h"
+
+void *cvar_alloc_handle(const char *cvar_parameters,
+		void *(*cvar_malloc)(size_t size), void (*cvar_free)(void *cvar_ptr))
+{
+	cvar_token_t *list_head;;
+	cvar_token_t *t;
+	handle_t handle;
+	handle_t *state = NULL;
+	int ret = 0;
+
+	cvar_trace("entry");
+
+	/* Tokenize parameters supplied by filebench. */
+	list_head = NULL;
+	ret = tokenize(cvar_parameters, DEFAULT_PARAMETER_DELIMITER,
+			DEFAULT_KEY_VALUE_DELIMITER, &list_head);
+	if (ret)
+		goto out;
+
+	/* Get the value of mean. */
+	t = find_token(list_head, RE_MEAN);
+	if (t && t->value) {
+		t->used = 1;
+		handle.mean = atof(t->value);
+	} else
+		handle.mean = RE_MEAN_DEFAULT;
+
+	cvar_trace("mean = %lf", handle.mean);
+
+	/* The Exponential PDF is defined to be 0 for mean < 0. */
+	if (handle.mean < 0) {
+		cvar_trace("Setting mean to 0");
+		handle.mean = 0;
+	}
+
+	t = unused_tokens(list_head);
+	if (t) {
+		cvar_log_error("Unsupported parameter %s", t->key);
+		goto out;
+	}
+
+	/* Seed the state. */
+	mts_goodseed(&handle.state);
+
+	/* All set. Now allocate space for the handle in the shared segment and
+	 * copy the state over. */
+	state = (handle_t *) cvar_malloc(sizeof(handle_t));
+	if (!state) {
+		cvar_log_error("Out of memory");
+		goto out;
+	}
+
+	*state = handle;
+
+out:
+	free_tokens(list_head);
+
+	cvar_trace("exit");
+	return state;
+}
+
+int cvar_revalidate_handle(void *cvar_handle)
+{
+	handle_t *h = (handle_t *) cvar_handle;
+
+	mts_mark_initialized(&h->state);
+
+	return 0;
+}
+
+int cvar_next_value(void *cvar_handle, double *value)
+{
+	handle_t *h = (handle_t *) cvar_handle;
+
+	if (!h) {
+		cvar_trace("NULL cvar_handle");
+		return -1;
+	}
+
+	if (!value) {
+		cvar_trace("NULL value");
+		return -1;
+	}
+
+	*value = rds_exponential(&h->state, h->mean);
+
+	return 0;
+}
+
+const char *cvar_usage()
+{
+	int offset;
+
+	if (usage[0])
+		return usage;
+
+	offset = 0;
+
+	offset += snprintf(usage + offset, USAGE_LEN - offset,
+			"\tparameter\tdefault\n");
+	offset += snprintf(usage + offset, USAGE_LEN - offset,
+			"\t---------\t-------\n");
+
+	offset += snprintf(usage + offset, USAGE_LEN - offset,
+			"\t%s\t\t%.1f\n", RE_MEAN, RE_MEAN_DEFAULT);
+
+	offset += snprintf(usage + offset, USAGE_LEN - offset,
+			"Use '%c' for assignment.\n", DEFAULT_KEY_VALUE_DELIMITER);
+
+	offset += snprintf(usage + offset, USAGE_LEN - offset,
+			"Example: '%s%c%.1f'",
+			RE_MEAN, DEFAULT_KEY_VALUE_DELIMITER, RE_MEAN_DEFAULT);
+
+	return usage;
+}
+
+const char *cvar_version()
+{
+	return VERSION;
+}
diff --git a/cvars/rand-exponential/rand-exponential.h b/cvars/rand-exponential/rand-exponential.h
new file mode 100644
index 0000000..8e96b3c
--- /dev/null
+++ b/cvars/rand-exponential/rand-exponential.h
@@ -0,0 +1,34 @@
+/*
+ * rand-exponential.h
+ *
+ * Custom variable implementation that returns exponentially distributed random
+ * numbers.
+ *
+ * Author: Santhosh Kumar Koundinya (santhosh@fsl.cs.sunysb.edu)
+ */
+
+#ifndef _RAND_EXPONENTIAL_H
+#define _RAND_EXPONENTIAL_H
+
+#include <mtwist.h>
+
+/* Parameters recognized by this variable. */
+#define RE_MEAN	"mean"
+
+/* Parameter defaults. */
+#define RE_MEAN_DEFAULT	1.0
+
+#define VERSION	"0.1.1 (alpha)"
+
+/* The handle that will be returned to Filebench. */
+typedef struct handle {
+	mt_state state;
+	double mean;
+} handle_t;
+
+/* Static buffer to hold the usage string */
+#define USAGE_LEN	2048
+
+char usage[USAGE_LEN + 1] = {0};
+
+#endif /* _RAND_EXPONENTIAL_H */
diff --git a/cvars/rand-lognormal/.cvsignore b/cvars/rand-lognormal/.cvsignore
new file mode 100644
index 0000000..8f1d062
--- /dev/null
+++ b/cvars/rand-lognormal/.cvsignore
@@ -0,0 +1 @@
+librand-lognormal.so*
diff --git a/cvars/rand-lognormal/Makefile b/cvars/rand-lognormal/Makefile
new file mode 100644
index 0000000..5cee147
--- /dev/null
+++ b/cvars/rand-lognormal/Makefile
@@ -0,0 +1,24 @@
+CC=gcc
+CFLAGS=-g -O0 -Wall -DDEBUG
+MAJOR_VERSION=0.1
+MINOR_VERSION=1 # Release number.
+FILEBENCHDIR=/usr/local/share
+CVAR_NAME=rand-lognormal
+
+.PHONEY : all
+all : ${CVAR_NAME}
+
+${CVAR_NAME} : ${CVAR_NAME}.h ${CVAR_NAME}.c
+	${CC} ${CFLAGS} -I../utils -I../utils/tokens -I../utils/mtwist -fPIC -c \
+	  ${CVAR_NAME}.c
+	${CC} ${CFLAGS} -shared -Wl,-soname,lib${CVAR_NAME}.so.${MAJOR_VERSION} \
+	  -Wl,--no-undefined \
+	  -o lib${CVAR_NAME}.so.${MAJOR_VERSION}.${MINOR_VERSION} -lc -lm \
+	  ../utils/mtwist/mtwist.o ../utils/mtwist/randistrs.o \
+	  ../utils/tokens/cvar_tokens.o ${CVAR_NAME}.o
+	cp lib${CVAR_NAME}.so.${MAJOR_VERSION}.${MINOR_VERSION} \
+	  ${FILEBENCHDIR}/filebench/cvars/
+
+.PHONEY : clean
+clean :
+	rm -f ${CVAR_NAME}.o lib${CVAR_NAME}.so.${MAJOR_VERSION}.${MINOR_VERSION}
diff --git a/cvars/rand-lognormal/rand-lognormal.c b/cvars/rand-lognormal/rand-lognormal.c
new file mode 100644
index 0000000..a6d9fee
--- /dev/null
+++ b/cvars/rand-lognormal/rand-lognormal.c
@@ -0,0 +1,155 @@
+/*
+ * rand-lognormal.c
+ *
+ * Custom variable implementation that returns Log-Normally distributed random
+ * numbers.
+ *
+ * Author: Santhosh Kumar Koundinya (santhosh@fsl.cs.sunysb.edu)
+ */
+
+#include <stdio.h>
+#include <mtwist.h>
+#include <randistrs.h>
+#include <cvar.h>
+#include <cvar_trace.h>
+#include <cvar_tokens.h>
+#include "rand-lognormal.h"
+
+void *cvar_alloc_handle(const char *cvar_parameters,
+		void *(*cvar_malloc)(size_t size), void (*cvar_free)(void *cvar_ptr))
+{
+	cvar_token_t *list_head;;
+	cvar_token_t *t;
+	handle_t handle;
+	handle_t *state = NULL;
+	int ret = 0;
+
+	cvar_trace("entry");
+
+	/* Tokenize parameters supplied by filebench. */
+	list_head = NULL;
+	ret = tokenize(cvar_parameters, DEFAULT_PARAMETER_DELIMITER,
+			DEFAULT_KEY_VALUE_DELIMITER, &list_head);
+	if (ret)
+		goto out;
+
+	/* Get the value of shape and scale. */
+	t = find_token(list_head, RLN_SHAPE);
+	if (t && t->value) {
+		t->used = 1;
+		handle.shape = atof(t->value);
+	} else
+		handle.shape = RLN_SHAPE_DEFAULT;
+
+	t = find_token(list_head, RLN_SCALE);
+	if (t && t->value) {
+		t->used = 1;
+		handle.scale = atof(t->value);
+	} else
+		handle.scale = RLN_SCALE_DEFAULT;
+
+	cvar_trace("shape = %lf, scale = %lf", handle.shape, handle.scale);
+
+	if (handle.shape < 0) {
+		cvar_log_error("Invalid parameter value: shape = %lf. shape is a "
+				"non-zero, positive rational number", handle.shape);
+		goto out;
+	}
+
+	if (handle.scale < 0) {
+		cvar_log_error("Invalid parameter value: scale = %lf. scale is a "
+				"non-zero, positive rational number", handle.scale);
+		goto out;
+	}
+
+	t = unused_tokens(list_head);
+	if (t) {
+		cvar_log_error("Unsupported parameter %s", t->key);
+		goto out;
+	}
+
+	/* Seed the state. */
+	mts_goodseed(&handle.state);
+
+	/* All set. Now allocate space for the handle in the shared segment and
+	 * copy the state over. */
+	state = (handle_t *) cvar_malloc(sizeof(handle_t));
+	if (!state) {
+		cvar_log_error("Out of memory");
+		goto out;
+	}
+
+	*state = handle;
+
+out:
+	free_tokens(list_head);
+
+	cvar_trace("exit");
+	return state;
+}
+
+int cvar_revalidate_handle(void *cvar_handle)
+{
+	handle_t *h = (handle_t *) cvar_handle;
+
+	mts_mark_initialized(&h->state);
+
+	return 0;
+}
+
+int cvar_next_value(void *cvar_handle, double *value)
+{
+	handle_t *h = (handle_t *) cvar_handle;
+
+	if (!h) {
+		cvar_trace("NULL cvar_handle");
+		return -1;
+	}
+
+	if (!value) {
+		cvar_trace("NULL value");
+		return -1;
+	}
+
+	*value = rds_lognormal(&h->state, h->shape, h->scale);
+
+	return 0;
+}
+
+const char *cvar_usage()
+{
+	int offset;
+
+	if (usage[0])
+		return usage;
+
+	offset = 0;
+
+	offset += snprintf(usage + offset, USAGE_LEN - offset,
+			"\tparameter\tdefault\n");
+	offset += snprintf(usage + offset, USAGE_LEN - offset,
+			"\t---------\t-------\n");
+
+	offset += snprintf(usage + offset, USAGE_LEN - offset,
+			"\t%s\t\t%.1f\n", RLN_SHAPE, RLN_SHAPE_DEFAULT);
+	offset += snprintf(usage + offset, USAGE_LEN - offset,
+			"\t%s\t\t%.1f\n", RLN_SCALE, RLN_SCALE_DEFAULT);
+
+	offset += snprintf(usage + offset, USAGE_LEN - offset,
+			"Use '%c' to delimit parameters and '%c' to delimit key-value "
+			"pairs.\n", DEFAULT_PARAMETER_DELIMITER,
+			DEFAULT_KEY_VALUE_DELIMITER);
+
+	offset += snprintf(usage + offset, USAGE_LEN - offset,
+			"Example: '%s%c%.1f%c%s%c%.1f'",
+			RLN_SHAPE, DEFAULT_KEY_VALUE_DELIMITER, RLN_SHAPE_DEFAULT,
+			DEFAULT_PARAMETER_DELIMITER,
+			RLN_SCALE, DEFAULT_KEY_VALUE_DELIMITER, RLN_SCALE_DEFAULT);
+
+	return usage;
+}
+
+const char *cvar_version()
+{
+	return VERSION;
+}
diff --git a/cvars/rand-lognormal/rand-lognormal.h b/cvars/rand-lognormal/rand-lognormal.h
new file mode 100644
index 0000000..f01e4c1
--- /dev/null
+++ b/cvars/rand-lognormal/rand-lognormal.h
@@ -0,0 +1,37 @@
+/*
+ * rand-lognormal.h
+ *
+ * Custom variable implementation that returns Log-Normally distributed random
+ * numbers.
+ *
+ * Author: Santhosh Kumar Koundinya (santhosh@fsl.cs.sunysb.edu)
+ */
+
+#ifndef _RAND_LOGNORMAL_H
+#define _RAND_LOGNORMAL_H
+
+#include <mtwist.h>
+
+/* Parameters recognized by this variable. */
+#define RLN_SHAPE	"shape"
+#define RLN_SCALE	"scale"
+
+/* Parameter defaults. */
+#define RLN_SHAPE_DEFAULT	1.0
+#define RLN_SCALE_DEFAULT	1.0
+
+#define VERSION	"0.1.1 (alpha)"
+
+/* The handle that will be returned to Filebench. */
+typedef struct handle {
+	mt_state state;
+	double shape;
+	double scale;
+} handle_t;
+
+/* Static buffer to hold the usage string */
+#define USAGE_LEN	2048
+
+char usage[USAGE_LEN + 1] = {0};
+
+#endif /* _RAND_NORMAL_H */
diff --git a/cvars/rand-normal/.cvsignore b/cvars/rand-normal/.cvsignore
new file mode 100644
index 0000000..5c941f6
--- /dev/null
+++ b/cvars/rand-normal/.cvsignore
@@ -0,0 +1 @@
+librand-normal.so*
diff --git a/cvars/rand-normal/Makefile b/cvars/rand-normal/Makefile
new file mode 100644
index 0000000..542bbe1
--- /dev/null
+++ b/cvars/rand-normal/Makefile
@@ -0,0 +1,24 @@
+CC=gcc
+CFLAGS=-g -O0 -Wall -DDEBUG
+MAJOR_VERSION=0.1
+MINOR_VERSION=1 # Release number.
+FILEBENCHDIR=/usr/local/share
+CVAR_NAME=rand-normal
+
+.PHONEY : all
+all : ${CVAR_NAME}
+
+${CVAR_NAME} : ${CVAR_NAME}.h ${CVAR_NAME}.c
+	${CC} ${CFLAGS} -I../utils -I../utils/tokens -I../utils/mtwist -fPIC -c \
+	  ${CVAR_NAME}.c
+	${CC} ${CFLAGS} -shared -Wl,-soname,lib${CVAR_NAME}.so.${MAJOR_VERSION} \
+	  -Wl,--no-undefined \
+	  -o lib${CVAR_NAME}.so.${MAJOR_VERSION}.${MINOR_VERSION} -lc -lm \
+	  ../utils/mtwist/mtwist.o ../utils/mtwist/randistrs.o \
+	  ../utils/tokens/cvar_tokens.o ${CVAR_NAME}.o
+	cp lib${CVAR_NAME}.so.${MAJOR_VERSION}.${MINOR_VERSION} \
+	  ${FILEBENCHDIR}/filebench/cvars/
+
+.PHONEY : clean
+clean :
+	rm -f ${CVAR_NAME}.o lib${CVAR_NAME}.so.${MAJOR_VERSION}.${MINOR_VERSION}
diff --git a/cvars/rand-normal/rand-normal.c b/cvars/rand-normal/rand-normal.c
new file mode 100644
index 0000000..47e5ff8
--- /dev/null
+++ b/cvars/rand-normal/rand-normal.c
@@ -0,0 +1,143 @@
+/*
+ * rand-normal.h
+ *
+ * Custom variable that returns random numbers following the Normal
+ * distribution.
+ *
+ * Author: Santhosh Kumar Koundinya (santhosh@fsl.cs.sunysb.edu)
+ */
+
+#include <stdio.h>
+#include <mtwist.h>
+#include <randistrs.h>
+#include <cvar.h>
+#include <cvar_trace.h>
+#include <cvar_tokens.h>
+#include "rand-normal.h"
+
+void *cvar_alloc_handle(const char *cvar_parameters,
+		void *(*cvar_malloc)(size_t size), void (*cvar_free)(void *cvar_ptr))
+{
+	cvar_token_t *list_head;;
+	cvar_token_t *t;
+	handle_t handle;
+	handle_t *state = NULL;
+	int ret = 0;
+
+	cvar_trace("entry");
+
+	/* Tokenize parameters supplied by filebench. */
+	list_head = NULL;
+	ret = tokenize(cvar_parameters, DEFAULT_PARAMETER_DELIMITER,
+			DEFAULT_KEY_VALUE_DELIMITER, &list_head);
+	if (ret)
+		goto out;
+
+	/* Get the value of mean and sigma. */
+	t = find_token(list_head, RN_MEAN);
+	if (t && t->value) {
+		t->used = 1;
+		handle.mean = atof(t->value);
+	} else
+		handle.mean = RN_MEAN_DEFAULT;
+
+	t = find_token(list_head, RN_SIGMA);
+	if (t && t->value) {
+		t->used = 1;
+		handle.sigma = atof(t->value);
+	} else
+		handle.sigma = RN_SIGMA_DEFAULT;
+
+	cvar_trace("mean = %lf, sigma = %lf", handle.mean, handle.sigma);
+
+	t = unused_tokens(list_head);
+	if (t) {
+		cvar_log_error("Unsupported parameter %s", t->key);
+		goto out;
+	}
+
+	/* Seed the state. */
+	mts_goodseed(&handle.state);
+
+	/* All set. Now allocate space for the handle in the shared segment and
+	 * copy the state over. */
+	state = (handle_t *) cvar_malloc(sizeof(handle_t));
+	if (!state) {
+		cvar_log_error("Out of memory");
+		goto out;
+	}
+
+	*state = handle;
+
+out:
+	free_tokens(list_head);
+
+	cvar_trace("exit");
+	return state;
+}
+
+int cvar_revalidate_handle(void *cvar_handle)
+{
+	handle_t *h = (handle_t *) cvar_handle;
+
+	mts_mark_initialized(&h->state);
+
+	return 0;
+}
+
+int cvar_next_value(void *cvar_handle, double *value)
+{
+	handle_t *h = (handle_t *) cvar_handle;
+
+	if (!h) {
+		cvar_trace("NULL cvar_handle");
+		return -1;
+	}
+
+	if (!value) {
+		cvar_trace("NULL value");
+		return -1;
+	}
+
+	*value = rds_normal(&h->state, h->mean, h->sigma);
+
+	return 0;
+}
+
+const char *cvar_usage()
+{
+	int offset;
+
+	if (usage[0])
+		return usage;
+
+	offset = 0;
+
+	offset += snprintf(usage + offset, USAGE_LEN - offset,
+			"\tparameter\tdefault\n");
+	offset += snprintf(usage + offset, USAGE_LEN - offset,
+			"\t---------\t-------\n");
+
+	offset += snprintf(usage + offset, USAGE_LEN - offset,
+			"\t%s\t\t%.1f\n", RN_MEAN, RN_MEAN_DEFAULT);
+	offset += snprintf(usage + offset, USAGE_LEN - offset,
+			"\t%s\t\t%.1f\n", RN_SIGMA, RN_SIGMA_DEFAULT);
+
+	offset += snprintf(usage + offset, USAGE_LEN - offset,
+			"Use '%c' to delimit parameters and '%c' to delimit key-value "
+			"pairs.\n", DEFAULT_PARAMETER_DELIMITER,
+			DEFAULT_KEY_VALUE_DELIMITER);
+
+	offset += snprintf(usage + offset, USAGE_LEN - offset,
+			"Example: '%s%c%.1f%c%s%c%.1f'",
+			RN_MEAN, DEFAULT_KEY_VALUE_DELIMITER, RN_MEAN_DEFAULT,
+			DEFAULT_PARAMETER_DELIMITER,
+			RN_SIGMA, DEFAULT_KEY_VALUE_DELIMITER, RN_SIGMA_DEFAULT);
+
+	return usage;
+}
+
+const char *cvar_version()
+{
+	return VERSION;
+}
diff --git a/cvars/rand-normal/rand-normal.h b/cvars/rand-normal/rand-normal.h
new file mode 100644
index 0000000..47c8d07
--- /dev/null
+++ b/cvars/rand-normal/rand-normal.h
@@ -0,0 +1,36 @@
+/*
+ * rand-normal.h
+ *
+ * Custom variable that returns Normally distributed random numbers.
+ *
+ * Author: Santhosh Kumar Koundinya (santhosh@fsl.cs.sunysb.edu)
+ */
+
+#ifndef _RAND_NORMAL_H
+#define _RAND_NORMAL_H
+
+#include <mtwist.h>
+
+/* Parameters recognized by this variable. */
+#define RN_MEAN		"mean"
+#define RN_SIGMA	"sigma"
+
+/* Parameter defaults. */
+#define RN_MEAN_DEFAULT		0.0
+#define RN_SIGMA_DEFAULT	1.0
+
+#define VERSION	"0.1.1 (alpha)"
+
+/* The handle that will be returned to Filebench. */
+typedef struct handle {
+	mt_state state;
+	double mean;
+	double sigma;
+} handle_t;
+
+/* Static buffer to hold the usage string */
+#define USAGE_LEN	2048
+
+char usage[USAGE_LEN + 1] = {0};
+
+#endif /* _RAND_NORMAL_H */
diff --git a/cvars/rand-triangular/.cvsignore b/cvars/rand-triangular/.cvsignore
new file mode 100644
index 0000000..cf71802
--- /dev/null
+++ b/cvars/rand-triangular/.cvsignore
@@ -0,0 +1 @@
+librand-triangular.so*
diff --git a/cvars/rand-triangular/Makefile b/cvars/rand-triangular/Makefile
new file mode 100644
index 0000000..5ebf910
--- /dev/null
+++ b/cvars/rand-triangular/Makefile
@@ -0,0 +1,24 @@
+CC=gcc
+CFLAGS=-g -O0 -Wall -DDEBUG
+MAJOR_VERSION=0.1
+MINOR_VERSION=1 # Release number.
+FILEBENCHDIR=/usr/local/share
+CVAR_NAME=rand-triangular
+
+.PHONEY : all
+all : ${CVAR_NAME}
+
+${CVAR_NAME} : ${CVAR_NAME}.h ${CVAR_NAME}.c
+	${CC} ${CFLAGS} -I../utils -I../utils/tokens -I../utils/mtwist -fPIC -c \
+	  ${CVAR_NAME}.c
+	${CC} ${CFLAGS} -shared -Wl,-soname,lib${CVAR_NAME}.so.${MAJOR_VERSION} \
+	  -Wl,--no-undefined \
+	  -o lib${CVAR_NAME}.so.${MAJOR_VERSION}.${MINOR_VERSION} -lc -lm \
+	  ../utils/mtwist/mtwist.o ../utils/mtwist/randistrs.o \
+	  ../utils/tokens/cvar_tokens.o ${CVAR_NAME}.o
+	cp lib${CVAR_NAME}.so.${MAJOR_VERSION}.${MINOR_VERSION} \
+	  ${FILEBENCHDIR}/filebench/cvars/
+
+.PHONEY : clean
+clean :
+	rm -f ${CVAR_NAME}.o lib${CVAR_NAME}.so.${MAJOR_VERSION}.${MINOR_VERSION}
diff --git a/cvars/rand-triangular/rand-triangular.c b/cvars/rand-triangular/rand-triangular.c
new file mode 100644
index 0000000..16d4db2
--- /dev/null
+++ b/cvars/rand-triangular/rand-triangular.c
@@ -0,0 +1,170 @@
+/*
+ * rand-triangular.c
+ *
+ * Custom variable implementation that returns random numbers following a
+ * Triangular distribution.
+ *
+ * Author: Santhosh Kumar Koundinya (santhosh@fsl.cs.sunysb.edu)
+ */
+
+#include <stdio.h>
+#include <mtwist.h>
+#include <randistrs.h>
+#include <cvar.h>
+#include <cvar_trace.h>
+#include <cvar_tokens.h>
+#include "rand-triangular.h"
+
+void *cvar_alloc_handle(const char *cvar_parameters,
+		void *(*cvar_malloc)(size_t size), void (*cvar_free)(void *cvar_ptr))
+{
+	cvar_token_t *list_head;;
+	cvar_token_t *t;
+	handle_t handle;
+	handle_t *state = NULL;
+	int ret = 0;
+
+	cvar_trace("entry");
+
+	/* Tokenize parameters supplied by filebench. */
+	list_head = NULL;
+	ret = tokenize(cvar_parameters, DEFAULT_PARAMETER_DELIMITER,
+			DEFAULT_KEY_VALUE_DELIMITER, &list_head);
+	if (ret)
+		goto out;
+
+	/* Get the value of lower, upper and mode. */
+	t = find_token(list_head, RT_LOWER);
+	if (t && t->value) {
+		t->used = 1;
+		handle.lower = atof(t->value);
+	} else
+		handle.lower = RT_LOWER_DEFAULT;
+
+	t = find_token(list_head, RT_UPPER);
+	if (t && t->value) {
+		t->used = 1;
+		handle.upper = atof(t->value);
+	} else
+		handle.upper = RT_UPPER_DEFAULT;
+
+	t = find_token(list_head, RT_MODE);
+	if (t && t->value) {
+		t->used = 1;
+		handle.mode = atof(t->value);
+	} else
+		handle.mode = RT_MODE_DEFAULT;
+
+	cvar_trace("lower = %lf, upper = %lf, mode = %lf", handle.lower,
+			handle.upper, handle.mode);
+
+	/* Validate parameters. */
+	if (handle.upper < handle.lower) {
+		cvar_log_error("Invalid parameter values: lower = %lf and upper = %lf. "
+				"upper must be greater than lower", handle.lower, handle.upper);
+		goto out;
+	}
+
+	if ((handle.mode > handle.upper) || (handle.mode < handle.lower)) {
+		cvar_log_error("Invalid parameter values: lower = %lf, mode = %lf and "
+				"upper = %lf. mode must be between lower and upper",
+				handle.lower, handle.mode, handle.upper);
+		goto out;
+	}
+
+	/* Check if there are unused tokens. */
+	t = unused_tokens(list_head);
+	if (t) {
+		cvar_log_error("Unsupported parameter %s", t->key);
+		goto out;
+	}
+
+	/* Seed the state. */
+	mts_goodseed(&handle.state);
+
+	/* All set. Now allocate space for the handle in the shared segment and
+	 * copy the state over. */
+	state = (handle_t *) cvar_malloc(sizeof(handle_t));
+	if (!state) {
+		cvar_log_error("Out of memory");
+		goto out;
+	}
+
+	*state = handle;
+
+out:
+	free_tokens(list_head);
+
+	cvar_trace("exit");
+	return state;
+}
+
+int cvar_revalidate_handle(void *cvar_handle)
+{
+	handle_t *h = (handle_t *) cvar_handle;
+
+	mts_mark_initialized(&h->state);
+
+	return 0;
+}
+
+int cvar_next_value(void *cvar_handle, double *value)
+{
+	handle_t *h = (handle_t *) cvar_handle;
+
+	if (!h) {
+		cvar_log_error("NULL cvar_handle");
+		return -1;
+	}
+
+	if (!value) {
+		cvar_log_error("NULL value");
+		return -1;
+	}
+
+	*value = rds_triangular(&h->state, h->lower, h->upper, h->mode);
+
+	return 0;
+}
+
+const char *cvar_usage()
+{
+	int offset;
+
+	if (usage[0])
+		return usage;
+
+	offset = 0;
+
+	offset += snprintf(usage + offset, USAGE_LEN - offset,
+			"\tparameter\tdefault\n");
+	offset += snprintf(usage + offset, USAGE_LEN - offset,
+			"\t---------\t-------\n");
+
+	offset += snprintf(usage + offset, USAGE_LEN - offset,
+			"\t%s\t\t%.1f\n", RT_LOWER, RT_LOWER_DEFAULT);
+	offset += snprintf(usage + offset, USAGE_LEN - offset,
+			"\t%s\t\t%.1f\n", RT_UPPER, RT_UPPER_DEFAULT);
+	offset += snprintf(usage + offset, USAGE_LEN - offset,
+			"\t%s\t\t%.1f\n", RT_MODE, RT_MODE_DEFAULT);
+
+	offset += snprintf(usage + offset, USAGE_LEN - offset,
+			"Use '%c' to delimit parameters and '%c' to delimit key-value "
+			"pairs.\n", DEFAULT_PARAMETER_DELIMITER,
+			DEFAULT_KEY_VALUE_DELIMITER);
+
+	offset += snprintf(usage + offset, USAGE_LEN - offset,
+			"Example: '%s%c%.1f%c%s%c%.1f%c%s%c%.1f'",
+			RT_LOWER, DEFAULT_KEY_VALUE_DELIMITER, RT_LOWER_DEFAULT,
+			DEFAULT_PARAMETER_DELIMITER,
+			RT_UPPER, DEFAULT_KEY_VALUE_DELIMITER, RT_UPPER_DEFAULT,
+			DEFAULT_PARAMETER_DELIMITER,
+			RT_MODE, DEFAULT_KEY_VALUE_DELIMITER, RT_MODE_DEFAULT);
+
+	return usage;
+}
+
+const char *cvar_version()
+{
+	return VERSION;
+}
diff --git a/cvars/rand-triangular/rand-triangular.h b/cvars/rand-triangular/rand-triangular.h
new file mode 100644
index 0000000..9ac0c29
--- /dev/null
+++ b/cvars/rand-triangular/rand-triangular.h
@@ -0,0 +1,40 @@
+/*
+ * rand-triangular.h
+ *
+ * Custom variable implementation that returns random numbers following a
+ * Triangular distribution.
+ *
+ * Author: Santhosh Kumar Koundinya (santhosh@fsl.cs.sunysb.edu)
+ */
+
+#ifndef _RAND_TRIANGULAR_H
+#define _RAND_TRIANGULAR_H
+
+#include <mtwist.h>
+
+/* Parameters recognized by this variable. */
+#define RT_LOWER	"lower"
+#define RT_UPPER	"upper"
+#define RT_MODE		"mode"
+
+/* Parameter defaults. */
+#define RT_LOWER_DEFAULT	0.0
+#define RT_UPPER_DEFAULT	1.0
+#define RT_MODE_DEFAULT		0.5
+
+#define VERSION	"0.1.1 (alpha)"
+
+/* The handle that will be returned to Filebench. */
+typedef struct handle {
+	mt_state state;
+	double lower;
+	double upper;
+	double mode;
+} handle_t;
+
+/* Static buffer to hold the usage string */
+#define USAGE_LEN	2048
+
+char usage[USAGE_LEN + 1] = {0};
+
+#endif /* _RAND_TRIANGULAR_H */
diff --git a/cvars/rand-uniform/.cvsignore b/cvars/rand-uniform/.cvsignore
new file mode 100644
index 0000000..7392b17
--- /dev/null
+++ b/cvars/rand-uniform/.cvsignore
@@ -0,0 +1 @@
+librand-uniform.so*
diff --git a/cvars/rand-uniform/Makefile b/cvars/rand-uniform/Makefile
new file mode 100644
index 0000000..a58a4ab
--- /dev/null
+++ b/cvars/rand-uniform/Makefile
@@ -0,0 +1,24 @@
+CC=gcc
+CFLAGS=-g -O0 -Wall -DDEBUG
+MAJOR_VERSION=0.1
+MINOR_VERSION=1 # Release number.
+FILEBENCHDIR=/usr/local/share
+CVAR_NAME=rand-uniform
+
+.PHONEY : all
+all : ${CVAR_NAME}
+
+${CVAR_NAME} : ${CVAR_NAME}.h ${CVAR_NAME}.c
+	${CC} ${CFLAGS} -I../utils -I../utils/tokens -I../utils/mtwist -fPIC -c \
+	  ${CVAR_NAME}.c
+	${CC} ${CFLAGS} -shared -Wl,-soname,lib${CVAR_NAME}.so.${MAJOR_VERSION} \
+	  -Wl,--no-undefined \
+	  -o lib${CVAR_NAME}.so.${MAJOR_VERSION}.${MINOR_VERSION} -lc -lm \
+	  ../utils/mtwist/mtwist.o ../utils/mtwist/randistrs.o \
+	  ../utils/tokens/cvar_tokens.o ${CVAR_NAME}.o
+	cp lib${CVAR_NAME}.so.${MAJOR_VERSION}.${MINOR_VERSION} \
+	  ${FILEBENCHDIR}/filebench/cvars/
+
+.PHONEY : clean
+clean :
+	rm -f ${CVAR_NAME}.o lib${CVAR_NAME}.so.${MAJOR_VERSION}.${MINOR_VERSION}
diff --git a/cvars/rand-uniform/rand-uniform.c b/cvars/rand-uniform/rand-uniform.c
new file mode 100644
index 0000000..5ad88cf
--- /dev/null
+++ b/cvars/rand-uniform/rand-uniform.c
@@ -0,0 +1,148 @@
+/*
+ * rand-uniform.c
+ *
+ * Custom variable implementation that returns uniformly distributed random
+ * numbers.
+ *
+ * Author: Santhosh Kumar Koundinya (santhosh@fsl.cs.sunysb.edu)
+ */
+
+#include <stdio.h>
+#include <mtwist.h>
+#include <randistrs.h>
+#include <cvar.h>
+#include <cvar_trace.h>
+#include <cvar_tokens.h>
+#include "rand-uniform.h"
+
+void *cvar_alloc_handle(const char *cvar_parameters,
+		void *(*cvar_malloc)(size_t size), void (*cvar_free)(void *cvar_ptr))
+{
+	cvar_token_t *list_head;;
+	cvar_token_t *t;
+	handle_t handle;
+	handle_t *state = NULL;
+	int ret = 0;
+
+	cvar_trace("entry");
+
+	/* Tokenize parameters supplied by filebench. */
+	list_head = NULL;
+	ret = tokenize(cvar_parameters, DEFAULT_PARAMETER_DELIMITER,
+			DEFAULT_KEY_VALUE_DELIMITER, &list_head);
+	if (ret)
+		goto out;
+
+	/* Get the values for lower and upper. */
+	t = find_token(list_head, RU_LOWER);
+	if (t && t->value) {
+		t->used = 1;
+		handle.lower = atof(t->value);
+	} else
+		handle.lower = RU_LOWER_DEFAULT;
+
+	t = find_token(list_head, RU_UPPER);
+	if (t && t->value) {
+		t->used = 1;
+		handle.upper = atof(t->value);
+	} else
+		handle.upper = RU_UPPER_DEFAULT;
+
+	cvar_trace("lower = %lf, upper = %lf", handle.lower, handle.upper);
+
+	/* Validate parameters. */
+	if (handle.lower > handle.upper) {
+		cvar_log_error("Invalid parameter values: lower = %lf and upper = %lf. "
+				"upper must be greater than lower", handle.lower, handle.upper);
+	}
+
+	t = unused_tokens(list_head);
+	if (t) {
+		cvar_log_error("Unsupported parameter %s", t->key);
+		goto out;
+	}
+
+	/* Seed the state. */
+	mts_goodseed(&handle.state);
+
+	/* All set. Now allocate space for the handle in the shared segment and
+	 * copy the state over. */
+	state = (handle_t *) cvar_malloc(sizeof(handle_t));
+	if (!state) {
+		cvar_log_error("Out of memory");
+		goto out;
+	}
+
+	*state = handle;
+
+out:
+	free_tokens(list_head);
+
+	cvar_trace("exit");
+	return state;
+}
+
+int cvar_revalidate_handle(void *cvar_handle)
+{
+	handle_t *h = (handle_t *) cvar_handle;
+
+	mts_mark_initialized(&h->state);
+
+	return 0;
+}
+
+int cvar_next_value(void *cvar_handle, double *value)
+{
+	handle_t *h = (handle_t *) cvar_handle;
+
+	if (!h) {
+		cvar_log_error("NULL cvar_handle");
+		return -1;
+	}
+
+	if (!value) {
+		cvar_log_error("NULL value");
+		return -1;
+	}
+
+	*value = rds_uniform(&h->state, h->lower, h->upper);
+
+	return 0;
+}
+
+const char *cvar_usage()
+{
+	int offset;
+
+	if (usage[0])
+		return usage;
+
+	offset = 0;
+
+	offset += snprintf(usage + offset, USAGE_LEN - offset,
+			"\tparameter\tdefault\n");
+	offset += snprintf(usage + offset, USAGE_LEN - offset,
+			"\t---------\t-------\n");
+
+	offset += snprintf(usage + offset, USAGE_LEN - offset,
+			"\t%s\t\t%.1f\n", RU_LOWER, RU_LOWER_DEFAULT);
+	offset += snprintf(usage + offset, USAGE_LEN - offset,
+			"\t%s\t\t%.1f\n", RU_UPPER, RU_UPPER_DEFAULT);
+
+	offset += snprintf(usage + offset, USAGE_LEN - offset,
+			"Use '%c' to delimit parameters and '%c' to delimit key-value "
+			"pairs.\n", DEFAULT_PARAMETER_DELIMITER,
+			DEFAULT_KEY_VALUE_DELIMITER);
+	offset += snprintf(usage + offset, USAGE_LEN - offset,
+			"Example: '%s%c%.1f%c%s%c%.1f'",
+			RU_LOWER, DEFAULT_KEY_VALUE_DELIMITER, RU_LOWER_DEFAULT,
+			DEFAULT_PARAMETER_DELIMITER,
+			RU_UPPER, DEFAULT_KEY_VALUE_DELIMITER, RU_UPPER_DEFAULT);
+
+	return usage;
+}
+
+const char *cvar_version()
+{
+	return VERSION;
+}
diff --git a/cvars/rand-uniform/rand-uniform.h b/cvars/rand-uniform/rand-uniform.h
new file mode 100644
index 0000000..f074076
--- /dev/null
+++ b/cvars/rand-uniform/rand-uniform.h
@@ -0,0 +1,37 @@
+/*
+ * rand-uniform.h
+ *
+ * Custom variable implementation that generates uniformly distributed random
+ * numbers.
+ *
+ * Author: Santhosh Kumar Koundinya (santhosh@fsl.cs.sunysb.edu)
+ */
+
+#ifndef _RAND_UNIFORM_H
+#define _RAND_UNIFORM_H
+
+#include <mtwist.h>
+
+/* Parameters recognized by this variable. */
+#define RU_LOWER	"lower"
+#define RU_UPPER	"upper"
+
+/* Parameter defaults. */
+#define RU_LOWER_DEFAULT	0.0
+#define RU_UPPER_DEFAULT	1.0
+
+#define VERSION	"0.1.1 (alpha)"
+
+/* The handle that will be returned to Filebench. */
+typedef struct handle {
+	mt_state state;
+	double lower;
+	double upper;
+} handle_t;
+
+/* Static buffer to hold the usage string */
+#define USAGE_LEN	2048
+
+char usage[USAGE_LEN + 1] = {0};
+
+#endif /* _RAND_UNIFORM_H */
diff --git a/cvars/rand-weibull/.cvsignore b/cvars/rand-weibull/.cvsignore
new file mode 100644
index 0000000..7d12d8c
--- /dev/null
+++ b/cvars/rand-weibull/.cvsignore
@@ -0,0 +1 @@
+librand-weibull.so*
diff --git a/cvars/rand-weibull/Makefile b/cvars/rand-weibull/Makefile
new file mode 100644
index 0000000..23d855e
--- /dev/null
+++ b/cvars/rand-weibull/Makefile
@@ -0,0 +1,24 @@
+CC=gcc
+CFLAGS=-g -O0 -Wall -DDEBUG
+MAJOR_VERSION=0.1
+MINOR_VERSION=1 # Release number.
+FILEBENCHDIR=/usr/local/share
+CVAR_NAME=rand-weibull
+
+.PHONEY : all
+all : ${CVAR_NAME}
+
+${CVAR_NAME} : ${CVAR_NAME}.h ${CVAR_NAME}.c
+	${CC} ${CFLAGS} -I../utils -I../utils/tokens -I../utils/mtwist -fPIC -c \
+	  ${CVAR_NAME}.c
+	${CC} ${CFLAGS} -shared -Wl,-soname,lib${CVAR_NAME}.so.${MAJOR_VERSION} \
+	  -Wl,--no-undefined \
+	  -o lib${CVAR_NAME}.so.${MAJOR_VERSION}.${MINOR_VERSION} -lc -lm \
+	  ../utils/mtwist/mtwist.o ../utils/mtwist/randistrs.o \
+	  ../utils/tokens/cvar_tokens.o ${CVAR_NAME}.o
+	cp lib${CVAR_NAME}.so.${MAJOR_VERSION}.${MINOR_VERSION} \
+	  ${FILEBENCHDIR}/filebench/cvars/
+
+.PHONEY : clean
+clean :
+	rm -f ${CVAR_NAME}.o lib${CVAR_NAME}.so.${MAJOR_VERSION}.${MINOR_VERSION}
diff --git a/cvars/rand-weibull/rand-weibull.c b/cvars/rand-weibull/rand-weibull.c
new file mode 100644
index 0000000..9b5d093
--- /dev/null
+++ b/cvars/rand-weibull/rand-weibull.c
@@ -0,0 +1,156 @@
+/*
+ * rand-weibull.c
+ *
+ * Custom variable implementation that returns random numbers following the
+ * Weibull distribution.
+ *
+ * Author: Santhosh Kumar Koundinya (santhosh@fsl.cs.sunysb.edu)
+ */
+
+#include <stdio.h>
+#include <mtwist.h>
+#include <randistrs.h>
+#include <cvar.h>
+#include <cvar_trace.h>
+#include <cvar_tokens.h>
+#include "rand-weibull.h"
+
+void *cvar_alloc_handle(const char *cvar_parameters,
+		void *(*cvar_malloc)(size_t size), void (*cvar_free)(void *cvar_ptr))
+{
+	cvar_token_t *list_head;;
+	cvar_token_t *t;
+	handle_t handle;
+	handle_t *state = NULL;
+	int ret = 0;
+
+	cvar_trace("entry");
+
+	/* Tokenize parameters supplied by filebench. */
+	list_head = NULL;
+	ret = tokenize(cvar_parameters, DEFAULT_PARAMETER_DELIMITER,
+			DEFAULT_KEY_VALUE_DELIMITER, &list_head);
+	if (ret)
+		goto out;
+
+	/* Get the value of shape and scale. */
+	t = find_token(list_head, RW_SHAPE);
+	if (t && t->value) {
+		t->used = 1;
+		handle.shape = atof(t->value);
+	} else
+		handle.shape = RW_SHAPE_DEFAULT;
+
+	t = find_token(list_head, RW_SCALE);
+	if (t && t->value) {
+		t->used = 1;
+		handle.scale = atof(t->value);
+	} else
+		handle.scale = RW_SCALE_DEFAULT;
+
+	cvar_trace("shape = %lf, scale = %lf", handle.shape, handle.scale);
+
+	/* Validate parameters. */
+	if (handle.shape < 0) {
+		cvar_log_error("Invalid parameter value: shape = %lf. shape is a "
+				"non-zero, positive integer", handle.shape);
+		goto out;
+	}
+
+	if (handle.scale < 0) {
+		cvar_log_error("Invalid parameter value: scale = %lf. scale is a "
+				"non-zero, positive rational number", handle.scale);
+		goto out;
+	}
+
+	t = unused_tokens(list_head);
+	if (t) {
+		cvar_log_error("Unsupported parameter %s", t->key);
+		goto out;
+	}
+
+	/* Seed the state. */
+	mts_goodseed(&handle.state);
+
+	/* All set. Now allocate space for the handle in the shared segment and
+	 * copy the state over. */
+	state = (handle_t *) cvar_malloc(sizeof(handle_t));
+	if (!state) {
+		cvar_log_error("Out of memory");
+		goto out;
+	}
+
+	*state = handle;
+
+out:
+	free_tokens(list_head);
+
+	cvar_trace("exit");
+	return state;
+}
+
+int cvar_revalidate_handle(void *cvar_handle)
+{
+	handle_t *h = (handle_t *) cvar_handle;
+
+	mts_mark_initialized(&h->state);
+
+	return 0;
+}
+
+int cvar_next_value(void *cvar_handle, double *value)
+{
+	handle_t *h = (handle_t *) cvar_handle;
+
+	if (!h) {
+		cvar_trace("NULL cvar_handle");
+		return -1;
+	}
+
+	if (!value) {
+		cvar_trace("NULL value");
+		return -1;
+	}
+
+	*value = rds_weibull(&h->state, h->shape, h->scale);
+
+	return 0;
+}
+
+const char *cvar_usage()
+{
+	int offset;
+
+	if (usage[0])
+		return usage;
+
+	offset = 0;
+
+	offset += snprintf(usage + offset, USAGE_LEN - offset,
+			"\tparameter\tdefault\n");
+	offset += snprintf(usage + offset, USAGE_LEN - offset,
+			"\t---------\t-------\n");
+
+	offset += snprintf(usage + offset, USAGE_LEN - offset,
+			"\t%s\t\t%.1f\n", RW_SHAPE, RW_SHAPE_DEFAULT);
+	offset += snprintf(usage + offset, USAGE_LEN - offset,
+			"\t%s\t\t%.1f\n", RW_SCALE, RW_SCALE_DEFAULT);
+
+	offset += snprintf(usage + offset, USAGE_LEN - offset,
+			"Use '%c' to delimit parameters and '%c' to delimit key-value "
+			"pairs.\n", DEFAULT_PARAMETER_DELIMITER,
+			DEFAULT_KEY_VALUE_DELIMITER);
+
+	offset += snprintf(usage + offset, USAGE_LEN - offset,
+			"Example: '%s%c%.1f%c%s%c%.1f'",
+			RW_SHAPE, DEFAULT_KEY_VALUE_DELIMITER, RW_SHAPE_DEFAULT,
+			DEFAULT_PARAMETER_DELIMITER,
+			RW_SCALE, DEFAULT_KEY_VALUE_DELIMITER, RW_SCALE_DEFAULT);
+
+	return usage;
+}
+
+const char *cvar_version()
+{
+	return VERSION;
+}
diff --git a/cvars/rand-weibull/rand-weibull.h b/cvars/rand-weibull/rand-weibull.h
new file mode 100644
index 0000000..4ac6746
--- /dev/null
+++ b/cvars/rand-weibull/rand-weibull.h
@@ -0,0 +1,37 @@
+/*
+ * rand-weibull.h
+ *
+ * Custom variable implementation that returns random numbers following the
+ * Weibull distribution.
+ *
+ * Author: Santhosh Kumar Koundinya (santhosh@fsl.cs.sunysb.edu)
+ */
+
+#ifndef _RAND_WEIBULL_H
+#define _RAND_WEIBULL_H
+
+#include <mtwist.h>
+
+/* Parameters recognized by this variable. */
+#define RW_SHAPE	"shape"
+#define RW_SCALE	"scale"
+
+/* Parameter defaults. */
+#define RW_SHAPE_DEFAULT	1.0
+#define RW_SCALE_DEFAULT	1.0
+
+#define VERSION	"0.1.1 (alpha)"
+
+/* The handle that will be returned to Filebench. */
+typedef struct handle {
+	mt_state state;
+	double shape;
+	double scale;
+} handle_t;
+
+/* Static buffer to hold the usage string */
+#define USAGE_LEN	2048
+
+char usage[USAGE_LEN + 1] = {0};
+
+#endif /* _RAND_WEIBULL_H */
diff --git a/cvars/utils/cvar.h b/cvars/utils/cvar.h
new file mode 100644
index 0000000..634d279
--- /dev/null
+++ b/cvars/utils/cvar.h
@@ -0,0 +1,111 @@
+/*
+ * cvar.h
+ *
+ * Include file for code implementing custom variables.
+ *
+ * @Author Santhosh Kumar Koundinya (santhosh@fsl.cs.sunysb.edu)
+ */
+
+#ifndef _CVAR_H
+#define _CVAR_H
+
+/*
+ * Initialize the state of the library supporting the custom variable.
+ * cvar_module_init is the first function to be invoked when a custom variable
+ * module is loaded.
+ *
+ * Implementation: Optional.
+ *
+ * Return 0 on success and a non-zero error code on failure.
+ */
+
+int cvar_module_init();
+
+/*
+ * Allocate a new custom variable handle. A handle is subsequently used to
+ * generate values. Memory required for initializing the handle must be
+ * allocated using argument cvar_malloc only. Libraries can use cvar_free to
+ * clean up memory allocated by cvar_malloc in case construction of the handle
+ * fails. Libraries must not store references to cvar_malloc and cvar_free for
+ * later use.
+ *
+ * Implementation: Mandatory.
+ *
+ * Return a non NULL handle on success and a NULL handle on error.
+ */
+
+void *cvar_alloc_handle(const char *cvar_parameters,
+		void *(*cvar_malloc)(size_t size), void (*cvar_free)(void *ptr));
+
+/*
+ * Re-validate a previously allocated handle. Filebench will always
+ * re-validate handles that were not allocated in the current process before
+ * use in the current process.
+ *
+ * Implementation: Optional.
+ *
+ * Return 0 on success and a non-zero error code on failure to re-validate
+ * existing handle.
+ */
+
+int cvar_revalidate_handle(void *cvar_handle);
+
+/*
+ * Called every time a new value of the custom variable is required.
+ *
+ * Implementation: Mandatory.
+ *
+ * Return 0 on success and non zero on error. On success, argument value is
+ * initialized to the next value of the variable whose state is in handle.
+ */
+
+int cvar_next_value(void *cvar_handle, double *value);
+
+/*
+ * Called when an existing custom variable has to be destroyed. Use function
+ * cvar_free to free up memory allocated for cvar_handle. If cvar_free_handle is
+ * not implemented, Filebench will invoke a cvar_free directly on cvar_handle.
+ *
+ * Implementation: Optional.
+ *
+ * Note: cvar_free_handle may not be called at all, i.e., Filebench may choose
+ * to quit without invoking free_handle.
+ */
+
+void cvar_free_handle(void *cvar_handle, void (*cvar_free)(void *ptr));
+
+/*
+ * Invoked before unloading the module.
+ *
+ * Implementation: Optional.
+ *
+ * Note:
+ * 1. cvar_module_exit will never be invoked if cvar_module_init failed.
+ * 2. cvar_module_exit may not be called at all, i.e., Filebench may choose
+ * to quit without invoking cvar_module_exit.
+ */
+
+void cvar_module_exit();
+
+/*
+ * Show usage, including information on the list of parameters supported and the
+ * format of the parameter string.
+ *
+ * Implementation: Optional.
+ *
+ * Return a non-null, formatted string to be displayed on screen.
+ */
+
+const char *cvar_usage();
+
+/*
+ * Show version.
+ *
+ * Implementation: Optional.
+ *
+ * Return a non-null version string.
+ */
+
+const char *cvar_version();
+
+#endif /* _CVAR_H */
diff --git a/cvars/utils/cvar_trace.h b/cvars/utils/cvar_trace.h
new file mode 100644
index 0000000..27b7be9
--- /dev/null
+++ b/cvars/utils/cvar_trace.h
@@ -0,0 +1,76 @@
+/*
+ * cvar_trace.h
+ *
+ * Tracing and logging utilities.
+ *
+ * Author: Santhosh Kumar Koundinya (santhosh@fsl.cs.sunysb.edu)
+ */
+
+#ifndef _CVAR_TRACE_H
+#define _CVAR_TRACE_H
+
+#include <stdio.h>
+#include <stdlib.h>
+
+#define cvar_log_error(fmt, ...) fprintf(stderr, fmt ".\n", ##__VA_ARGS__)
+
+#ifdef DEBUG
+
+#define cvar_trace(fmt, ...) fprintf(stdout, "%s: %d: %s: " fmt ".\n",\
+		__FILE__, __LINE__, __func__, ##__VA_ARGS__)
+
+/* Tracing functions */
+static inline void cvar_tracebuf(const void *buff, unsigned int len)
+{
+	char *buf = (char *)buff;
+	unsigned int i;
+	char *sbuf = NULL;
+
+	if (len == 0)
+		return;
+
+	sbuf = (char *)malloc(2 + 2*len + 1);
+	if (sbuf == NULL) {
+		fprintf(stdout, "out of memory. unable to print "
+				"buffer in hex.");
+		return;
+	}
+
+	sbuf[2*len + 2] = '\0';
+
+	sprintf(sbuf, "%s", "0x");
+
+	for (i = 0; i < len; i++) {
+		if (((buf[i] & 0xF0) >> 4) < 0x0A)
+			sprintf(sbuf + 2 + 2*i, "%c", '0' +
+					(int)((buf[i] & 0xF0) >> 4));
+		else
+			sprintf(sbuf + 2 + 2*i, "%c", 'a' +
+					(char) (((buf[i] & 0xF0) >> 4) - 0x0A));
+
+		if ((buf[i] & 0x0F) < 0x0A)
+			sprintf(sbuf + 2 + 2*i + 1, "%c", '0' +
+					(int)(buf[i] & 0x0F));
+		else
+			sprintf(sbuf + 2 + 2*i + 1, "%c", 'a' +
+					(char) ((buf[i] & 0x0F) - 0x0A));
+	}
+
+	fprintf(stdout, "%s.\n", sbuf);
+	free(sbuf);
+
+	return;
+}
+
+#else
+
+#define cvar_trace(fmt, ...)
+
+static inline void cvar_tracebuf(const void *buff, unsigned int len)
+{
+	return;
+}
+
+#endif /* DEBUG */
+
+#endif /* _CVAR_TRACE_H */
diff --git a/cvars/utils/mtwist/Makefile b/cvars/utils/mtwist/Makefile
new file mode 100644
index 0000000..eeb1785
--- /dev/null
+++ b/cvars/utils/mtwist/Makefile
@@ -0,0 +1,15 @@
+CC=gcc
+CFLAGS=-g -O0 -Wall -fPIC
+
+.PHONEY : all
+all : randistrs
+
+randistrs : mtwist randistrs.h randistrs.c
+	${CC} -c ${CFLAGS} randistrs.c
+
+mtwist : mtwist.h mtwist.c
+	${CC} -c ${CFLAGS} mtwist.c
+
+.PHONEY : clean
+clean :
+	rm -f mtwist.o randistrs.o
diff --git a/cvars/utils/mtwist/mtwist.3 b/cvars/utils/mtwist/mtwist.3
new file mode 100644
index 0000000..57d81e6
--- /dev/null
+++ b/cvars/utils/mtwist/mtwist.3
@@ -0,0 +1,371 @@
+.\"
+.\" $Id: mtwist.3,v 1.1.2.1 2011/01/11 22:08:51 santhosh Exp $
+.\"
+.\" $Log: mtwist.3,v $
+.\" Revision 1.1.2.1  2011/01/11 22:08:51  santhosh
+.\" PURPOSE: Savepoint.
+.\" REVIEW REQUIRED: N/a.
+.\"
+.\" Revision 1.7  2010-06-24 01:53:59-07  geoff
+.\" Change all documented declarations to use types from stdint.h.  Fix
+.\" some restriction descriptions.  Remove bugs that are no longer bugs.
+.\"
+.\" Revision 1.6  2007-10-26 00:21:06-07  geoff
+.\" Document the new mt_u32bit_t type (barely).
+.\"
+.\" Revision 1.5  2002/10/30 07:39:53  geoff
+.\" Document the new seeding routines.
+.\"
+.\" Revision 1.4  2001/06/20 08:15:51  geoff
+.\" Correct the documentation of the generator's period.
+.\"
+.\" Revision 1.3  2001/06/19 00:43:01  geoff
+.\" Document the lack of a newline in the << operator
+.\"
+.\" Revision 1.2  2001/06/18 10:09:24  geoff
+.\" Fix the manual section.
+.\"
+.\" Revision 1.1  2001/06/16 21:20:31  geoff
+.\" Initial revision
+.\"
+.\" 
+.TH mtwist 3 "June 14, 2001" "" "Linux Programmer's Manual"
+.SH NAME
+mts_seed32new, mts_seed32, mts_seedfull, mts_seed, mts_goodseed, mts_bestseed,
+mts_savestate, mts_loadstate, mt_seed32new, mt_seed32, mt_seedfull, mt_seed,
+mt_goodseed, mt_bestseed, mt_getstate, mt_savestate, mt_loadstate,
+mts_lrand, mts_llrand, mts_drand, mts_ldrand, mt_lrand, mt_llrand,
+mt_drand, mt_ldrand,
+mt_prng \- generate uniformly distributed pseudo-random numbers
+.SH SYNOPSIS
+.nf
+.IR "#defines" " (see below)"
+.br
+.B
+#include "mtwist.h"
+.sp
+C interface:
+.sp
+.BI "void mts_seed32(mt_state* " state ", uint32_t " seed ");"
+.sp
+.BI "void mts_seed32new(mt_state* " state ", uint32_t " seed ");"
+.sp
+.BI "void mts_seedfull(mt_state* " state ","
+.BI "                  uint32_t " seeds "[MT_STATE_SIZE]);"
+.sp
+.BI "void mts_seed(mt_state* " state ");"
+.sp
+.BI "void mts_goodseed(mt_state* " state ");"
+.sp
+.BI "void mts_bestseed(mt_state* " state ");"
+.sp
+.BI "int mts_savestate(FILE* " statefile ", mt_state* " state ");"
+.sp
+.BI "int mts_loadstate(FILE* " statefile ", mt_state* " state ");"
+.sp
+.BI "void mt_seed32(uint32_t " seed ");"
+.sp
+.BI "void mt_seed32new(uint32_t " seed ");"
+.sp
+.BI "void mt_seedfull(uint32_t " seeds "[MT_STATE_SIZE]);"
+.sp
+.B void mt_seed(void);
+.sp
+.B void mt_goodseed(void);
+.sp
+.B void mt_bestseed(void);
+.sp
+.B mt_state* mt_getstate(void);
+.sp
+.BI "int mt_savestate(FILE* " statefile ");"
+.sp
+.BI "int mt_loadstate(FILE* " statefile ");"
+.sp
+.BI "uint32_t mts_lrand(mt_state* " state ");"
+.sp
+.BI "uint64_t mts_llrand(mt_state* " state ");"
+.sp
+.BI "double mts_drand(mt_state* " state ");"
+.sp
+.BI "double mts_ldrand(mt_state* " state ");"
+.sp
+.B uint32_t mt_lrand(void);
+.sp
+.B uint64_t mt_llrand(void);
+.sp
+.B double mt_drand(void);
+.sp
+.B double mt_ldrand(void);
+.sp
+.B "C++ interface:"
+.sp
+.BI "mt_prng " rng ;
+.sp
+.BI "mt_prng " rng "(bool " pickseed " = false);"
+.sp
+.BI "mt_prng " rng "(uint32_t " seed );
+.sp
+.BI "mt_prng " rng "(uint32_t " seeds [MT_STATE_SIZE]);
+.sp
+.BI "void " rng ".seed32(uint32_t " seed ");"
+.sp
+.BI "void " rng ".seedfull(uint32_t seeds[MT_STATE_SIZE]);"
+.sp
+.BI "void " rng ".seed();"
+.sp
+.BI "void " rng ".goodseed();"
+.sp
+.BI "void " rng ".bestseed();"
+.sp
+.BI "uint32_t " rng ".lrand();"
+.sp
+.BI "uint64_t " rng ".llrand();"
+.sp
+.BI "double " rng ".drand();"
+.sp
+.BI "double " rng ".ldrand();"
+.sp
+.BI "double " rng "();"
+.sp
+.IB "stream" " << " rng ";"
+.sp
+.IB "stream" " >> " rng ";"
+.SH DESCRIPTION
+These functions generate pseudo-random numbers using Matsumoto and
+Nishimura's Mersenne Twist algorithm (see:
+.nf
+.sp
+        http://www.math.keio.ac.jp/~matumoto/emt.html
+.sp
+.fi
+for full information).
+The period of this pseudo random-number generator (PRNG) is 2^19337-1
+which is vastly longer than the life of the universe
+even if the random numbers are being generated at an impossible rate.
+The generator also has excellent statistical properties.
+.PP
+The
+.B mtwist
+package assumes a 32-bit machine with a modern C or C++ compiler that
+supports inline functions and the
+.B inttypes.h
+header file.
+If these features are not present, the package must be modified.
+.PP
+All of the PRNG functions work from a
+.IR "state vector" ,
+which is of type
+.B mt_state
+in C and type
+.B mt_prng
+in C++.
+The state vector stores everything that the PRNG needs to generate new
+numbers in the proper sequence.
+By using multiple state vectors, programs can draw random numbers from
+independent sequences, which is important in applications such as
+simulation (where each independent random variable should be drawn
+from its own sequence to avoid unintentional correlations).
+.PP
+For convenience, the C interface also provides a built-in default
+state vector that can be used in simple applications.
+The
+.BI mt_ xxx
+functions use the default state vector to control their behavior,
+while the
+.BI mts_xxx
+functions accept a user-provided state vector.
+.PP
+In C, a user-provided state vector has the following structure:
+.PP
+.nf
+#define MT_STATE_SIZE 624
+
+typedef struct {
+.in +8
+uint32_t statevec[MT_STATE_SIZE];
+.in +16
+/* Vector holding current state */
+.in -16
+int stateptr;   /* Next state entry to be used */
+int initialized;
+.in +16
+/* NZ if state has been initialized */
+.in -24
+} mt_state;
+.fi
+.PP
+An uninitialized PRNG is indicated by zeros in
+.I both
+.B stateptr
+and
+.BR initialized .
+It is the programmer's responsibility to ensure that these fields are
+zero before calling any of the
+.BI mts_xxx
+functions.
+.PP
+It is occasionally useful to directly access the default state vector, so
+.B mt_getstate
+will return a pointer to the default state.
+.PP
+In both C and C++, the functionality is divided into two categories:
+seeding and pseudorandom-number generation.
+If one of the generation functions is called on an unseeded generator,
+a default seed (specified by Matsumoto and Nishimura) will be used.
+Usually, the programmer will wish to override the default seed and
+choose a more appropriate one.
+The simplest way to seed a PRNG is by calling one of the
+.B *seed32new
+functions.
+This will invoke Matsumoto and Nishimura's revised Knuth-style seed
+generator.
+.PP
+The
+.B *seed32
+functions
+will invoke Matsumoto and Nishimura's original Knuth-style seed
+generator, which is now deprecated.
+In C++, the same effect can be achieved by passing a 32-bit
+.RB ( "uint32_t" )
+seed to the constructor.
+The original 32-bit seeder did not work correctly if the seed was zero,
+so in that
+case the default seed of 4357 will be substituted.
+The original seeder is still supported so that older software will
+continue to work in the same fashion without changes.
+.PP
+The
+.B *seed32new
+and
+.B *seed32
+functions are simple to use, but they have the drawback that only 4
+billion distinct pseudorandom sequences can be generated using them.
+To allow access to sequences beginning anywhere in the entire space of
+possibilities, the
+.B *seedfull
+functions can be passed an initial state vector of 624 32-bit numbers,
+or a C++ PRNG can be constructed with a 624-element array as an
+argument.
+The initialization vector must contain at least one nonzero value;
+if this rule is violated, the program will be aborted (unfortunately
+without a diagnostic message due to C/C++ portability issues).
+.PP
+The
+.BR *seed32new ,
+.BR *seed32 ,
+and
+.B *seedfull
+functions allow fixed, reproducible seeds, which is useful for
+simulation and experimentation.
+For game-like applications, non-reproducible seeds are usually more
+appropriate.
+The
+.BR mts_seed ,
+.BR mt_seed ,
+and
+.B seed
+functions use the system time to generate an argument to the
+.B *seed32new
+functions to satisfy this need.
+The microseconds portion of the time is included in the seed to
+enhance the probability that two programs will generate different
+random sequences.
+.PP
+Since the various "plain"
+.B seed
+functions are also somewhat limited in the variety they can produce,
+two other functions are available on systems that have support for the
+.B /dev/random
+device.
+The
+.B *goodseed
+functions attempt to use
+.B /dev/urandom
+to get truly random values for use with
+.BR *seedfull .
+If
+.B /dev/urandom
+isn't available, these functions fall back to calling the equivalent "plain"
+.B seed
+function.
+C++ programmers can also invoke
+.B goodseed
+at construction time by passing an argument of
+.B true
+to the constructor.
+.PP
+For the most random seed possible, the
+.B *bestseed
+functions attempt to use
+.B /dev/random
+to acquire values for
+.BR *seedfull ,
+falling back to
+.B *seed
+if
+.B /dev/random
+is unavailable.
+The disadvantage of these functions is that it usually takes a
+significant amount of (wall-clock) time before
+.B /dev/random
+can produce enough entropy to provide a seed.
+Therefore, it is nearly always better to stick with the
+.B *goodseed
+functions.
+.PP
+Finally, it is often useful to be able to save and restore the PRNG
+state for later use.
+In C, the functions
+.B *savestate
+.B *loadstate
+will save the current state into an open
+.B stdio
+.B FILE
+as a single long line (in ASCII)
+and later restore it such that the restored PRNG will pick up where
+the saved one left off.
+In C++, the same effect can be achieved by writing to or reading from
+a C++
+.B stream
+using the usual
+.B "<<"
+and
+.B ">>"
+operators.
+As with all well-behaved C++ types, the
+.B "<<"
+operator does not add a newline after the saved state.
+.PP
+Once a generator has been seeded,
+uniformly distributed pseudorandom numbers can be produced in several
+formats.
+(The functions in the
+.IR randistrs (3)
+library can be used to produce other statistical distributions.)
+The
+.B *lrand
+and
+.B *llrand
+generate 32-bit and 64-bit random integers uniformly distributed
+between 0 and the maximum unsigned value.
+(The
+.B *llrand
+functions are only available on machines that support a 64-bit
+data type.
+The
+.B *drand
+functions generate a double-precision number in the range [0,1)
+(i.e., 0 is a possible value but 1 is not).
+The number generated by
+.B *drand
+has 32 bits of precision.
+For convenience, the C++ interface also defines a function operator
+that returns the same result as
+.BR drand ,
+so that a PRNG can be called as if it were a function.
+For applications that demand increased precision, the
+.B *ldrand
+functions generate a double-precision number in [0,1) with up to 64
+bits of precision (usually 52 bits).
+.SH "SEE ALSO"
+.BR randistrs "(3), " drand48 "(3), " rand "(3), " random (3)
diff --git a/cvars/utils/mtwist/mtwist.c b/cvars/utils/mtwist/mtwist.c
new file mode 100644
index 0000000..cc061c3
--- /dev/null
+++ b/cvars/utils/mtwist/mtwist.c
@@ -0,0 +1,954 @@
+#ifndef lint
+static char Rcs_Id[] =
+    "$Id: mtwist.c,v 1.1.2.1 2011/01/11 22:08:51 santhosh Exp $";
+#endif
+
+/*
+ * C library functions for generating pseudorandom numbers using the
+ * Mersenne Twist algorithm.  See M. Matsumoto and T. Nishimura,
+ * "Mersenne Twister: A 623-Dimensionally Equidistributed Uniform
+ * Pseudo-Random Number Generator", ACM Transactions on Modeling and
+ * Computer Simulation, Vol. 8, No. 1, January 1998, pp 3--30.
+ *
+ * The Web page on the Mersenne Twist algorithm is at:
+ *
+ * http://www.math.keio.ac.jp/~matumoto/emt.html
+ *
+ * These functions were written by Geoff Kuenning, Claremont, CA.
+ *
+ * IMPORTANT NOTE: this implementation assumes a modern compiler.  In
+ * particular, it assumes that the "inline" keyword is available, and
+ * that the "inttypes.h" header file is present.
+ *
+ * IMPORTANT NOTE: this software requires access to a 32-bit type.
+ * The Mersenne Twist algorithms are not guaranteed to produce correct
+ * results with a 64-bit type.
+ *
+ * This software is based on LGPL-ed code by Takuji Nishimura.  It has
+ * also been heavily influenced by code written by Shawn Cokus, and
+ * somewhat influenced by code written by Richard J. Wagner.  It is
+ * therefore also distributed under the LGPL:
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public License
+ * as published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.  You should have
+ * received a copy of the GNU Library General Public License along
+ * with this library; if not, write to the Free Foundation, Inc., 59
+ * Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ * $Log: mtwist.c,v $
+ * Revision 1.1.2.1  2011/01/11 22:08:51  santhosh
+ * PURPOSE: Savepoint.
+ * REVIEW REQUIRED: N/a.
+ *
+ * Revision 1.22  2010-06-24 01:53:59-07  geoff
+ * Switch to using types and formats from inttypes.h.  Get rid of all
+ * compilation options.
+ *
+ * Revision 1.21  2010-06-24 00:29:38-07  geoff
+ * Correctly save and restore the state vector even if longs are wider
+ * than 32 bits.
+ *
+ * Revision 1.20  2007-10-26 00:21:06-07  geoff
+ * Use the new mt_u32bit_t type.
+ *
+ * Revision 1.19  2003/09/11 05:55:19  geoff
+ * Get rid of some minor compiler warnings.
+ *
+ * Revision 1.18  2003/09/11 05:50:53  geoff
+ * Don't #define inline to nothing, since that breaks standard include
+ * files.  Instead, use MT_INLINE as a synonym.
+ *
+ * Revision 1.17  2002/10/31 22:07:10  geoff
+ * Make WIN32 detection work with GCC as well as MS C
+ *
+ * Revision 1.16  2002/10/31 22:04:59  geoff
+ * Fix a typo in the WIN32 option
+ *
+ * Revision 1.15  2002/10/31 06:01:43  geoff
+ * Incorporate Joseph Brill's Windows-portability changes
+ *
+ * Revision 1.14  2002/10/30 07:39:53  geoff
+ * Reintroduce the old seeding functions (so that old code will still
+ * produce the same results), and give the new versions new names.
+ *
+ * Revision 1.13  2002/10/30 01:08:26  geoff
+ * Switch to M&T's new initialization method
+ *
+ * Revision 1.12  2001/06/18 05:40:12  geoff
+ * Prefix the compile options with MT_.
+ *
+ * Revision 1.11  2001/06/14 10:26:59  geoff
+ * Invert the sense of the #define flags so that the default is the
+ * normal case (if gcc is normal!).  Also default MT_MACHINE_BITS to 32.
+ *
+ * Revision 1.10  2001/06/14 10:10:38  geoff
+ * Move the RNG functions into the header file so they can be inlined.
+ * Add saving/loading of state.  Add a function that marks the PRNG as
+ * initialized while also calculating critical constants.  Run the
+ * refresh routine whenever seed32 is called.  Add functions to seed
+ * based on /dev/random or the time.
+ *
+ * Revision 1.9  2001/06/11 10:00:04  geoff
+ * Major changes to improve flexibility and performance, and to prepare
+ * for inlining.  This code is about as fast as it can get without
+ * inlining the various PRNG functions.  Add seed/goodseed/bestseed for
+ * seeding from random start values.  Add the refresh routine a la Cokus,
+ * but optimize it by unrolling loops.  Change getstate to return a
+ * complete state pointer, since knowing the position in the state vector
+ * is critical to restoring state.  Add more macros to improve
+ * readability.  Rename certain macros in preparation for inlining.  Get
+ * rid of leftover optimizer-bug stuff.  Stop using mtwist_guts.h;
+ * instead use direct code (via macros) and the refresh function.
+ *
+ * Revision 1.8  2001/04/23 08:36:03  geoff
+ * Move the #defined code into a header file to ease stepping with a debugger.
+ *
+ * Revision 1.7  2001/04/23 08:00:13  geoff
+ * Add code to work around optimizer bug
+ *
+ * Revision 1.6  2001/04/14 01:33:32  geoff
+ * Clarify the license
+ *
+ * Revision 1.5  2001/04/09 08:45:00  geoff
+ * Rename default_state to mt_default_state, and make it global so that
+ * the random-distribution code can use it.
+ *
+ * Revision 1.4  2001/04/07 23:24:11  geoff
+ * My guess in the commentary for the last delta was right: it's faster
+ * on a x86 to convert the two halves of the PRN to double, multiplying
+ * them by the appropriate value to scale them, and then add them as
+ * doubles.  I suspect the reason is that there is no instruction to
+ * convert a 64-bit value directly to a double, so the work of building
+ * the long long (which isn't easy anyway, without assembly access) is
+ * worse than wasted.  So add support for MT_MACHINE_BITS, and only go
+ * the via-long-long route on a true 64-bit machine.
+ *
+ * Revision 1.3  2001/04/07 23:09:38  geoff
+ * Get rid of MT_INLINE.  Convert all of the code to use preprocessor
+ * macros for the guts of the PRNG code.  Take advantage of the
+ * conversion to get rid of unnecessary calls initialization tests.  Also
+ * clean up the generation of long-double pseudorandom numbers on
+ * machines that have the long long type (by converting first to a long
+ * long, then to a double, saving one floating-point operation).  The
+ * latter change might be a mistake on 32-bit machines.  The code is now
+ * much faster as a result of macro-izing.
+ *
+ * Revision 1.2  2001/04/07 22:21:41  geoff
+ * Make the long-double code a hair faster by always having a 64-bit
+ * conversion constant.  Add commentary to the PRNG loop.
+ *
+ * Revision 1.1  2001/04/07 09:43:41  geoff
+ * Initial revision
+ *
+ */
+
+#ifdef _WIN32
+#undef WIN32
+#define WIN32
+#endif /* _WIN32 */
+
+#include <inttypes.h>
+#include <stdio.h>
+#include <stdlib.h>
+#ifdef WIN32
+#include <sys/timeb.h>
+#else /* WIN32 */
+#include <sys/time.h>
+#endif /* WIN32 */
+
+/*
+ * Before we include the Mersenne Twist header file, we must do a bit
+ * of magic setup.  The code for actual random-number generation
+ * resides in that file rather than here.  We need to arrange for the
+ * code to be compiled into this .o file, either because inlines
+ * aren't supported or because somebody might want to take a pointer
+ * to a function.  We do so with a couple of careful #defines.
+ */
+#define MT_INLINE			/* Disable the inline keyword */
+#define MT_EXTERN			/* Generate real code for functions */
+
+#include "mtwist.h"
+
+/*
+ * Table of contents:
+ */
+void			mts_mark_initialized(mt_state* state);
+					/* Mark a PRNG state as initialized */
+void			mts_seed32(mt_state* state, uint32_t seed);
+					/* Set random seed for any generator */
+void			mts_seed32new(mt_state* state, uint32_t seed);
+					/* Set random seed for any generator */
+void			mts_seedfull(mt_state* state,
+			  uint32_t seeds[MT_STATE_SIZE]);
+					/* Set complicated seed for any gen. */
+void			mts_seed(mt_state* state);
+					/* Choose seed from random input */
+void			mts_goodseed(mt_state* state);
+					/* Choose seed from more random */
+					/* ..input than mts_seed */
+static void		mts_devseed(mt_state* state, char* seed_dev);
+					/* Choose seed from a device */
+void			mts_bestseed(mt_state* state);
+					/* Choose seed from extremely random */
+					/* ..input (can be *very* slow) */
+void			mts_refresh(mt_state* state);
+					/* Generate 624 more random values */
+int			mts_savestate(FILE* statefile, mt_state* state);
+					/* Save state to a file (ASCII) */
+int			mts_loadstate(FILE* statefile, mt_state* state);
+					/* Load state from a file (ASCII) */
+
+void			mt_seed32(uint32_t seed);
+					/* Set random seed for default gen. */
+void			mt_seed32new(uint32_t seed);
+					/* Set random seed for default gen. */
+void			mt_seedfull(uint32_t seeds[MT_STATE_SIZE]);
+					/* Set complicated seed for default */
+void			mt_seed(void);	/* Choose seed from random input */
+void			mt_goodseed(void);
+					/* Choose seed from more random */
+					/* ..input than mts_seed */
+void			mt_bestseed(void);
+					/* Choose seed from extremely random */
+					/* ..input (can be *very* slow) */
+extern mt_state*	mt_getstate(void);
+					/* Get current state of default */
+					/* ..generator */
+int			mt_savestate(FILE* statefile);
+					/* Save state to a file (ASCII) */
+int			mt_loadstate(FILE* statefile);
+					/* Load state from a file (ASCII) */
+
+
+/*
+ * The following values are fundamental parameters of the algorithm.
+ * With the exception of the two masks, all of them were found
+ * experimentally using methods described in Matsumoto and Nishimura's
+ * paper.  They are exceedingly magic; don't change them.
+ */
+
+/* MT_STATE_SIZE is defined in the header file. */
+#define RECURRENCE_OFFSET 397		/* Offset into state space for the */
+					/* ..recurrence relation.  The */
+					/* ..recurrence mashes together two */
+					/* ..values that are separated by */
+					/* ..this offset in the state */
+					/* ..space. */
+#define MATRIX_A	0x9908b0df	/* Constant vector A for the */
+					/* ..recurrence relation.  The */
+					/* ..mashed-together value is */
+					/* ..multiplied by this vector to */
+					/* ..get a new value that will be */
+					/* ..stored into the state space. */
+
+/*
+ * Width of an unsigned int.  Don't change this even if your ints are 64 bits.
+ */
+#define BIT_WIDTH	32		/* Work with 32-bit words */
+
+/*
+ * Masks for extracting the bits to be mashed together.  The widths of these
+ * masks are also fundamental parameters of the algorithm, determined
+ * experimentally -- but of course the masks themselves are simply bit
+ * selectors.
+ */
+#define UPPER_MASK	0x80000000	/* Most significant w-r bits */
+#define LOWER_MASK	0x7fffffff	/* Least significant r bits */
+
+/*
+ * Macro to simplify code in the generation loop.  This function
+ * combines the top bit of x with the bottom 31 bits of y.
+ */
+#define COMBINE_BITS(x, y) \
+			(((x) & UPPER_MASK) | ((y) & LOWER_MASK))
+
+/*
+ * Another generation-simplification macro.  This one does the magic
+ * scrambling function.
+ */
+#define MATRIX_MULTIPLY(original, new) \
+			((original) ^ ((new) >> 1) \
+			  ^ matrix_decider[(new) & 0x1])
+
+/*
+ * Parameters of Knuth's PRNG (Line 25, Table 1, p. 102 of "The Art of
+ * Computer Programming, Vol. 2, 2nd ed, 1981).
+ */
+#define KNUTH_MULTIPLIER_OLD \
+			69069
+
+/*
+ * Parameters of Knuth's PRNG (p. 106 of "The Art of Computer
+ * Programming, Vol. 2, 3rd ed).
+ */
+#define KNUTH_MULTIPLIER_NEW \
+			1812433253ul
+#define KNUTH_SHIFT	30		// Even on a 64-bit machine!
+
+/*
+ * Default 32-bit random seed if mts_seed32 wasn't called
+ */
+#define DEFAULT_SEED32_OLD \
+			4357
+#define DEFAULT_SEED32_NEW \
+			5489ul
+
+/*
+ * Where to get random numbers
+ */
+#define DEVRANDOM	"/dev/random"
+#define DEVURANDOM	"/dev/urandom"
+
+/*
+ * Many applications need only a single PRNG, so it's a nuisance to have to
+ * specify a state.  For those applications, we will provide a default
+ * state, and functions to use it.
+ */
+mt_state		mt_default_state;
+
+/*
+ * To generate double-precision random numbers, we need to divide the result
+ * of mts_lrand or mts_llrand by 2^32 or 2^64, respectively.  The quickest
+ * way to do that on most machines is to multiply by the inverses of those
+ * numbers.  However, I don't trust the compiler to correctly convert the
+ * corresponding decimal constant.  So we will compute the correct number at
+ * run time as part of initialization, which will produce a nice exact
+ * result.
+ */
+double			mt_32_to_double;
+					/* Multiplier to convert long to dbl */
+double			mt_64_to_double;
+					/* Mult'r to cvt long long to dbl */
+
+/*
+ * In the recurrence relation, the new value is XORed with MATRIX_A only if
+ * the lower bit is nonzero.  Since most modern machines don't like to
+ * branch, it's vastly faster to handle this decision by indexing into an
+ * array.  The chosen bit is used as an index into the following vector,
+ * which produces either zero or MATRIX_A and thus the desired effect.
+ */
+static uint32_t	matrix_decider[2] =
+			  {0x0, MATRIX_A};
+
+/*
+ * Mark a PRNG's state as having been initialized.  This is the only
+ * way to set that field nonzero; that way we can be sure that the
+ * constants are set properly before the PRNG is used.
+ *
+ * As a side effect, set up some constants that the PRNG assumes are
+ * valid.  These are calculated at initialization time rather than
+ * being written as decimal constants because I frankly don't trust
+ * the compiler's ASCII conversion routines.
+ */
+void mts_mark_initialized(
+    mt_state*		state)		/* State vector to mark initialized */
+    {
+    int			i;		/* Power of 2 being calculated */
+
+    /*
+     * Figure out the proper multiplier for long-to-double conversion.  We
+     * don't worry too much about efficiency, since the assumption is that
+     * initialization is vastly rarer than generation of random numbers.
+     */
+    mt_32_to_double = 1.0;
+    for (i = 0;  i < BIT_WIDTH;  i++)
+	mt_32_to_double /= 2.0;
+    mt_64_to_double = mt_32_to_double;
+    for (i = 0;  i < BIT_WIDTH;  i++)
+	mt_64_to_double /= 2.0;
+
+    state->initialized = 1;
+    }
+
+/*
+ * Initialize a Mersenne Twist PRNG from a 32-bit seed.
+ *
+ * According to Matsumoto and Nishimura's paper, the seed array needs to be
+ * filled with nonzero values.  (My own interpretation is that there needs
+ * to be at least one nonzero value).  They suggest using Knuth's PRNG from
+ * Line 25, Table 1, p.102, "The Art of Computer Programming," Vol. 2 (2nd
+ * ed.), 1981.  I find that rather odd, since that particular PRNG is
+ * sensitive to having an initial seed of zero (there are many other PRNGs
+ * out there that have an additive component, so that a seed of zero does
+ * not generate a repeating-zero sequence).  However, one thing I learned
+ * from reading Knuth is that you shouldn't second-guess mathematicians
+ * about PRNGs.  Also, by following M & N's approach, we will be compatible
+ * with other implementations.  So I'm going to stick with their version,
+ * with the single addition that a zero seed will be changed to their
+ * default seed.
+ */
+void mts_seed32(
+    mt_state*		state,		/* State vector to initialize */
+    uint32_t		seed)		/* 32-bit seed to start from */
+    {
+    int			i;		/* Loop index */
+
+    if (seed == 0)
+	seed = DEFAULT_SEED32_OLD;
+
+    /*
+     * Fill the state vector using Knuth's PRNG.  Be sure to mask down
+     * to 32 bits in case we're running on a machine with 64-bit
+     * ints.
+     */
+    state->statevec[MT_STATE_SIZE - 1] = seed & 0xffffffff;
+    for (i = MT_STATE_SIZE - 2;  i >= 0;  i--)
+        state->statevec[i] =
+          (KNUTH_MULTIPLIER_OLD * state->statevec[i + 1]) & 0xffffffff;
+
+    state->stateptr = MT_STATE_SIZE;
+    mts_mark_initialized(state);
+
+    /*
+     * Matsumoto and Nishimura's implementation refreshes the PRNG
+     * immediately after running the Knuth algorithm.  This is
+     * probably a good thing, since Knuth's PRNG doesn't generate very
+     * good numbers.
+     */
+    mts_refresh(state);
+    }
+
+/*
+ * Initialize a Mersenne Twist PRNG from a 32-bit seed, using
+ * Matsumoto and Nishimura's newer reference implementation (Jan. 9,
+ * 2002).
+ */
+void mts_seed32new(
+    mt_state*		state,		/* State vector to initialize */
+    uint32_t		seed)		/* 32-bit seed to start from */
+    {
+    int			i;		/* Loop index */
+    uint32_t		nextval;	/* Next value being calculated */
+
+    /*
+     * Fill the state vector using Knuth's PRNG.  Be sure to mask down
+     * to 32 bits in case we're running on a machine with 64-bit
+     * ints.
+     */
+    state->statevec[MT_STATE_SIZE - 1] = seed & 0xffffffffUL;
+    for (i = MT_STATE_SIZE - 2;  i >= 0;  i--)
+	{
+	nextval = state->statevec[i + 1] >> KNUTH_SHIFT;
+	nextval ^= state->statevec[i + 1];
+	nextval *= KNUTH_MULTIPLIER_NEW;
+	nextval += (MT_STATE_SIZE - 1) - i;
+	state->statevec[i] = nextval & 0xffffffffUL;
+	}
+
+    state->stateptr = MT_STATE_SIZE;
+    mts_mark_initialized(state);
+
+    /*
+     * Matsumoto and Nishimura's implementation refreshes the PRNG
+     * immediately after running the Knuth algorithm.  This is
+     * probably a good thing, since Knuth's PRNG doesn't generate very
+     * good numbers.
+     */
+    mts_refresh(state);
+    }
+
+/*
+ * Initialize a Mersenne Twist RNG from a 624-int seed.
+ *
+ * The 32-bit seeding routine given by Matsumoto and Nishimura has the
+ * drawback that there are only 2^32 different PRNG sequences that can be
+ * generated by calling that function.  This function solves that problem by
+ * allowing a full 624*32-bit state to be given.  (Note that 31 bits of the
+ * given state are ignored; see the paper for details.)
+ *
+ * Since an all-zero state would cause the PRNG to cycle, we detect
+ * that case and abort the program (silently, since there is no
+ * portable way to produce a message in both C and C++ environments).
+ * An alternative would be to artificially force the state to some
+ * known nonzero value.  However, I feel that if the user is providing
+ * a full state, it's a bug to provide all zeros and we we shouldn't
+ * conceal the bug by generating apparently correct output.
+ */
+void mts_seedfull(
+    mt_state*		state,		/* State vector to initialize */
+    uint32_t		seeds[MT_STATE_SIZE])
+					/* Seed array to start from */
+    {
+    int			had_nz = 0;	/* NZ if at least one NZ seen */
+    int			i;		/* Loop index */
+
+    for (i = 0;  i < MT_STATE_SIZE;  i++)
+        {
+        if (seeds[i] != 0)
+	    had_nz = 1;
+        state->statevec[MT_STATE_SIZE - i - 1] = seeds[i];
+	}
+
+    if (!had_nz)
+	{
+	/*
+	 * It would be nice to abort with a message.  Unfortunately, fprintf
+	 * isn't compatible with all implementations of C++.  In the
+	 * interest of C++ compatibility, therefore, we will simply abort
+	 * silently.  It will unfortunately be up to a programmer to run
+	 * under a debugger (or examine the core dump) to discover the cause
+	 * of the abort.
+	 */
+	abort();
+	}
+
+    state->stateptr = MT_STATE_SIZE;
+    mts_mark_initialized(state);
+    }
+
+/*
+ * Choose a seed based on some moderately random input.  Prefers
+ * /dev/urandom as a source of random numbers, but uses the lower bits
+ * of the current time if /dev/urandom is not available.  In any case,
+ * only provides 32 bits of entropy.
+ */
+void mts_seed(
+    mt_state*		state)		/* State vector to seed */
+    {
+    mts_devseed(state, DEVURANDOM);
+    }
+
+/*
+ * Choose a seed based on some fairly random input.  Prefers
+ * /dev/random as a source of random numbers, but uses the lower bits
+ * of the current time if /dev/random is not available.  In any case,
+ * only provides 32 bits of entropy.
+ */
+void mts_goodseed(
+    mt_state*		state)		/* State vector to seed */
+    {
+    mts_devseed(state, DEVRANDOM);
+    }
+
+/*
+ * Choose a seed based on a random-number device given by the caller.
+ * If that device can't be opened, use the lower 32 bits from the
+ * current time.
+ */
+static void mts_devseed(
+    mt_state*		state,		/* State vector to seed */
+    char*		seed_dev)	/* Device to seed from */
+    {
+    int			bytesread;	/* Byte count read from device */
+    int			nextbyte;	/* Index of next byte to read */
+    FILE*		ranfile;	/* Access to device */
+    union
+	{
+	char		ranbuffer[sizeof (uint32_t)];
+					/* Space for reading random int */
+	uint32_t	randomvalue;	/* Random value for initialization */
+	}
+			randomunion;	/* Union for reading random int */
+#ifdef WIN32
+    struct _timeb	tb;		/* Time of day (Windows mode) */
+#else /* WIN32 */
+    struct timeval	tv;		/* Time of day */
+    struct timezone	tz;		/* Dummy for gettimeofday */
+#endif /* WIN32 */
+
+    ranfile = fopen(seed_dev, "rb");
+    if (ranfile != NULL)
+	{
+	for (nextbyte = 0;
+	  nextbyte < (int)sizeof randomunion.ranbuffer;
+	  nextbyte += bytesread)
+	    {
+	    bytesread = fread(&randomunion.ranbuffer[nextbyte], 1,
+	      sizeof randomunion.ranbuffer - nextbyte, ranfile);
+	    if (bytesread == 0)
+		break;
+	    }
+	fclose(ranfile);
+	if (nextbyte == sizeof randomunion.ranbuffer)
+	    {
+	    mts_seed32new(state, randomunion.randomvalue);
+	    return;
+	    }
+	}
+
+    /*
+     * The device isn't available.  Use the time.  We will
+     * assume that the time of day is accurate to microsecond
+     * resolution, which is true on most modern machines.
+     */
+#ifdef WIN32
+    (void) _ftime (&tb);
+#else /* WIN32 */
+    (void) gettimeofday (&tv, &tz);
+#endif /* WIN32 */
+
+    /*
+     * We just let the excess part of the seconds field overflow
+     */
+#ifdef WIN32
+    randomunion.randomvalue = tb.time * 1000 + tb.millitm;
+#else /* WIN32 */
+    randomunion.randomvalue = tv.tv_sec * 1000000 + tv.tv_usec;
+#endif /* WIN32 */
+    mts_seed32new(state, randomunion.randomvalue);
+    }
+
+/*
+ * Choose a seed based on the best random input available.  Prefers
+ * /dev/random as a source of random numbers, and reads the entire
+ * 624-int state from that device.  Because of this approach, the
+ * function can take a long time (in real time) to complete, since
+ * /dev/random may have to wait quite a while before it can provide
+ * that much randomness.  If /dev/random is unavailable, falls back to
+ * calling mts_goodseed.
+ */
+void mts_bestseed(
+    mt_state*		state)		/* State vector to seed */
+    {
+    int			bytesread;	/* Byte count read from device */
+    int			nextbyte;	/* Index of next byte to read */
+    FILE*		ranfile;	/* Access to device */
+
+    ranfile = fopen("/dev/random", "rb");
+    if (ranfile == NULL)
+	{
+	mts_goodseed(state);
+	return;
+	}
+
+    for (nextbyte = 0;
+      nextbyte < (int)sizeof state->statevec;
+      nextbyte += bytesread)
+	{
+	bytesread = fread((char *)&state->statevec + nextbyte, 1,
+	  sizeof state->statevec - nextbyte, ranfile);
+	if (bytesread == 0)
+	    {
+	    /*
+	     * Something went wrong.  Fall back to time-based seeding.
+	     */
+	    fclose(ranfile);
+	    mts_goodseed(state);
+	    return;
+	    }
+	}
+    }
+
+/*
+ * Generate 624 more random values.  This function is called when the
+ * state vector has been exhausted.  It generates another batch of
+ * pseudo-random values.  The performance of this function is critical
+ * to the performance of the Mersenne Twist PRNG, so it has been
+ * highly optimized.
+ */
+void mts_refresh(
+    register mt_state*	state)		/* State for the PRNG */
+    {
+    register int	i;		/* Index into the state */
+    register uint32_t*
+			state_ptr;	/* Next place to get from state */
+    register uint32_t
+			value1;		/* Scratch val picked up from state */
+    register uint32_t
+			value2;		/* Scratch val picked up from state */
+
+    /*
+     * Start by making sure a random seed has been set.  If not, set
+     * one.
+     */
+    if (!state->initialized)
+	{
+	mts_seed32(state, DEFAULT_SEED32_OLD);
+	return;				/* Seed32 calls us recursively */
+	}
+
+    /*
+     * Now generate the new pseudorandom values by applying the
+     * recurrence relation.  We use two loops and a final
+     * 2-statement sequence so that we can handle the wraparound
+     * explicitly, rather than having to use the relatively slow
+     * modulus operator.
+     *
+     * In essence, the recurrence relation concatenates bits
+     * chosen from the current random value (last time around)
+     * with the immediately preceding one.  Then it
+     * matrix-multiplies the concatenated bits with a value
+     * RECURRENCE_OFFSET away and a constant matrix.  The matrix
+     * multiplication reduces to a shift and two XORs.
+     *
+     * Some comments on the optimizations are in order:
+     *
+     * Strictly speaking, none of the optimizations should be
+     * necessary.  All could conceivably be done by a really good
+     * compiler.  However, the compilers available to me aren't quite
+     * smart enough, so hand optimization needs to be done.
+     *
+     * Shawn Cokus was the first to achieve a major speedup.  In the
+     * original code, the first value given to COMBINE_BITS (in my
+     * characterization) was re-fetched from the state array, rather
+     * than being carried in a scratch variable.  Cokus noticed that
+     * the first argument to COMBINE_BITS could be saved in a register
+     * in the previous loop iteration, getting rid of the need for an
+     * expensive memory reference.
+     *
+     * Cokus also switched to using pointers to access the state
+     * array and broke the original loop into two so that he could
+     * avoid using the expensive modulus operator.  Cokus used three
+     * pointers; Richard J. Wagner noticed that the offsets between
+     * the three were constant, so that they could be collapsed into a
+     * single pointer and constant-offset accesses.  This is clearly
+     * faster on x86 architectures, and is the same cost on RISC
+     * machines.  A secondary benefit is that Cokus' version was
+     * register-starved on the x86, while Wagner's version was not.
+     *
+     * I made several smaller improvements to these observations.
+     * First, I reversed the contents of the state vector.  In the
+     * current version of the code, this change doesn't directly
+     * affect the performance of the refresh loop, but it has the nice
+     * side benefit that an all-zero state structure represents an
+     * uninitialized generator.  It also slightly speeds up the
+     * random-number routines, since they can compare the state
+     * pointer against zero instead of against a constant (this makes
+     * the biggest difference on RISC machines).
+     *
+     * Second, I returned to Matsumoto and Nishimura's original
+     * technique of using a lookup table to decide whether to xor the
+     * constant vector A (MATRIX_A in this code) with the newly
+     * computed value.  Cokus and Wagner had used the ?: operator,
+     * which requires a test and branch.  Modern machines don't like
+     * branches, so the table lookup is faster.
+     *
+     * Third, in the Cokus and Wagner versions the loop ends with a
+     * statement similar to "value1 = value2", which is necessary to
+     * carry the fetched value into the next loop iteration.  I
+     * recognized that if the loop were unrolled so that it generates
+     * two values per iteration, a bit of variable renaming would get
+     * rid of that assignment.  A nice side effect is that the
+     * overhead of loop control becomes only half as large.
+     *
+     * It is possible to improve the code's performance somewhat
+     * further.  In particular, since the second loop's loop count
+     * factors into 2*2*3*3*11, it could be unrolled yet further.
+     * That's easy to do, too: just change the "/ 2" into a division
+     * by whatever factor you choose, and then use cut-and-paste to
+     * duplicate the code in the body.  To remove a few more cycles,
+     * fix the code to decrement state_ptr by the unrolling factor, and
+     * adjust the various offsets appropriately.  However, the payoff
+     * will be small.  At the moment, the x86 version of the loop is
+     * 25 instructions, of which 3 are involved in loop control
+     * (including the decrementing of state_ptr).  Further unrolling by
+     * a factor of 2 would thus produce only about a 6% speedup.
+     *
+     * The logical extension of the unrolling
+     * approach would be to remove the loops and create 624
+     * appropriate copies of the body.  However, I think that doing
+     * the latter is a bit excessive!
+     *
+     * I suspect that a superior optimization would be to simplify the
+     * mathematical operations involved in the recurrence relation.
+     * However, I have no idea whether such a simplification is
+     * feasible.
+     */
+    state_ptr = &state->statevec[MT_STATE_SIZE - 1];
+    value1 = *state_ptr;
+    for (i = (MT_STATE_SIZE - RECURRENCE_OFFSET) / 2;  --i >= 0;  )
+	{
+	state_ptr -= 2;
+	value2 = state_ptr[1];
+	value1 = COMBINE_BITS(value1, value2);
+	state_ptr[2] =
+	  MATRIX_MULTIPLY(state_ptr[-RECURRENCE_OFFSET + 2], value1);
+	value1 = state_ptr[0];
+	value2 = COMBINE_BITS(value2, value1);
+	state_ptr[1] =
+	  MATRIX_MULTIPLY(state_ptr[-RECURRENCE_OFFSET + 1], value2);
+	}
+    value2 = *--state_ptr;
+    value1 = COMBINE_BITS(value1, value2);
+    state_ptr[1] =
+      MATRIX_MULTIPLY(state_ptr[-RECURRENCE_OFFSET + 1], value1);
+
+    for (i = (RECURRENCE_OFFSET - 1) / 2;  --i >= 0;  )
+	{
+	state_ptr -= 2;
+	value1 = state_ptr[1];
+	value2 = COMBINE_BITS(value2, value1);
+	state_ptr[2] =
+	  MATRIX_MULTIPLY(state_ptr[MT_STATE_SIZE - RECURRENCE_OFFSET + 2],
+	    value2);
+	value2 = state_ptr[0];
+	value1 = COMBINE_BITS(value1, value2);
+	state_ptr[1] =
+	  MATRIX_MULTIPLY(state_ptr[MT_STATE_SIZE - RECURRENCE_OFFSET + 1],
+	    value1);
+	}
+
+    /*
+     * The final entry in the table requires the "previous" value
+     * to be gotten from the other end of the state vector, so it
+     * must be handled specially.
+     */
+    value1 = COMBINE_BITS(value2, state->statevec[MT_STATE_SIZE - 1]);
+    *state_ptr =
+      MATRIX_MULTIPLY(state_ptr[MT_STATE_SIZE - RECURRENCE_OFFSET], value1);
+
+    /*
+     * Now that refresh is complete, reset the state pointer to allow more
+     * pseudorandom values to be fetched from the state array.
+     */
+    state->stateptr = MT_STATE_SIZE;
+    }
+
+/*
+ * Save state to a file.  The save format is compatible with Richard
+ * J. Wagner's format, although the details are different.  Returns NZ
+ * if the save succeeded.  Produces one very long line containing 625
+ * numbers.
+ */
+int mts_savestate(
+    FILE*		statefile,	/* File to save to */
+    mt_state*		state)		/* State to be saved */
+    {
+    int			i;		/* Next word to save */
+
+    if (!state->initialized)
+	mts_seed32(state, DEFAULT_SEED32_OLD);
+
+    for (i = MT_STATE_SIZE;  --i >= 0;  )
+	{
+	if (fprintf(statefile, "%" PRIu32 " ", state->statevec[i]) < 0)
+	    return 0;
+	}
+
+    if (fprintf(statefile, "%d\n", state->stateptr) < 0)
+	return 0;
+
+    return 1;
+    }
+
+/*
+ * Load state from a file.  Returns NZ if the load succeeded.
+ */
+int mts_loadstate(
+    FILE*		statefile,	/* File to load from */
+    mt_state*		state)		/* State to be loaded */
+    {
+    int			i;		/* Next word to load */
+
+    /*
+     * Set the state to "uninitialized" in case the load fails.
+     */
+    state->initialized = state->stateptr = 0;
+
+    for (i = MT_STATE_SIZE;  --i >= 0;  )
+	{
+	if (fscanf(statefile, "%" SCNu32, &state->statevec[i]) != 1)
+	    return 0;
+	}
+
+    if (fscanf(statefile, "%d", &state->stateptr) != 1)
+	return 0;
+
+    /*
+     * The only validity checking we can do is to insist that the
+     * state pointer be valid.
+     */
+    if (state->stateptr < 0  ||  state->stateptr > MT_STATE_SIZE)
+	{
+	state->stateptr = 0;
+	return 0;
+	}
+
+    mts_mark_initialized(state);
+
+    return 1;
+    }
+
+/*
+ * Initialize the default Mersenne Twist PRNG from a 32-bit seed.
+ *
+ * See mts_seed32 for full commentary.
+ */
+void mt_seed32(
+    uint32_t		seed)		/* 32-bit seed to start from */
+    {
+    mts_seed32(&mt_default_state, seed);
+    }
+
+/*
+ * Initialize the default Mersenne Twist PRNG from a 32-bit seed.
+ *
+ * See mts_seed32new for full commentary.
+ */
+void mt_seed32new(
+    uint32_t		seed)		/* 32-bit seed to start from */
+    {
+    mts_seed32new(&mt_default_state, seed);
+    }
+
+/*
+ * Initialize a Mersenne Twist RNG from a 624-int seed.
+ *
+ * See mts_seedfull for full commentary.
+ */
+void mt_seedfull(
+    uint32_t		seeds[MT_STATE_SIZE])
+    {
+    mts_seedfull(&mt_default_state, seeds);
+    }
+
+/*
+ * Initialize the PRNG from random input.  See mts_seed.
+ */
+void mt_seed()
+    {
+    mts_seed(&mt_default_state);
+    }
+
+/*
+ * Initialize the PRNG from random input.  See mts_goodseed.
+ */
+void mt_goodseed()
+    {
+    mts_goodseed(&mt_default_state);
+    }
+
+/*
+ * Initialize the PRNG from random input.  See mts_bestseed.
+ */
+void mt_bestseed()
+    {
+    mts_bestseed(&mt_default_state);
+    }
+
+/*
+ * Return a pointer to the current state of the PRNG.  The purpose of
+ * this function is to allow the state to be saved for later
+ * restoration.  The state should not be modified; instead, it should
+ * be reused later as a parameter to one of the mts_xxx functions.
+ */
+extern mt_state* mt_getstate()
+    {
+    return &mt_default_state;
+    }
+
+/*
+ * Save state to a file.  The save format is compatible with Richard
+ * J. Wagner's format, although the details are different.
+ */
+int mt_savestate(
+    FILE*		statefile)	/* File to save to */
+    {
+    return mts_savestate(statefile, &mt_default_state);
+    }
+
+/*
+ * Load state from a file.
+ */
+int mt_loadstate(
+    FILE*		statefile)	/* File to load from */
+    {
+    return mts_loadstate(statefile, &mt_default_state);
+    }
diff --git a/cvars/utils/mtwist/mtwist.h b/cvars/utils/mtwist/mtwist.h
new file mode 100644
index 0000000..fecad74
--- /dev/null
+++ b/cvars/utils/mtwist/mtwist.h
@@ -0,0 +1,815 @@
+#ifndef MTWIST_H
+#define MTWIST_H
+
+/*
+ * $Id: mtwist.h,v 1.1.2.1 2011/01/11 22:08:51 santhosh Exp $
+ *
+ * Header file for C/C++ use of the Mersenne-Twist pseudo-RNG.  See
+ * http://www.math.keio.ac.jp/~matumoto/emt.html for full information.
+ *
+ * Author of this header file: Geoff Kuenning, March 18, 2001.
+ *
+ * IMPORTANT NOTE: this implementation assumes a modern compiler.  In
+ * particular, it assumes that the "inline" keyword is available, and
+ * that the "stdint.h" header file is present.
+ *
+ * The variables above are defined in an inverted sense because I
+ * expect that most modern compilers will support these features.  By
+ * inverting the sense, this common case will require no special
+ * compiler flags.
+ *
+ * IMPORTANT NOTE: this software requires access to a 32-bit type.
+ * The Mersenne Twist algorithms are not guaranteed to produce correct
+ * results with a 64-bit type.
+ *
+ * The executable part of this software is based on LGPL-ed code by
+ * Takuji Nishimura.  The header file is therefore also distributed
+ * under the LGPL:
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public License
+ * as published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.  You should have
+ * received a copy of the GNU Library General Public License along
+ * with this library; if not, write to the Free Foundation, Inc., 59
+ * Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ * $Log: mtwist.h,v $
+ * Revision 1.1.2.1  2011/01/11 22:08:51  santhosh
+ * PURPOSE: Savepoint.
+ * REVIEW REQUIRED: N/a.
+ *
+ * Revision 1.19  2010-06-24 01:53:59-07  geoff
+ * Switch to using types from stdint.h.  Get rid of all compilation
+ * options.
+ *
+ * Revision 1.18  2010-06-24 00:29:38-07  geoff
+ * Do a better job of auto-determining MT_MACHINE_BITS.
+ *
+ * Revision 1.17  2007-10-26 00:21:06-07  geoff
+ * Introduce, document, and use the new mt_u32bit_t type so that the code
+ * will compile and run on 64-bit platforms (although it does not
+ * currently use the 64-bit Mersenne Twist algorithm).
+ *
+ * Revision 1.16  2005/11/11 08:21:39  geoff
+ * If possible, try to infer MT_MACHINE_BITS from limits.h.
+ *
+ * Revision 1.15  2003/09/11 23:56:20  geoff
+ * Allow stdio references in C++ files; it turns out that ANSI has
+ * blessed it.  Declare the various functions as external even if they're
+ * inlined or being compiled directly (in mtwist.c).  Get rid of a #ifdef
+ * that can't ever be true.
+ *
+ * Revision 1.14  2003/09/11 05:50:53  geoff
+ * Don't allow stdio references from C++, since they're not guaranteed to
+ * work on all compilers.  Disable inlining using the MT_INLINE keyword
+ * rather than #defining inline, since doing the latter can affect other
+ * files and functions than our own.
+ *
+ * Revision 1.13  2003/07/01 23:29:29  geoff
+ * Refer to streams from the standard library using the correct namespace.
+ *
+ * Revision 1.12  2002/10/30 07:39:54  geoff
+ * Declare the new seeding functions.
+ *
+ * Revision 1.11  2001/06/19 00:41:16  geoff
+ * For consistency with other C++ types, don't put out a newline after
+ * the saved data.
+ *
+ * Revision 1.10  2001/06/18 10:09:24  geoff
+ * Fix some places where I forgot to set one of the result values.  Make
+ * the C++ state vector protected so the random-distributions package can
+ * pass it to the C functions.
+ *
+ * Revision 1.9  2001/06/18 05:40:12  geoff
+ * Prefix the compile options with MT_.
+ *
+ * Revision 1.8  2001/06/14 10:26:59  geoff
+ * Invert the sense of the #define flags so that the default is the
+ * normal case (if gcc is normal!).  Also default MT_MACHINE_BITS to 32.
+ *
+ * Revision 1.7  2001/06/14 10:10:38  geoff
+ * Move the critical-path PRNG code into the header file so that it can
+ * be inlined.  Add saving/loading of state.  Add functions to seed based
+ * on /dev/random or the time.  Add the function-call operator in the C++
+ * code.
+ *
+ * Revision 1.6  2001/06/11 10:00:04  geoff
+ * Add declarations of the refresh and /dev/random seeding functions.
+ * Change getstate to return a complete state pointer, since knowing the
+ * position in the state vector is critical to restoring the state.
+ *
+ * Revision 1.5  2001/04/23 08:36:03  geoff
+ * Remember to zero the state pointer when constructing, since otherwise
+ * proper initialization won't happen.
+ *
+ * Revision 1.4  2001/04/14 01:33:32  geoff
+ * Clarify the license
+ *
+ * Revision 1.3  2001/04/14 01:04:54  geoff
+ * Add a C++ class, mt_prng, that makes usage more convenient for C++
+ * programmers.
+ *
+ * Revision 1.2  2001/04/09 08:45:00  geoff
+ * Fix the name in the #ifndef wrapper, and clean up some outdated comments.
+ *
+ * Revision 1.1  2001/04/07 09:43:41  geoff
+ * Initial revision
+ *
+ */
+
+#include <stdio.h>
+#ifdef __cplusplus
+#include <iostream>
+#endif /* __cplusplus */
+
+#define __STDC_LIMIT_MACROS
+#include <stdint.h>
+
+/*
+ * The following value is a fundamental parameter of the algorithm.
+ * It was found experimentally using methods described in Matsumoto
+ * and Nishimura's paper.  It is exceedingly magic; don't change it.
+ */
+#define MT_STATE_SIZE	624		/* Size of the MT state vector */
+
+/*
+ * Internal state for an MT RNG.  The user can keep multiple mt_state
+ * structures around as a way of generating multiple streams of random
+ * numbers.
+ *
+ * In Matsumoto and Nishimura's original paper, the state vector was
+ * processed in a forward direction.  I have reversed the state vector
+ * in this implementation.  The reason for the reversal is that it
+ * allows the critical path to use a test against zero instead of a
+ * test against 624 to detect the need to refresh the state.  on most
+ * machines, testing against zero is slightly faster.  It also means
+ * that a state that has been set to all zeros will be correctly
+ * detected as needing initialization; this means that setting a state
+ * vector to zero (either with memset or by statically allocating it)
+ * will cause the RNG to operate properly.
+ */
+
+typedef struct
+    {
+    uint32_t		statevec[MT_STATE_SIZE];
+					/* Vector holding current state */
+    int			stateptr;	/* Next state entry to be used */
+    int			initialized;	/* NZ if state was initialized */
+    }
+			mt_state;
+
+#ifdef __cplusplus
+extern "C"
+    {
+#endif
+
+/*
+ * Functions for manipulating any generator (given a state pointer).
+ */
+extern void		mts_mark_initialized(mt_state* state);
+					/* Mark a PRNG state as initialized */
+extern void		mts_seed32(mt_state* state, uint32_t seed);
+					/* Set random seed for any generator */
+extern void		mts_seed32new(mt_state* state, uint32_t seed);
+					/* Set random seed for any generator */
+extern void		mts_seedfull(mt_state* state,
+			  uint32_t seeds[MT_STATE_SIZE]);
+					/* Set complicated seed for any gen. */
+extern void		mts_seed(mt_state* state);
+					/* Choose seed from random input. */
+					/* ..Prefers /dev/urandom; uses time */
+					/* ..if /dev/urandom unavailable. */
+					/* ..Only gives 32 bits of entropy. */
+extern void		mts_goodseed(mt_state* state);
+					/* Choose seed from more random */
+					/* ..input than mts_seed.  Prefers */
+					/* ../dev/random; uses time if that */
+					/* ..is unavailable.  Only gives 32 */
+					/* ..bits of entropy. */
+extern void		mts_bestseed(mt_state* state);
+					/* Choose seed from extremely random */
+					/* ..input (can be *very* slow). */
+					/* ..Prefers /dev/random and reads */
+					/* ..the entire state from there. */
+					/* ..If /dev/random is unavailable, */
+					/* ..falls back to mt_goodseed().  */
+					/* ..Not usually worth the cost.  */
+extern void		mts_refresh(mt_state* state);
+					/* Generate 624 more random values */
+extern int		mts_savestate(FILE* statefile, mt_state* state);
+					/* Save state to a file (ASCII). */
+					/* ..Returns NZ if succeeded. */
+extern int		mts_loadstate(FILE* statefile, mt_state* state);
+					/* Load state from a file (ASCII). */
+					/* ..Returns NZ if succeeded. */
+
+/*
+ * Functions for manipulating the default generator.
+ */
+extern void		mt_seed32(uint32_t seed);
+					/* Set random seed for default gen. */
+extern void		mt_seed32new(uint32_t seed);
+					/* Set random seed for default gen. */
+extern void		mt_seedfull(uint32_t seeds[MT_STATE_SIZE]);
+					/* Set complicated seed for default */
+extern void		mt_seed(void);	/* Choose seed from random input. */
+					/* ..Prefers /dev/urandom; uses time */
+					/* ..if /dev/urandom unavailable. */
+					/* ..Only gives 32 bits of entropy. */
+extern void		mt_goodseed(void);
+					/* Choose seed from more random */
+					/* ..input than mts_seed.  Prefers */
+					/* ../dev/random; uses time if that */
+					/* ..is unavailable.  Only gives 32 */
+					/* ..bits of entropy. */
+extern void		mt_bestseed(void);
+					/* Choose seed from extremely random */
+					/* ..input (can be *very* slow). */
+					/* ..Prefers /dev/random and reads */
+					/* ..the entire state from there. */
+					/* ..If /dev/random is unavailable, */
+					/* ..falls back to mt_goodseed().  */
+					/* ..Not usually worth the cost.  */
+extern mt_state*	mt_getstate(void);
+					/* Get current state of default */
+					/* ..generator */
+extern int		mt_savestate(FILE* statefile);
+					/* Save state to a file (ASCII) */
+					/* ..Returns NZ if succeeded. */
+extern int		mt_loadstate(FILE* statefile);
+					/* Load state from a file (ASCII) */
+					/* ..Returns NZ if succeeded. */
+
+#ifdef __cplusplus
+    }
+#endif
+
+/*
+ * Functions for generating random numbers.  The actual code of the
+ * functions is given in this file so that it can be declared inline.
+ * For compilers that don't have the inline feature, mtwist.c will
+ * incorporate this file with some clever #defining so that the code
+ * actually gets compiled.  In that case, however, "extern"
+ * definitions will be needed here, so we give them.
+ */
+#ifdef __cplusplus
+#endif /* __cplusplus */
+
+extern uint32_t		mts_lrand(mt_state* state);
+					/* Generate 32-bit value, any gen. */
+#ifdef UINT64_MAX
+extern uint64_t		mts_llrand(mt_state* state);
+					/* Generate 64-bit value, any gen. */
+#endif /* UINT64_MAX */
+extern double		mts_drand(mt_state* state);
+					/* Generate floating value, any gen. */
+					/* Fast, with only 32-bit precision */
+extern double		mts_ldrand(mt_state* state);
+					/* Generate floating value, any gen. */
+					/* Slower, with 64-bit precision */
+
+extern uint32_t		mt_lrand(void);	/* Generate 32-bit random value */
+#ifdef UINT64_MAX
+extern uint64_t		mt_llrand(void);
+					/* Generate 64-bit random value */
+#endif /* UINT64_MAX */
+extern double		mt_drand(void);
+					/* Generate floating value */
+					/* Fast, with only 32-bit precision */
+extern double		mt_ldrand(void);
+					/* Generate floating value */
+					/* Slower, with 64-bit precision */
+
+/*
+ * Tempering parameters.  These are perhaps the most magic of all the magic
+ * values in the algorithm.  The values are again experimentally determined.
+ * The values generated by the recurrence relation (constants above) are not
+ * equidistributed in 623-space.  For some reason, the tempering process
+ * produces that effect.  Don't ask me why.  Read the paper if you can
+ * understand the math.  Or just trust these magic numbers.
+ */
+#define MT_TEMPERING_MASK_B 0x9d2c5680
+#define MT_TEMPERING_MASK_C 0xefc60000
+#define MT_TEMPERING_SHIFT_U(y) \
+			(y >> 11)
+#define MT_TEMPERING_SHIFT_S(y) \
+			(y << 7)
+#define MT_TEMPERING_SHIFT_T(y) \
+			(y << 15)
+#define MT_TEMPERING_SHIFT_L(y) \
+			(y >> 18)
+
+/*
+ * Macros to do the tempering.  MT_PRE_TEMPER does all but the last step;
+ * it's useful for situations where the final step can be incorporated
+ * into a return statement.  MT_FINAL_TEMPER does that final step (not as
+ * an assignment).  MT_TEMPER does the entire process.  Note that
+ * MT_PRE_TEMPER and MT_TEMPER both modify their arguments.
+ */
+#define MT_PRE_TEMPER(value)						\
+    do									\
+	{								\
+	value ^= MT_TEMPERING_SHIFT_U(value);				\
+	value ^= MT_TEMPERING_SHIFT_S(value) & MT_TEMPERING_MASK_B;	\
+	value ^= MT_TEMPERING_SHIFT_T(value) & MT_TEMPERING_MASK_C;	\
+	}								\
+	while (0)
+#define MT_FINAL_TEMPER(value) \
+			((value) ^ MT_TEMPERING_SHIFT_L(value))
+#define MT_TEMPER(value)						\
+    do									\
+	{								\
+	value ^= MT_TEMPERING_SHIFT_U(value);				\
+	value ^= MT_TEMPERING_SHIFT_S(value) & MT_TEMPERING_MASK_B;	\
+	value ^= MT_TEMPERING_SHIFT_T(value) & MT_TEMPERING_MASK_C;	\
+	value ^= MT_TEMPERING_SHIFT_L(value);				\
+	}								\
+	while (0)
+
+extern mt_state		mt_default_state;
+					/* State of the default generator */
+extern double		mt_32_to_double;
+					/* Multiplier to convert long to dbl */
+extern double		mt_64_to_double;
+					/* Mult'r to cvt long long to dbl */
+
+/*
+ * In gcc, inline functions must be declared extern or they'll produce
+ * assembly code (and thus linking errors).  We have to work around
+ * that difficulty with the MT_EXTERN define.
+ */
+#ifndef MT_EXTERN
+#ifdef __cplusplus
+#define MT_EXTERN			/* C++ doesn't need static */
+#else /* __cplusplus */
+#define MT_EXTERN	extern		/* C (at least gcc) needs extern */
+#endif /* __cplusplus */
+#endif /* MT_EXTERN */
+
+/*
+ * Make it possible for mtwist.c to disable the inline keyword.  We
+ * use our own keyword so that we don't interfere with inlining in
+ * C/C++ header files, above.
+ */
+#ifndef MT_INLINE
+#define MT_INLINE	inline		/* Compiler has inlining */
+#endif /* MT_INLINE */
+
+/*
+ * Generate a random number in the range 0 to 2^32-1, inclusive, working
+ * from a given state vector.
+ *
+ * The generator is optimized for speed.  The primary optimization is that
+ * the pseudorandom numbers are generated in batches of MT_STATE_SIZE.  This
+ * saves the cost of a modulus operation in the critical path.
+ */
+MT_EXTERN MT_INLINE uint32_t mts_lrand(
+    register mt_state*	state)		/* State for the PRNG */
+    {
+    register uint32_t	random_value;	/* Pseudorandom value generated */
+
+    if (state->stateptr <= 0)
+	mts_refresh(state);
+
+    random_value = state->statevec[--state->stateptr];
+    MT_PRE_TEMPER(random_value);
+    return MT_FINAL_TEMPER(random_value);
+    }
+
+#ifdef UINT64_MAX
+/*
+ * Generate a random number in the range 0 to 2^64-1, inclusive, working
+ * from a given state vector.
+ *
+ * According to Matsumoto and Nishimura, such a number can be generated by
+ * simply concatenating two 32-bit pseudorandom numbers.  Who am I to argue?
+ *
+ * Note that there is a slight inefficiency here: if the 624-entry state is
+ * recycled on the second call to mts_lrand, there will be an unnecessary
+ * check to see if the state has been initialized.  The cost of that check
+ * seems small (since it happens only once every 624 random numbers, and
+ * never if only 64-bit numbers are being generated), so I didn't bother to
+ * optimize it out.  Doing so would be messy, since it would require two
+ * nearly-identical internal implementations of mts_lrand.
+ */
+MT_EXTERN MT_INLINE uint64_t mts_llrand(
+    register mt_state*	state)		/* State for the PRNG */
+    {
+    register uint32_t	random_value_1;	/* 1st pseudorandom value generated */
+    register uint32_t	random_value_2;	/* 2nd pseudorandom value generated */
+
+    /*
+     * For maximum speed, we'll handle the two overflow cases
+     * together.  That will save us one test in the common case, at
+     * the expense of an extra one in the overflow case.
+     */
+    if (--state->stateptr <= 0)
+	{
+	if (state->stateptr < 0)
+	    {
+	    mts_refresh(state);
+	    random_value_1 = state->statevec[--state->stateptr];
+	    }
+	else
+	    {
+	    random_value_1 = state->statevec[state->stateptr];
+	    mts_refresh(state);
+	    }
+	}
+    else
+	random_value_1 = state->statevec[--state->stateptr];
+
+    MT_TEMPER(random_value_1);
+
+    random_value_2 = state->statevec[--state->stateptr];
+    MT_PRE_TEMPER(random_value_2);
+
+    return ((uint64_t) random_value_1 << 32)
+      | (uint64_t) MT_FINAL_TEMPER(random_value_2);
+    }
+#endif /* UINT64_MAX */
+
+/*
+ * Generate a double-precision random number between 0 (inclusive) and 1.0
+ * (exclusive).  This function is optimized for speed, but it only generates
+ * 32 bits of precision.  Use mts_ldrand to get 64 bits of precision.
+ */
+MT_EXTERN MT_INLINE double mts_drand(
+    register mt_state*	state)		/* State for the PRNG */
+    {
+    register uint32_t	random_value;	/* Pseudorandom value generated */
+
+    if (state->stateptr <= 0)
+	mts_refresh(state);
+
+    random_value = state->statevec[--state->stateptr];
+    MT_TEMPER(random_value);
+
+    return random_value * mt_32_to_double;
+    }
+
+/*
+ * Generate a double-precision random number between 0 (inclusive) and 1.0
+ * (exclusive).  This function generates 64 bits of precision.  Use
+ * mts_drand for more speed but less precision.
+ */
+MT_EXTERN MT_INLINE double mts_ldrand(
+    register mt_state*	state)		/* State for the PRNG */
+    {
+#ifdef UINT64_MAX
+    uint64_t		final_value;	/* Final (integer) value */
+#endif /* UINT64_MAX */
+    register uint32_t	random_value_1;	/* 1st pseudorandom value generated */
+    register uint32_t	random_value_2;	/* 2nd pseudorandom value generated */
+
+    /*
+     * For maximum speed, we'll handle the two overflow cases
+     * together.  That will save us one test in the common case, at
+     * the expense of an extra one in the overflow case.
+     */
+    if (--state->stateptr <= 0)
+	{
+	if (state->stateptr < 0)
+	    {
+	    mts_refresh(state);
+	    random_value_1 = state->statevec[--state->stateptr];
+	    }
+	else
+	    {
+	    random_value_1 = state->statevec[state->stateptr];
+	    mts_refresh(state);
+	    }
+	}
+    else
+	random_value_1 = state->statevec[--state->stateptr];
+
+    MT_TEMPER(random_value_1);
+
+    random_value_2 = state->statevec[--state->stateptr];
+    MT_TEMPER(random_value_2);
+
+#ifdef UINT64_MAX
+    final_value = ((uint64_t) random_value_1 << 32) | (uint64_t) random_value_2;
+    return final_value * mt_64_to_double;
+#else /* UINT64_MAX */
+    return random_value_1 * mt_32_to_double + random_value_2 * mt_64_to_double;
+#endif /* UINT64_MAX */
+    }
+
+/*
+ * Generate a random number in the range 0 to 2^32-1, inclusive, working
+ * from the default state vector.
+ *
+ * See mts_lrand for full commentary.
+ */
+MT_EXTERN MT_INLINE uint32_t mt_lrand()
+    {
+    register uint32_t	random_value;	/* Pseudorandom value generated */
+
+    if (mt_default_state.stateptr <= 0)
+	mts_refresh(&mt_default_state);
+
+    random_value = mt_default_state.statevec[--mt_default_state.stateptr];
+    MT_PRE_TEMPER(random_value);
+
+    return MT_FINAL_TEMPER(random_value);
+    }
+
+#ifdef UINT64_MAX
+/*
+ * Generate a random number in the range 0 to 2^64-1, inclusive, working
+ * from the default state vector.
+ *
+ * See mts_llrand for full commentary.
+ */
+MT_EXTERN MT_INLINE uint64_t mt_llrand()
+    {
+    register uint32_t	random_value_1;	/* 1st pseudorandom value generated */
+    register uint32_t	random_value_2;	/* 2nd pseudorandom value generated */
+
+    /*
+     * For maximum speed, we'll handle the two overflow cases
+     * together.  That will save us one test in the common case, at
+     * the expense of an extra one in the overflow case.
+     */
+    if (--mt_default_state.stateptr <= 0)
+	{
+	if (mt_default_state.stateptr < 0)
+	    {
+	    mts_refresh(&mt_default_state);
+	    random_value_1 =
+	      mt_default_state.statevec[--mt_default_state.stateptr];
+	    }
+	else
+	    {
+	    random_value_1 =
+	      mt_default_state.statevec[mt_default_state.stateptr];
+	    mts_refresh(&mt_default_state);
+	    }
+	}
+    else
+	random_value_1 =
+	  mt_default_state.statevec[--mt_default_state.stateptr];
+
+    MT_TEMPER(random_value_1);
+
+    random_value_2 = mt_default_state.statevec[--mt_default_state.stateptr];
+    MT_PRE_TEMPER(random_value_2);
+
+    return ((uint64_t) random_value_1 << 32)
+      | (uint64_t) MT_FINAL_TEMPER(random_value_2);
+    }
+#endif /* UINT64_MAX */
+
+/*
+ * Generate a double-precision random number between 0 (inclusive) and 1.0
+ * (exclusive).  This function is optimized for speed, but it only generates
+ * 32 bits of precision.  Use mt_ldrand to get 64 bits of precision.
+ */
+MT_EXTERN MT_INLINE double mt_drand()
+    {
+    register uint32_t	random_value;	/* Pseudorandom value generated */
+
+    if (mt_default_state.stateptr <= 0)
+	mts_refresh(&mt_default_state);
+
+    random_value = mt_default_state.statevec[--mt_default_state.stateptr];
+    MT_TEMPER(random_value);
+
+    return random_value * mt_32_to_double;
+    }
+
+/*
+ * Generate a double-precision random number between 0 (inclusive) and 1.0
+ * (exclusive).  This function generates 64 bits of precision.  Use
+ * mts_drand for more speed but less precision.
+ */
+MT_EXTERN MT_INLINE double mt_ldrand(void)
+    {
+#ifdef UINT64_MAX
+    uint64_t		final_value;	/* Final (integer) value */
+#endif /* UINT64_MAX */
+    register uint32_t	random_value_1;	/* 1st pseudorandom value generated */
+    register uint32_t	random_value_2;	/* 2nd pseudorandom value generated */
+
+    /*
+     * For maximum speed, we'll handle the two overflow cases
+     * together.  That will save us one test in the common case, at
+     * the expense of an extra one in the overflow case.
+     */
+    if (--mt_default_state.stateptr <= 0)
+	{
+	if (mt_default_state.stateptr < 0)
+	    {
+	    mts_refresh(&mt_default_state);
+	    random_value_1 =
+	      mt_default_state.statevec[--mt_default_state.stateptr];
+	    }
+	else
+	    {
+	    random_value_1 =
+	      mt_default_state.statevec[mt_default_state.stateptr];
+	    mts_refresh(&mt_default_state);
+	    }
+	}
+    else
+	random_value_1 =
+	  mt_default_state.statevec[--mt_default_state.stateptr];
+
+    MT_TEMPER(random_value_1);
+
+    random_value_2 = mt_default_state.statevec[--mt_default_state.stateptr];
+    MT_TEMPER(random_value_2);
+
+#ifdef UINT64_MAX
+    final_value = ((uint64_t) random_value_1 << 32) | (uint64_t) random_value_2;
+    return final_value * mt_64_to_double;
+#else /* UINT64_MAX */
+    return random_value_1 * mt_32_to_double + random_value_2 * mt_64_to_double;
+#endif /* UINT64_MAX */
+    }
+
+#ifdef __cplusplus
+/*
+ * C++ interface to the Mersenne Twist PRNG.  This class simply
+ * provides a more C++-ish way to access the PRNG.  Only state-based
+ * functions are provided.  All functions are inlined, both for speed
+ * and so that the same implementation code can be used in C and C++.
+ */
+class mt_prng
+    {
+    public:
+	/*
+	 * Constructors and destructors.  The default constructor
+	 * leaves initialization (seeding) for later unless pickSeed
+	 * is true, in which case the seed is chosen based on either
+	 * /dev/urandom (if available) or the system time.  The other
+	 * constructors accept either a 32-bit seed, or a full
+	 * 624-integer seed.
+	 */
+			mt_prng(	// Default constructor
+			    bool pickSeed = false)
+					// True to get seed from /dev/urandom
+					// ..or time
+			    {
+			    state.stateptr = 0;
+			    state.initialized = 0;
+			    if (pickSeed)
+				mts_seed(&state);
+			    }
+			mt_prng(uint32_t seed)
+					// Construct with 32-bit seeding
+			    {
+			    state.stateptr = 0;
+			    state.initialized = 0;
+			    mts_seed32(&state, seed);
+			    }
+			mt_prng(uint32_t seeds[MT_STATE_SIZE])
+					// Construct with full seeding
+			    {
+			    state.stateptr = 0;
+			    state.initialized = 0;
+			    mts_seedfull(&state, seeds);
+			    }
+			~mt_prng() { }
+
+	/*
+	 * Copy and assignment are best left defaulted.
+	 */
+
+	/*
+	 * PRNG seeding functions.
+	 */
+	void		seed32(uint32_t seed)
+					// Set 32-bit random seed
+			    {
+			    mts_seed32(&state, seed);
+			    }
+	void		seed32new(uint32_t seed)
+					// Set 32-bit random seed
+			    {
+			    mts_seed32new(&state, seed);
+			    }
+	void		seedfull(uint32_t seeds[MT_STATE_SIZE])
+					// Set complicated random seed
+			    {
+			    mts_seedfull(&state, seeds);
+			    }
+	void		seed()		// Choose seed from random input
+			    {
+			    mts_seed(&state);
+			    }
+	void		goodseed()	// Choose better seed from random input
+			    {
+			    mts_goodseed(&state);
+			    }
+	void		bestseed()	// Choose best seed from random input
+			    {
+			    mts_bestseed(&state);
+			    }
+	friend std::ostream&
+			operator<<(std::ostream& stream, const mt_prng& rng);
+	friend std::istream&
+			operator>>(std::istream& stream, mt_prng& rng);
+
+	/*
+	 * PRNG generation functions
+	 */
+	uint32_t	lrand()		// Generate 32-bit pseudo-random value
+			    {
+			    return mts_lrand(&state);
+			    }
+#ifdef UINT64_MAX
+	uint64_t	llrand()	// Generate 64-bit pseudo-random value
+			    {
+			    return mts_llrand(&state);
+			    }
+#endif /* UINT64_MAX */
+	double		drand()		// Generate fast 32-bit floating value
+			    {
+			    return mts_drand(&state);
+			    }
+	double		ldrand()	// Generate slow 64-bit floating value
+			    {
+			    return mts_ldrand(&state);
+			    }
+
+	/*
+	 * Following Richard J. Wagner's example, we overload the
+	 * function-call operator to return a 64-bit floating value.
+	 * That allows the common use of the PRNG to be simplified as
+	 * in the following example:
+	 *
+	 *	mt_prng ranno(true);
+	 *	// ...
+	 *	coinFlip = ranno() >= 0.5 ? heads : tails;
+	 */
+	double		operator()()
+			    {
+			    return mts_drand(&state);
+			    }
+    protected:
+	/*
+	 * Protected data
+	 */
+	mt_state	state;		// Current state of the PRNG
+    };
+
+/*
+ * Save state to a stream.  See mts_savestate.
+ */
+MT_INLINE std::ostream& operator<<(
+    std::ostream&	stream,		// Stream to save to
+    const mt_prng&	rng)		// PRNG to save
+    {
+    for (int i = MT_STATE_SIZE;  --i >= 0;  )
+	{
+	if (!(stream << rng.state.statevec[i] << ' '))
+	    return stream;
+	}
+
+    return stream << rng.state.stateptr;
+    }
+
+/*
+ * Restore state from a stream.  See mts_loadstate.
+ */
+MT_INLINE std::istream& operator>>(
+    std::istream&	stream,		// Stream to laod from
+    mt_prng&		rng)		// PRNG to load
+    {
+    rng.state.initialized = rng.state.stateptr = 0;
+    for (int i = MT_STATE_SIZE;  --i >= 0;  )
+	{
+	if (!(stream >> rng.state.statevec[i]))
+	    return stream;
+	}
+
+    if (!(stream >> rng.state.stateptr))
+	{
+	rng.state.stateptr = 0;
+	return stream;
+	}
+
+    /*
+     * If the state is invalid, all we can do is to make it uninitialized.
+     */
+    if (rng.state.stateptr < 0  ||  rng.state.stateptr > MT_STATE_SIZE)
+	{
+	rng.state.stateptr = 0;
+	return stream;
+	}
+
+    mts_mark_initialized(&rng.state);
+
+    return stream;
+    }
+#endif
+
+#endif /* MTWIST_H */
diff --git a/cvars/utils/mtwist/randistrs.3 b/cvars/utils/mtwist/randistrs.3
new file mode 100644
index 0000000..346b562
--- /dev/null
+++ b/cvars/utils/mtwist/randistrs.3
@@ -0,0 +1,323 @@
+.\"
+.\" $Id: randistrs.3,v 1.1.2.1 2011/01/11 22:08:51 santhosh Exp $
+.\"
+.\" $Log: randistrs.3,v $
+.\" Revision 1.1.2.1  2011/01/11 22:08:51  santhosh
+.\" PURPOSE: Savepoint.
+.\" REVIEW REQUIRED: N/a.
+.\"
+.\" Revision 1.4  2010-06-24 01:53:59-07  geoff
+.\" Change all documented declarations to use types from stdint.h.  Fix
+.\" some restriction descriptions and a misplaced header.  Clarify the
+.\" widths of the "l" versions for integer outputs.
+.\"
+.\" Revision 1.3  2010-06-09 13:19:10-07  geoff
+.\" Fix the notation for open and closed intervals.
+.\"
+.\" Revision 1.2  2001-06-18 17:41:17-07  geoff
+.\" Add documentation of the new "l" versions of all the functions.
+.\"
+.\" Revision 1.1  2001/06/18 10:04:20  geoff
+.\" Initial revision
+.\"
+.\" 
+.TH randistrs 3 "June 18, 2001" "" "Linux Programmer's Manual"
+.SH NAME
+rds_iuniform, rds_liuniform, rds_uniform, rds_luniform,
+rds_exponential, rds_lexponential, rds_erlang, rds_lerlang,
+rds_weibull, rds_lweibull, rds_normal, rds_lnormal, rds_lognormal,
+rds_llognormal, rds_triangular, rds_ltriangular, rds_empirical,
+rds_lempirical, rd_iuniform, rd_liuniform, rd_uniform, rd_luniform,
+rd_exponential, rd_lexponential, rd_erlang, rd_lerlang, rd_weibull,
+rd_lweibull, rd_normal, rd_lnormal, rd_lognormal, rd_llognormal,
+rd_triangular, rd_ltriangular, rd_empirical rd_lempirical \- generate
+pseudo-random numbers in various distributions
+.SH SYNOPSIS
+.nf
+.IR "#defines" " (see below)"
+.br
+.B
+#include "randistrs.h"
+.sp
+C interface:
+.R
+.sp
+.BI "int32_t rds_iuniform(mt_state* " state ", int32_t " lower ", int32_t " upper ");"
+.sp
+.BI "int64_t rds_liuniform(mt_state* " state ","
+.BI "                  int64_t " lower ", int64_t " upper ");"
+.sp
+.BI "double rds_uniform(mt_state* " state ", double " lower ", double " upper ");"
+.sp
+.BI "double rds_luniform(mt_state* " state ", double " lower ", double " upper ");"
+.sp
+.BI "double rds_exponential(mt_state* " state ", double " mean ");"
+.sp
+.BI "double rds_lexponential(mt_state* " state ", double " mean ");"
+.sp
+.BI "double rds_erlang(mt_state* " state ", int " p ", double " mean ");"
+.sp
+.BI "double rds_lerlang(mt_state* " state ", int " p ", double " mean ");"
+.sp
+.BI "double rds_weibull(mt_state* " state ", double " shape ", double " scale ");"
+.sp
+.BI "double rds_lweibull(mt_state* " state ", double " shape ", double " scale ");"
+.sp
+.BI "double rds_normal(mt_state* " state ", double " mean ", double " sigma ");"
+.sp
+.BI "double rds_lnormal(mt_state* " state ", double " mean ", double " sigma ");"
+.sp
+.BI "double rds_lognormal(mt_state* " state ", double " shape ", double " scale ");"
+.sp
+.BI "double rds_llognormal(mt_state* " state ", double " shape ", double " scale ");"
+.sp
+.BI "double rds_triangular(mt_state* " state ", double " lower ","
+.BI "                      double " upper ", double " mode ");"
+.sp
+.BI "double rds_ltriangular(mt_state* " state ", double " lower ","
+.BI "                      double " upper ", double " mode ");"
+.sp
+.BI "double rds_empirical(mt_state* " state ", int " n_probs ","
+.BI "                     double* " values ", double* " probs ");"
+.sp
+.BI "double rds_lempirical(mt_state* " state ", int " n_probs ","
+.BI "                     double* " values ", double* " probs ");"
+.sp
+.BI "int32_t rd_iuniform(int32_t " lower ", int32_t " upper ");"
+.sp
+.BI "int64_t rd_liuniform(int64_t " lower ", int64_t " upper ");"
+.sp
+.BI "double rd_uniform(double " lower ", double " upper ");"
+.sp
+.BI "double rd_luniform(double " lower ", double " upper ");"
+.sp
+.BI "double rd_exponential(double " mean ");"
+.sp
+.BI "double rd_lexponential(double " mean ");"
+.sp
+.BI "double rd_erlang(int " p ", double " mean ");"
+.sp
+.BI "double rd_lerlang(int " p ", double " mean ");"
+.sp
+.BI "double rd_weibull(double " shape ", double " scale ");"
+.sp
+.BI "double rd_lweibull(double " shape ", double " scale ");"
+.sp
+.BI "double rd_normal(double " mean ", double " sigma ");"
+.sp
+.BI "double rd_lnormal(double " mean ", double " sigma ");"
+.sp
+.BI "double rd_lognormal(double " shape ", double " scale ");"
+.sp
+.BI "double rd_llognormal(double " shape ", double " scale ");"
+.sp
+.BI "double rd_triangular(double " lower ", double " upper ", double " mode ");"
+.sp
+.BI "double rd_ltriangular(double " lower ", double " upper ", double " mode ");"
+.sp
+.BI "double rd_empirical(int " n_probs ", double* " values ", double* " probs ");"
+.sp
+.BI "double rd_lempirical(int " n_probs ", double* " values ", double* " probs ");"
+.sp
+.B "C++ interface:"
+.sp
+.BI "mt_distribution " rng ;
+.sp
+.BI "int32_t " rng ".iuniform(int32_t " lower ", int32_t " upper ");"
+.sp
+.BI "int64_t " rng ".liuniform(int64_t " lower ", int64_t " upper ");"
+.sp
+.BI "double " rng ".uniform(double " lower ", double " upper ");"
+.sp
+.BI "double " rng ".luniform(double " lower ", double " upper ");"
+.sp
+.BI "double " rng ".exponential(double " mean ");"
+.sp
+.BI "double " rng ".lexponential(double " mean ");"
+.sp
+.BI "double " rng ".erlang(int " p ", double " mean ");"
+.sp
+.BI "double " rng ".lerlang(int " p ", double " mean ");"
+.sp
+.BI "double " rng ".weibull(double " shape ", double " scale ");"
+.sp
+.BI "double " rng ".lweibull(double " shape ", double " scale ");"
+.sp
+.BI "double " rng ".normal(double " mean ", double " sigma ");"
+.sp
+.BI "double " rng ".lnormal(double " mean ", double " sigma ");"
+.sp
+.BI "double " rng ".lognormal(double " shape ", double " scale ");"
+.sp
+.BI "double " rng ".llognormal(double " shape ", double " scale ");"
+.sp
+.BI "double " rng ".triangular(double " lower ", double " upper ", double " mode ");"
+.sp
+.BI "double " rng ".ltriangular(double " lower ", double " upper ", double " mode ");"
+.sp
+.BI "double " rng ".empirical(int " n_probs ", double* " values ", double* " probs ");"
+.p
+.BI "double " rng ".lempirical(int " n_probs ", double* " values ", double* " probs ");"
+.SH DESCRIPTION
+These functions generate pseudo-random numbers in various
+distributions using the Mersenne Twist algorithm described in
+.BR mtwist (3).
+.PP
+The C interface provides four flavors of each function:
+.BI rds_ xxx\fR,\fP
+.BI rds_l xxx\fR,\fP
+.BI rd_ xxx\fR,\fP
+and
+.BI rd_l xxx\fR.\fP
+The "\fBrds\fP" versions
+accept an explicit Mersenne Twist state vector, as
+described in
+.BR mtwist (3).
+The "\fBrd\fP" versions use the default global state vector;
+in general these functions should be avoided except for unimportant
+applications.
+The versions with no "\fBl\fP" after the underscore use the 32-bit
+version of the PRNG, while the "\fBl\fP" versions generate more bits
+(53 for floating-point values, 64 for integers) to increase the
+accuracy of the generated distribution at
+the expense of speed.
+.PP
+In the C++ interface, the
+.B mt_distribution
+class is derived from
+.B mt_prng
+(see
+.BR mtwist (3)),
+and provides all the functionality of that class as well as the
+extended functions for generating specific distributions.
+.PP
+With the exception of the
+.B *iuniform
+functions, all functions return a double-precision result.
+The range of the result depends on the distribution and the
+parameters.
+However, in all cases the precision of the result of non-"\fBl\fP"
+functions is limited to 32
+bits, or about 1 part in 4 billion.
+.PP
+The
+.B *iuniform
+functions generate integers selected from a uniform distribution in
+the range
+.RI [ lower ,
+.IR upper ).
+If the total range given to the non-"\fBl\fP" functions is less than
+429497, a fast but slightly
+inaccurate method is used; the bias in this case will never exceed
+.01%.
+If the range exceeds that value, a slightly slower but precise method
+is used.
+.PP
+The
+.B *liuniform
+functions also generate uniformly distributed integers, but they will
+support a range greater than 4294967295.
+The
+.B *liuniform
+functions should never be used unless a large range is required.
+.PP
+The
+.B *uniform
+functions generate double-precision numbers selected from a uniform
+distribution in the range
+.RI [ lower ,
+.IR upper ).
+This function should
+.I not
+be used to generate uniformly distributed random integers.
+Use the
+.I *iuniform
+family instead.
+.PP
+The
+.B *exponential
+functions generate an exponential distribution with the given mean.
+The
+.B *erlang
+functions generate a
+.IR p -Erlang
+distribution with the given mean.
+The
+.B *weibull
+functions generate a Weibull function with the given shape and scale
+parameters.
+.PP
+The
+.B *normal
+functions generate a normal (Gaussian) distribution with the given
+mean and a standard deviation equal to
+.IR sigma .
+The
+.B *lognormal
+functions generate a lognormal distribution with the given shape and
+scale parameters.
+.PP
+The
+.B *triangular
+functions generate a triangular distribution in the range 
+.RI [ lower ,
+.IR upper )
+and with the given mode.
+.PP
+Finally, the
+.B *empirical
+functions generate empirically determined distributions.
+The caller must supply an array of
+.I n_probs
+probabilities in
+.I probs
+and an array of
+.IR n_probs +1
+.IR values .
+The result will be
+.IR values [0]
+with probability
+.IR probs [0],
+.IR values [1]
+with probability
+.IR probs [1],
+and so forth.
+The extra value,
+.IR values [ n_probs ],
+will appear with a probability equal to 1 minus the sum of the
+preceding probabilities.
+There is little point in using the "\fBl\fP" versions of the
+.B *empirical
+functions unless you have strong evidence to the contrary.
+.SH NOTES
+.PP
+It would be helpful if the package supported even more distributions.
+Please e-mail the author (geoff@cs.hmc.edu) with suggestions for other
+distributions and algorithms for generating them.
+.PP
+The
+.B *iuniform
+functions keep internal state in an attempt to speed up their
+performance when the range is large.
+This internal state makes them non-reentrant.
+.PP
+When the range is small,
+.B *iuniform
+functions exhibit a very slight bias in favor of some values.
+This bias isn't significant for any application less demanding than
+gambling.
+To eliminate the bias, compile
+.B randistrs.c
+with
+.B RD_MAX_BIAS
+set to zero.
+.PP
+The state-saving optimization in the
+.B *iuniform
+functions doesn't help when they are called with varying ranges, even
+if a different state vector is used for each range.
+.SH "SEE ALSO"
+.BR mtwist (3)
+.PP
+Any good statistics or simulation textbook for descriptions of the
+distributions.
diff --git a/cvars/utils/mtwist/randistrs.c b/cvars/utils/mtwist/randistrs.c
new file mode 100644
index 0000000..d786a86
--- /dev/null
+++ b/cvars/utils/mtwist/randistrs.c
@@ -0,0 +1,922 @@
+#ifndef lint
+static char Rcs_Id[] =
+    "$Id: randistrs.c,v 1.1.2.1 2011/01/11 22:08:51 santhosh Exp $";
+#endif
+
+/*
+ * C library functions for generating various random distributions
+ * using the Mersenne Twist PRNG.  See the header file for full
+ * documentation.
+ *
+ * These functions were written by Geoff Kuenning, Claremont, CA.
+ *
+ * Unless otherwise specified, these algorithms are taken from Averill
+ * M. Law and W. David Kelton, "Simulation Modeling and Analysis",
+ * McGraw-Hill, 1991.
+ *
+ * IMPORTANT NOTE: By default, this code is reentrant.  If you are
+ * certain you don't need reentrancy, you can get a bit more speed by
+ * defining MT_CACHING.
+ *
+ * Copyright 2001, 2002, 2010, Geoffrey H. Kuenning, Claremont, CA.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All modifications to the source code must be clearly marked as
+ *    such.  Binary redistributions based on modified source code
+ *    must be clearly marked as modified versions in the documentation
+ *    and/or other materials provided with the distribution.
+ * 4. The name of Geoff Kuenning may not be used to endorse or promote
+ *    products derived from this software without specific prior
+ *    written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY GEOFF KUENNING AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL GEOFF KUENNING OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * $Log: randistrs.c,v $
+ * Revision 1.1.2.1  2011/01/11 22:08:51  santhosh
+ * PURPOSE: Savepoint.
+ * REVIEW REQUIRED: N/a.
+ *
+ * Revision 1.9  2010-06-24 01:53:59-07  geoff
+ * Switch to using types from stdint.h.  Make reentrancy the default.
+ *
+ * Revision 1.8  2008-07-25 16:34:01-07  geoff
+ * Fix notation for intervals in commentary.
+ *
+ * Revision 1.7  2005/05/17 21:40:10  geoff
+ * Fix a bug that caused rds_iuniform to generate off-by-one values if the
+ * lower bound was negative.
+ *
+ * Revision 1.6  2002/10/30 00:50:44  geoff
+ * Add a (BSD-style) license.  Fix all places where logs are taken so
+ * that there is no risk of unintentionally taking the log of zero.  This
+ * is a very low-probability occurrence, but it's better to have robust
+ * code.
+ *
+ * Revision 1.5  2001/06/20 09:07:57  geoff
+ * Fix a place where long long wasn't conditionalized.
+ *
+ * Revision 1.4  2001/06/19 00:41:17  geoff
+ * Add the "l" versions of all functions.  Add the MT_NO_CACHING option.
+ *
+ * Revision 1.3  2001/06/18 10:09:24  geoff
+ * Add the iuniform functions to generate unbiased uniformly distributed
+ * integers.
+ *
+ * Revision 1.2  2001/04/10 09:11:38  geoff
+ * Make sure the Erlang distribution has a p of 1 or more.  Fix a serious
+ * bug in the Erlang calculation (the value returned was completely
+ * wrong).
+ *
+ * Revision 1.1  2001/04/09 08:39:54  geoff
+ * Initial revision
+ *
+ */
+
+#include "mtwist.h"
+#include "randistrs.h"
+#include <math.h>
+
+/*
+ * Table of contents:
+ */
+int32_t			rds_iuniform(mt_state * state, int32_t lower,
+			  int32_t upper);
+					/* (Integer) uniform distribution */
+#ifdef INT64_MAX
+int64_t			rds_liuniform(mt_state * state, int64_t lower,
+			  int64_t upper);
+					/* (Integer) uniform distribution */
+#endif /* INT64_MAX */
+double			rds_uniform(mt_state * state,
+			  double lower, double upper);
+					/* (Floating) uniform distribution */
+double			rds_luniform(mt_state * state,
+			  double lower, double upper);
+					/* (Floating) uniform distribution */
+double			rds_exponential(mt_state * state, double mean);
+					/* Exponential distribution */
+double			rds_lexponential(mt_state * state, double mean);
+					/* Exponential distribution */
+double			rds_erlang(mt_state * state, int p, double mean);
+					/* p-Erlang distribution */
+double			rds_lerlang(mt_state * state, int p, double mean);
+					/* p-Erlang distribution */
+double			rds_weibull(mt_state * state,
+			  double shape, double scale);
+					/* Weibull distribution */
+double			rds_lweibull(mt_state * state,
+			  double shape, double scale);
+					/* Weibull distribution */
+double			rds_normal(mt_state * state,
+			  double mean, double sigma);
+					/* Normal distribution */
+double			rds_lnormal(mt_state * state,
+			  double mean, double sigma);
+					/* Normal distribution */
+double			rds_lognormal(mt_state * state,
+			  double shape, double scale);
+					/* Lognormal distribution */
+double			rds_llognormal(mt_state * state,
+			  double shape, double scale);
+					/* Lognormal distribution */
+double			rds_triangular(mt_state * state,
+			  double lower, double upper, double mode);
+					/* Triangular distribution */
+double			rds_ltriangular(mt_state * state,
+			  double lower, double upper, double mode);
+					/* Triangular distribution */
+double			rds_empirical(mt_state * state,
+			  int n_probs, double * values, double * probs);
+					/* Empirical distribution */
+double			rds_lempirical(mt_state * state,
+			  int n_probs, double * values, double * probs);
+					/* Empirical distribution */
+int32_t			rd_iuniform(int32_t lower, int32_t upper);
+					/* (Integer) uniform distribution */
+#ifdef INT64_MAX
+int64_t			rd_liuniform(int64_t lower, int64_t upper);
+					/* (Integer) uniform distribution */
+#endif /* INT64_MAX */
+double			rd_uniform(double lower, double upper);
+					/* (Floating) uniform distribution */
+double			rd_luniform(double lower, double upper);
+					/* (Floating) uniform distribution */
+double			rd_exponential(double mean);
+					/* Exponential distribution */
+double			rd_lexponential(double mean);
+					/* Exponential distribution */
+double			rd_erlang(int p, double mean);
+					/* p-Erlang distribution */
+double			rd_lerlang(int p, double mean);
+					/* p-Erlang distribution */
+double			rd_weibull(double shape, double scale);
+					/* Weibull distribution */
+double			rd_lweibull(double shape, double scale);
+					/* Weibull distribution */
+double			rd_normal(double mean, double sigma);
+					/* Normal distribution */
+double			rd_lnormal(double mean, double sigma);
+					/* Normal distribution */
+double			rd_lognormal(double shape, double scale);
+					/* Lognormal distribution */
+double			rd_llognormal(double shape, double scale);
+					/* Lognormal distribution */
+double			rd_triangular(double lower, double upper, double mode);
+					/* Triangular distribution */
+double			rd_ltriangular(double lower, double upper, double mode);
+					/* Triangular distribution */
+double			rd_empirical(int n_probs,
+			  double * values, double * probs);
+					/* Empirical distribution */
+double			rd_lempirical(int n_probs,
+			  double * values, double * probs);
+					/* Empirical distribution */
+
+/*
+ * The Mersenne Twist PRNG makes it default state available as an
+ * external variable.  This feature is undocumented, but is useful to
+ * use because it allows us to avoid implementing every function
+ * twice.  (In fact, the feature was added to enable this file to be
+ * written.  It would be better to write in C++, where I could control
+ * the access to the state.)
+ */
+extern mt_state		mt_default_state;
+
+/*
+ * Threshold below which it is OK for uniform integer distributions to make
+ * use of the double-precision code as a crutch.  For ranges below
+ * this value, a double-precision random value is generated and then
+ * mapped to the given range.  For a lower bound of zero, this is
+ * equivalent to mapping a 32-bit integer into the range by using the
+ * following formula:
+ *
+ *	final = upper * mt_lrand() / (1 << 32);
+ *
+ * That formula can't be computed using integer arithmetic, since the
+ * multiplication must precede the division and would cause overflow.
+ * Double-precision calculations solve that problem.  However the
+ * formula will also produce biased results unless the range ("upper")
+ * is exactly a power of 2.  To see this, suppose mt_lrand produced
+ * values from 0 to 7 (i.e., 8 values), and we asked for numbers in
+ * the range [0, 7).  The 8 values uniformly generated by mt_lrand
+ * would be mapped into the 7 output values.  Clearly, one output
+ * value (in this case, 4) would occur twice as often as the others
+ *
+ * The amount of bias introduced by this approximation depends on the
+ * relative sizes of the requested range and the range of values
+ * produced by mt_lrand.  If the ranges are almost equal, some values
+ * will occur almost twice as often as they should.  At the other
+ * extreme, consider a requested range of 3 values (0 to 2,
+ * inclusive).  If the PRNG cycles through all 2^32 possible values,
+ * two of the output values will be generated 1431655765 times and the
+ * third will appear 1431655766 times.  Clearly, the bias here is
+ * within the expected limits of randomness.
+ *
+ * The exact amount of bias depends on the relative size of the range
+ * compared to the width of the PRNG output.  In general, for an
+ * output range of r, no value will appear more than r/(2^32) extra
+ * times using the simple integer algorithm.
+ *
+ * The threshold given below will produce a bias of under 0.01%.  For
+ * values above this threshold, a slower but 100% accurate algorithm
+ * will be used.
+ */
+#ifndef RD_MAX_BIAS
+#define RD_MAX_BIAS		0.0001
+#endif /* RD_MAX_BIAS */
+#ifndef RD_UNIFORM_THRESHOLD
+#define RD_UNIFORM_THRESHOLD	((int)((double)(1u << 31) * 2.0 * RD_MAX_BIAS))
+#endif /* RD_UNIFORM_THRESHOLD */
+
+/*
+ * Generate a uniform integer distribution on the open interval
+ * [lower, upper).  See comments above about RD_UNIFORM_THRESHOLD.  If
+ * we are above the threshold, this function is relatively expensive
+ * because we may have to repeatedly draw random numbers to get a
+ * one that works.
+ */
+int32_t rds_iuniform(
+    mt_state *		state,		/* State of the MT PRNG to use */
+    int32_t		lower,		/* Lower limit of distribution */
+    int32_t		upper)		/* Upper limit of distribution */
+    {
+    uint32_t		range = upper - lower;
+					/* Range of requested distribution */
+
+    if (range <= RD_UNIFORM_THRESHOLD)
+	return lower + (int32_t)(mts_ldrand(state) * range);
+    else
+	{
+	/*
+	 * Using the simple formula would produce too much bias.
+	 * Instead, draw numbers until we get one within the range.
+	 * To save time, we first calculate a mask so that we only
+	 * look at the number of bits we actually need.  Since finding
+	 * the mask is expensive, we optionally do a bit of caching
+	 * here (note that the caching makes the code non-reentrant;
+	 * set MT_CACHING to turn on this misfeature).
+	 *
+	 * Incidentally, the astute reader will note that we use the
+	 * low-order bits of the PRNG output.  If the PRNG were linear
+	 * congruential, using the low-order bits wouuld be a major
+	 * no-no.  However, the Mersenne Twist PRNG doesn't have that
+	 * drawback.
+	 */
+#ifdef MT_CACHING
+	static uint32_t	lastrange = 0;	/* Range used last time */
+	static uint32_t	rangemask = 0;	/* Mask for range */
+#else /* MT_CACHING */
+	uint32_t	rangemask = 0;	/* Mask for range */
+#endif /* MT_CACHING */
+	register uint32_t
+			ranval;		/* Random value from mts_lrand */
+
+#ifdef MT_CACHING
+	if (range != lastrange)
+#endif /* MT_CACHING */
+	    {
+	    /*
+	     * Range is different from last time, recalculate mask.
+	     *
+	     * A few iterations could be trimmed off of the loop if we
+	     * started rangemask at the next power of 2 above
+	     * RD_UNIFORM_THRESHOLD.  However, I don't currently know
+	     * a formula for generating that value (though there is
+	     * probably one in HAKMEM).
+	     */
+#ifdef MT_CACHING
+	    lastrange = range;
+#endif /* MT_CACHING */
+	    for (rangemask = 1;
+	      rangemask < range  &&  rangemask != 0;
+	      rangemask <<= 1)
+		;
+
+	    /*
+	     * If rangemask became zero, the range is over 2^31.  In
+	     * that case, subtracting 1 from rangemask will produce a
+	     * full-word mask, which is what we need.
+	     */
+	    rangemask -= 1;
+	    }
+
+	/*
+	 * Draw random numbers until we get one in the requested range.
+	 */
+	do
+	    {
+	    ranval = mts_lrand(state) & rangemask;
+	    }
+	    while (ranval >= range);
+	return lower + ranval;
+	}
+    }
+
+#ifdef INT64_MAX
+/*
+ * Generate a uniform integer distribution on the half-open interval
+ * [lower, upper).
+ */
+int64_t rds_liuniform(
+    mt_state *		state,		/* State of the MT PRNG to use */
+    int64_t		lower,		/* Lower limit of distribution */
+    int64_t		upper)		/* Upper limit of distribution */
+    {
+    uint64_t		range = upper - lower;
+					/* Range of requested distribution */
+
+    /*
+     * Draw numbers until we get one within the range.  To save time,
+     * we first calculate a mask so that we only look at the number of
+     * bits we actually need.  Since finding the mask is expensive, we
+     * optionally do a bit of caching here.  See rds_iuniform for more
+     * information.
+     */
+#ifdef MT_CACHING
+    static uint32_t	lastrange = 0;	/* Range used last time */
+    static uint32_t	rangemask = 0;	/* Mask for range */
+#else /* MT_CACHING */
+    uint32_t		rangemask = 0;	/* Mask for range */
+#endif /* MT_CACHING */
+    register uint32_t	ranval;		/* Random value from mts_lrand */
+
+#ifdef MT_CACHING
+    if (range != lastrange)
+#endif /* MT_CACHING */
+	{
+	/*
+	 * Range is different from last time, recalculate mask.
+	 */
+#ifdef MT_CACHING
+	lastrange = range;
+#endif /* MT_CACHING */
+	for (rangemask = 1;
+	  rangemask < range  &&  rangemask != 0;
+	  rangemask <<= 1)
+	    ;
+
+	/*
+	 * If rangemask became zero, the range is over 2^31.  In
+	 * that case, subtracting 1 from rangemask will produce a
+	 * full-word mask, which is what we need.
+	 */
+	rangemask -= 1;
+	}
+
+    /*
+     * Draw random numbers until we get one in the requested range.
+     */
+    do
+	{
+	ranval = mts_llrand(state) & rangemask;
+	}
+	while (ranval >= range);
+    return lower + ranval;
+    }
+#endif /* INT64_MAX */
+
+/*
+ * Generate a uniform distribution on the half-open interval [lower, upper).
+ */
+double rds_uniform(
+    mt_state *		state,		/* State of the MT PRNG to use */
+    double		lower,		/* Lower limit of distribution */
+    double		upper)		/* Upper limit of distribution */
+    {
+    return lower + mts_drand(state) * (upper - lower);
+    }
+
+/*
+ * Generate a uniform distribution on the half-open interval [lower, upper).
+ */
+double rds_luniform(
+    mt_state *		state,		/* State of the MT PRNG to use */
+    double		lower,		/* Lower limit of distribution */
+    double		upper)		/* Upper limit of distribution */
+    {
+    return lower + mts_ldrand(state) * (upper - lower);
+    }
+
+/*
+ * Generate an exponential distribution with the given mean.
+ */
+double rds_exponential(
+    mt_state *		state,		/* State of the MT PRNG to use */
+    double		mean)		/* Mean of generated distribution */
+    {
+    double		random_value;	/* Random sample on [0,1) */
+
+    do
+	random_value = mts_drand(state);
+    while (random_value == 0.0);
+    return -mean * log(random_value);
+    }
+
+/*
+ * Generate an exponential distribution with the given mean.
+ */
+double rds_lexponential(
+    mt_state *		state,		/* State of the MT PRNG to use */
+    double		mean)		/* Mean of generated distribution */
+    {
+    double		random_value;	/* Random sample on [0,1) */
+
+    do
+	random_value = mts_ldrand(state);
+    while (random_value == 0.0);
+    return -mean * log(random_value);
+    }
+
+/*
+ * Generate a p-Erlang distribution with the given mean.
+ */
+double rds_erlang(
+    mt_state *		state,		/* State of the MT PRNG to use */
+    int			p,		/* Order of distribution to generate */
+    double		mean)		/* Mean of generated distribution */
+    {
+    int			order;		/* Order generated so far */
+    double		random_value;	/* Value generated so far */
+
+    do
+	{
+	if (p <= 1)
+	    p = 1;
+	random_value = mts_drand(state);
+	for (order = 1;  order < p;  order++)
+	    random_value *= mts_drand(state);
+	}
+    while (random_value == 0.0);
+    return -mean * log(random_value) / p;
+    }
+
+/*
+ * Generate a p-Erlang distribution with the given mean.
+ */
+double rds_lerlang(
+    mt_state *		state,		/* State of the MT PRNG to use */
+    int			p,		/* Order of distribution to generate */
+    double		mean)		/* Mean of generated distribution */
+    {
+    int			order;		/* Order generated so far */
+    double		random_value;	/* Value generated so far */
+
+    do
+	{
+	if (p <= 1)
+	    p = 1;
+	random_value = mts_ldrand(state);
+	for (order = 1;  order < p;  order++)
+	    random_value *= mts_ldrand(state);
+	}
+    while (random_value == 0.0);
+    return -mean * log(random_value) / p;
+    }
+
+/*
+ * Generate a Weibull distribution with the given shape and scale parameters.
+ */
+double rds_weibull(
+    mt_state *		state,		/* State of the MT PRNG to use */
+    double		shape,		/* Shape of the distribution */
+    double		scale)		/* Scale of the distribution */
+    {
+    double		random_value;	/* Random sample on [0,1) */
+
+    do
+	random_value = mts_drand(state);
+    while (random_value == 0.0);
+    return scale * exp(log(-log(random_value)) / shape);
+    }
+					/* Weibull distribution */
+/*
+ * Generate a Weibull distribution with the given shape and scale parameters.
+ */
+double rds_lweibull(
+    mt_state *		state,		/* State of the MT PRNG to use */
+    double		shape,		/* Shape of the distribution */
+    double		scale)		/* Scale of the distribution */
+    {
+    double		random_value;	/* Random sample on [0,1) */
+
+    do
+	random_value = mts_ldrand(state);
+    while (random_value == 0.0);
+    return scale * exp(log(-log(random_value)) / shape);
+    }
+					/* Weibull distribution */
+/*
+ * Generate a normal distribution with the given mean and standard
+ * deviation.  See Law and Kelton, p. 491.
+ */
+double rds_normal(
+    mt_state *		state,		/* State of the MT PRNG to use */
+    double		mean,		/* Mean of generated distribution */
+    double		sigma)		/* Standard deviation to generate */
+    {
+    double		mag;		/* Magnitude of (x,y) point */
+    double		offset;		/* Unscaled offset from mean */
+    double		xranval;	/* First random value on [-1,1) */
+    double		yranval;	/* Second random value on [-1,1) */
+
+    /*
+     * Generating a normal distribution is a bit tricky.  We may need
+     * to make several attempts before we get a valid result.  When we
+     * are done, we will have two normally distributed values, one of
+     * which we discard.
+     */
+    do
+	{
+	xranval = 2.0 * mts_drand(state) - 1.0;
+	yranval = 2.0 * mts_drand(state) - 1.0;
+	mag = xranval * xranval + yranval * yranval;
+	}
+    while (mag > 1.0  ||  mag == 0.0);
+
+    offset = sqrt((-2.0 * log(mag)) / mag);
+    return mean + sigma * xranval * offset;
+
+    /*
+     * The second random variate is given by:
+     *
+     *     mean + sigma * yranval * offset;
+     *
+     * If this were a C++ function, it could probably save that value
+     * somewhere and return it in the next subsequent call.  But
+     * that's too hard to make bulletproof (and reentrant) in C.
+     */
+    }
+
+/*
+ * Generate a normal distribution with the given mean and standard
+ * deviation.  See Law and Kelton, p. 491.
+ */
+double rds_lnormal(
+    mt_state *		state,		/* State of the MT PRNG to use */
+    double		mean,		/* Mean of generated distribution */
+    double		sigma)		/* Standard deviation to generate */
+    {
+    double		mag;		/* Magnitude of (x,y) point */
+    double		offset;		/* Unscaled offset from mean */
+    double		xranval;	/* First random value on [-1,1) */
+    double		yranval;	/* Second random value on [-1,1) */
+
+    /*
+     * Generating a normal distribution is a bit tricky.  We may need
+     * to make several attempts before we get a valid result.  When we
+     * are done, we will have two normally distributed values, one of
+     * which we discard.
+     */
+    do
+	{
+	xranval = 2.0 * mts_ldrand(state) - 1.0;
+	yranval = 2.0 * mts_ldrand(state) - 1.0;
+	mag = xranval * xranval + yranval * yranval;
+	}
+    while (mag > 1.0  ||  mag == 0.0);
+
+    offset = sqrt((-2.0 * log(mag)) / mag);
+    return mean + sigma * xranval * offset;
+
+    /*
+     * The second random variate is given by:
+     *
+     *     mean + sigma * yranval * offset;
+     *
+     * If this were a C++ function, it could probably save that value
+     * somewhere and return it in the next subsequent call.  But
+     * that's too hard to make bulletproof (and reentrant) in C.
+     */
+    }
+
+/*
+ * Generate a lognormal distribution with the given shape and scale
+ * parameters.
+ */
+double rds_lognormal(
+    mt_state *		state,		/* State of the MT PRNG to use */
+    double		shape,		/* Shape of the distribution */
+    double		scale)		/* Scale of the distribution */
+    {
+    return exp(rds_normal(state, scale, shape));
+    }
+
+/*
+ * Generate a lognormal distribution with the given shape and scale
+ * parameters.
+ */
+double rds_llognormal(
+    mt_state *		state,		/* State of the MT PRNG to use */
+    double		shape,		/* Shape of the distribution */
+    double		scale)		/* Scale of the distribution */
+    {
+    return exp(rds_lnormal(state, scale, shape));
+    }
+
+/*
+ * Generate a triangular distibution between given limits, with a
+ * given mode.
+ */
+double rds_triangular(
+    mt_state *		state,		/* State of the MT PRNG to use */
+    double		lower,		/* Lower limit of distribution */
+    double		upper,		/* Upper limit of distribution */
+    double		mode)		/* Highest point of distribution */
+    {
+    double		ran_value;	/* Value generated by PRNG */
+    double		scaled_mode;	/* Scaled version of mode */
+
+    scaled_mode = (mode - lower) / (upper - lower);
+    ran_value = mts_drand(state);
+    if (ran_value <= scaled_mode)
+	ran_value = sqrt(scaled_mode * ran_value);
+    else
+	ran_value = 1.0 - sqrt((1.0 - scaled_mode) * (1.0 - ran_value));
+    return lower + (upper - lower) * ran_value;
+    }
+
+/*
+ * Generate a triangular distibution between given limits, with a
+ * given mode.
+ */
+double rds_ltriangular(
+    mt_state *		state,		/* State of the MT PRNG to use */
+    double		lower,		/* Lower limit of distribution */
+    double		upper,		/* Upper limit of distribution */
+    double		mode)		/* Highest point of distribution */
+    {
+    double		ran_value;	/* Value generated by PRNG */
+    double		scaled_mode;	/* Scaled version of mode */
+
+    scaled_mode = (mode - lower) / (upper - lower);
+    ran_value = mts_ldrand(state);
+    if (ran_value <= scaled_mode)
+	ran_value = sqrt(scaled_mode * ran_value);
+    else
+	ran_value = 1.0 - sqrt((1.0 - scaled_mode) * (1.0 - ran_value));
+    return lower + (upper - lower) * ran_value;
+    }
+
+/*
+ * Generate an empirical distribution given a set of values and their
+ * probabilities.
+ */
+double rds_empirical(
+    mt_state *		state,		/* State of the MT PRNG to use */
+    int			n_probs,	/* Number of probabilities given */
+    double *		values,		/* Vals returned with various probs */
+    double *		probs)		/* Probs of various values */
+    {
+    int			i;		/* Index into both arrays */
+    double		ran_value;	/* Value generated by PRNG */
+
+    ran_value = mts_drand(state);
+    /*
+     * NEEDSWORK: This should be a binary search if n_probs is
+     * moderately large (e.g., more than about 5-7).
+     */
+    for (i = 0;  i < n_probs;  i++)
+	{
+	if (ran_value <= probs[i])
+	    return values[i];
+	}
+    return values[n_probs];
+    }
+
+/*
+ * Generate an empirical distribution given a set of values and their
+ * probabilities.
+ */
+double rds_lempirical(
+    mt_state *		state,		/* State of the MT PRNG to use */
+    int			n_probs,	/* Number of probabilities given */
+    double *		values,		/* Vals returned with various probs */
+    double *		probs)		/* Probs of various values */
+    {
+    int			i;		/* Index into both arrays */
+    double		ran_value;	/* Value generated by PRNG */
+
+    ran_value = mts_ldrand(state);
+    /*
+     * NEEDSWORK: This should be a binary search if n_probs is
+     * moderately large (e.g., more than about 5-7).
+     */
+    for (i = 0;  i < n_probs;  i++)
+	{
+	if (ran_value <= probs[i])
+	    return values[i];
+	}
+    return values[n_probs];
+    }
+
+/*
+ * Generate a uniform integer distribution on the half-open interval
+ * [lower, upper).  See comments on rds_iuniform.
+ */
+int32_t rd_iuniform(
+    int32_t		lower,		/* Lower limit of distribution */
+    int32_t		upper)		/* Upper limit of distribution */
+    {
+    return rds_iuniform(&mt_default_state, lower, upper);
+    }
+
+#ifdef INT64_MAX
+/*
+ * Generate a uniform integer distribution on the open interval
+ * [lower, upper).  See comments on rds_iuniform.
+ */
+int64_t rd_liuniform(
+    int64_t		lower,		/* Lower limit of distribution */
+    int64_t		upper)		/* Upper limit of distribution */
+    {
+    return rds_liuniform(&mt_default_state, lower, upper);
+    }
+#endif /* INT64_MAX */
+
+/*
+ * Generate a uniform distribution on the open interval [lower, upper).
+ */
+double rd_uniform(
+    double		lower,		/* Lower limit of distribution */
+    double		upper)		/* Upper limit of distribution */
+    {
+    return rds_uniform (&mt_default_state, lower, upper);
+    }
+
+/*
+ * Generate a uniform distribution on the open interval [lower, upper).
+ */
+double rd_luniform(
+    double		lower,		/* Lower limit of distribution */
+    double		upper)		/* Upper limit of distribution */
+    {
+    return rds_luniform (&mt_default_state, lower, upper);
+    }
+
+/*
+ * Generate an exponential distribution with the given mean.
+ */
+double rd_exponential(
+    double		mean)		/* Mean of generated distribution */
+    {
+    return rds_exponential (&mt_default_state, mean);
+    }
+
+/*
+ * Generate an exponential distribution with the given mean.
+ */
+double rd_lexponential(
+    double		mean)		/* Mean of generated distribution */
+    {
+    return rds_lexponential (&mt_default_state, mean);
+    }
+
+/*
+ * Generate a p-Erlang distribution with the given mean.
+ */
+double rd_erlang(
+    int			p,		/* Order of distribution to generate */
+    double		mean)		/* Mean of generated distribution */
+    {
+    return rds_erlang (&mt_default_state, p, mean);
+    }
+
+/*
+ * Generate a p-Erlang distribution with the given mean.
+ */
+double rd_lerlang(
+    int			p,		/* Order of distribution to generate */
+    double		mean)		/* Mean of generated distribution */
+    {
+    return rds_lerlang (&mt_default_state, p, mean);
+    }
+
+/*
+ * Generate a Weibull distribution with the given shape and scale parameters.
+ */
+double rd_weibull(
+    double		shape,		/* Shape of the distribution */
+    double		scale)		/* Scale of the distribution */
+    {
+    return rds_weibull (&mt_default_state, shape, scale);
+    }
+
+/*
+ * Generate a Weibull distribution with the given shape and scale parameters.
+ */
+double rd_lweibull(
+    double		shape,		/* Shape of the distribution */
+    double		scale)		/* Scale of the distribution */
+    {
+    return rds_lweibull (&mt_default_state, shape, scale);
+    }
+
+/*
+ * Generate a normal distribution with the given mean and standard
+ * deviation.  See Law and Kelton, p. 491.
+ */
+double rd_normal(
+    double		mean,		/* Mean of generated distribution */
+    double		sigma)		/* Standard deviation to generate */
+    {
+    return rds_normal (&mt_default_state, mean, sigma);
+    }
+
+/*
+ * Generate a normal distribution with the given mean and standard
+ * deviation.  See Law and Kelton, p. 491.
+ */
+double rd_lnormal(
+    double		mean,		/* Mean of generated distribution */
+    double		sigma)		/* Standard deviation to generate */
+    {
+    return rds_lnormal (&mt_default_state, mean, sigma);
+    }
+
+/*
+ * Generate a lognormal distribution with the given shape and scale
+ * parameters.
+ */
+double rd_lognormal(
+    double		shape,		/* Shape of the distribution */
+    double		scale)		/* Scale of the distribution */
+    {
+    return rds_lognormal (&mt_default_state, shape, scale);
+    }
+
+/*
+ * Generate a lognormal distribution with the given shape and scale
+ * parameters.
+ */
+double rd_llognormal(
+    double		shape,		/* Shape of the distribution */
+    double		scale)		/* Scale of the distribution */
+    {
+    return rds_llognormal (&mt_default_state, shape, scale);
+    }
+
+/*
+ * Generate a triangular distibution between given limits, with a
+ * given mode.
+ */
+double rd_triangular(
+    double		lower,		/* Lower limit of distribution */
+    double		upper,		/* Upper limit of distribution */
+    double		mode)
+    {
+    return rds_triangular (&mt_default_state, lower, upper, mode);
+    }
+
+/*
+ * Generate a triangular distibution between given limits, with a
+ * given mode.
+ */
+double rd_ltriangular(
+    double		lower,		/* Lower limit of distribution */
+    double		upper,		/* Upper limit of distribution */
+    double		mode)
+    {
+    return rds_ltriangular (&mt_default_state, lower, upper, mode);
+    }
+
+/*
+ * Generate an empirical distribution given a set of values and their
+ * probabilities.
+ */
+double rd_empirical(
+    int			n_probs,	/* Number of probabilities given */
+    double *		values,		/* Vals returned with various probs */
+    double *		probs)		/* Probs of various values */
+    {
+    return rds_empirical (&mt_default_state, n_probs, values, probs);
+    }
+
+/*
+ * Generate an empirical distribution given a set of values and their
+ * probabilities.
+ */
+double rd_lempirical(
+    int			n_probs,	/* Number of probabilities given */
+    double *		values,		/* Vals returned with various probs */
+    double *		probs)		/* Probs of various values */
+    {
+    return rds_lempirical (&mt_default_state, n_probs, values, probs);
+    }
diff --git a/cvars/utils/mtwist/randistrs.h b/cvars/utils/mtwist/randistrs.h
new file mode 100644
index 0000000..6bc958b
--- /dev/null
+++ b/cvars/utils/mtwist/randistrs.h
@@ -0,0 +1,392 @@
+#ifndef RANDISTRS_H
+#define RANDISTRS_H
+
+/*
+ * $Id: randistrs.h,v 1.1.2.1 2011/01/11 22:08:51 santhosh Exp $
+ *
+ * Header file for C/C++ use of a generalized package that generates
+ * random numbers in various distributions, using the Mersenne-Twist
+ * pseudo-RNG.  See mtwist.h and mtwist.c for documentation on the PRNG.
+ *
+ * Author of this header file: Geoff Kuenning, April 7, 2001.
+ *
+ * All of the functions provided by this package have three variants.
+ * The rd_xxx versions use the default state vector provided by the MT
+ * package.  The rds_xxx versions use a state vector provided by the
+ * caller.  In general, the rds_xxx versions are preferred for serious
+ * applications, since they allow random numbers used for different
+ * purposes to be drawn from independent, uncorrelated streams.
+ * Finally, the C++ interface provides a class "mt_distribution",
+ * derived from mt_prng, with no-prefix ("xxx") versions of each
+ * function.
+ *
+ * The summary below will describe only the rds_xxx functions.  The
+ * rd_xxx functions have identical specifications, except that the
+ * "state" argument is omitted.  In all cases, the "state" argument
+ * has type mt_state, and must have been initialized either by calling
+ * one of the Mersenne Twist seeding functions, or by being set to all
+ * zeros.
+ *
+ * The "l" version of each function calls the 64-bit version of the
+ * PRNG instead of the 32-bit version.  In general, you shouldn't use
+ * those functions unless your application is *very* sensitive to tiny
+ * variations in the probability distribution.  This is especially
+ * true of the uniform and empirical distributions.
+ *
+ * Random-distribution functions:
+ *
+ * rds_iuniform(mt_state* state, long lower, long upper)
+ *		(Integer) uniform on the half-open interval [lower, upper).
+ * rds_liuniform(mt_state* state, long long lower, long long upper)
+ *		(Integer) uniform on the half-open interval [lower, upper).
+ *		Don't use unless you need numbers bigger than a long!
+ * rds_uniform(mt_state* state, double lower, double upper)
+ *		(Floating) uniform on the half-open interval [lower, upper).
+ * rds_luniform(mt_state* state, double lower, double upper)
+ *		(Floating) uniform on the half-open interval [lower, upper).
+ *		Higher precision but slower than rds_uniform.
+ * rds_exponential(mt_state* state, double mean)
+ *		Exponential with the given mean.
+ * rds_lexponential(mt_state* state, double mean)
+ *		Exponential with the given mean.
+ *		Higher precision but slower than rds_exponential.
+ * rds_erlang(mt_state* state, int p, double mean)
+ *		p-Erlang with the given mean.
+ * rds_lerlang(mt_state* state, int p, double mean)
+ *		p-Erlang with the given mean.
+ *		Higher precision but slower than rds_erlang.
+ * rds_weibull(mt_state* state, double shape, double scale)
+ *		Weibull with the given shape and scale parameters.
+ * rds_lweibull(mt_state* state, double shape, double scale)
+ *		Weibull with the given shape and scale parameters.
+ *		Higher precision but slower than rds_weibull.
+ * rds_normal(mt_state* state, double mean, double sigma)
+ *		Normal with the  given mean and standard deviation.
+ * rds_lnormal(mt_state* state, double mean, double sigma)
+ *		Normal with the  given mean and standard deviation.
+ *		Higher precision but slower than rds_normal.
+ * rds_lognormal(mt_state* state, double shape, double scale)
+ *		Lognormal with the given shape and scale parameters.
+ * rds_llognormal(mt_state* state, double shape, double scale)
+ *		Lognormal with the given shape and scale parameters.
+ *		Higher precision but slower than rds_lognormal.
+ * rds_triangular(mt_state* state, double lower, double upper, double mode)
+ *		Triangular on the closed interval (lower, upper) with
+ *		the given mode.
+ * rds_ltriangular(mt_state* state, double lower, double upper, double mode)
+ *		Triangular on the closed interval (lower, upper) with
+ *		the given mode.
+ *		Higher precision but slower than rds_triangular.
+ * rds_empirical(mt_state* state, int n_probs, double* values, double* probs)
+ *		values[0] with probability probs[0], values[1] with
+ *		probability probs[1] - probs[0], etc.; values[n_probs]
+ *		with probability 1-probs[n_probs-1].  Note that there
+ *		is one more value than there are probabilities.  It is
+ *		the caller's responsibility to make sure that the
+ *		probabilities are monotonically increasing and that
+ *		their sum is less than or equal to 1; if this
+ *		condition is violated, some of the values will never
+ *		be generated.
+ * rds_lempirical(mt_state* state, int n_probs, double* values, double* probs)
+ *		Empirical distribution.  Higher precision but slower than
+ *		rds_empirical.
+ * rd_iuniform(long lower, long upper)
+ * rd_liuniform(long long lower, long long upper)
+ *		As above, using the default MT-PRNG.
+ * rd_uniform(double lower, double upper)
+ * rd_luniform(double lower, double upper)
+ *		As above, using the default MT-PRNG.
+ * rd_exponential(double mean)
+ * rd_lexponential(double mean)
+ *		As above, using the default MT-PRNG.
+ * rd_erlang(int p, double mean)
+ * rd_lerlang(int p, double mean)
+ *		As above, using the default MT-PRNG.
+ * rd_weibull(double shape, double scale)
+ * rd_lweibull(double shape, double scale)
+ *		As above, using the default MT-PRNG.
+ * rd_normal(double mean, double sigma)
+ * rd_lnormal(double mean, double sigma)
+ *		As above, using the default MT-PRNG.
+ * rd_lognormal(double shape, double scale)
+ * rd_llognormal(double shape, double scale)
+ *		As above, using the default MT-PRNG.
+ * rd_triangular(double lower, double upper, double mode)
+ * rd_ltriangular(double lower, double upper, double mode)
+ *		As above, using the default MT-PRNG.
+ * rd_empirical(int n_probs, double* values, double* probs)
+ * rd_lempirical(int n_probs, double* values, double* probs)
+ *		As above, using the default MT-PRNG.
+ *
+ * $Log: randistrs.h,v $
+ * Revision 1.1.2.1  2011/01/11 22:08:51  santhosh
+ * PURPOSE: Savepoint.
+ * REVIEW REQUIRED: N/a.
+ *
+ * Revision 1.6  2010-06-24 01:53:59-07  geoff
+ * Switch to using types from stdint.h.
+ *
+ * Revision 1.5  2008-07-25 16:34:01-07  geoff
+ * Fix notation for intervals in commentary.
+ *
+ * Revision 1.4  2001/06/20 09:07:58  geoff
+ * Fix a place where long long wasn't conditionalized.
+ *
+ * Revision 1.3  2001/06/19 00:41:17  geoff
+ * Add the "l" versions of all functions.
+ *
+ * Revision 1.2  2001/06/18 10:09:24  geoff
+ * Add the iuniform functions.  Improve the header comments.  Add a C++
+ * interface.  Clean up some stylistic inconsistencies.
+ *
+ * Revision 1.1  2001/04/09 08:39:54  geoff
+ * Initial revision
+ *
+ */
+
+#include "mtwist.h"
+
+#ifdef __cplusplus
+extern "C"
+    {
+#endif
+
+/*
+ * Functions that use a provided state.
+ */
+extern int32_t		rds_iuniform(mt_state* state, int32_t lower,
+			  int32_t upper);
+					/* (Integer) uniform distribution */
+#ifdef INT64_MAX
+extern int64_t		rds_liuniform(mt_state* state, int64_t lower,
+			  int64_t upper);
+					/* (Integer) uniform distribution */
+#endif /* INT64_MAX */
+extern double		rds_uniform(mt_state* state,
+			  double lower, double upper);
+					/* (Floating) uniform distribution */
+extern double		rds_luniform(mt_state* state,
+			  double lower, double upper);
+					/* (Floating) uniform distribution */
+extern double		rds_exponential(mt_state* state, double mean);
+					/* Exponential distribution */
+extern double		rds_lexponential(mt_state* state, double mean);
+					/* Exponential distribution */
+extern double		rds_erlang(mt_state* state, int p, double mean);
+					/* p-Erlang distribution */
+extern double		rds_lerlang(mt_state* state, int p, double mean);
+					/* p-Erlang distribution */
+extern double		rds_weibull(mt_state* state,
+			  double shape, double scale);
+					/* Weibull distribution */
+extern double		rds_lweibull(mt_state* state,
+			  double shape, double scale);
+					/* Weibull distribution */
+extern double		rds_normal(mt_state* state,
+			  double mean, double sigma);
+					/* Normal distribution */
+extern double		rds_lnormal(mt_state* state,
+			  double mean, double sigma);
+					/* Normal distribution */
+extern double		rds_lognormal(mt_state* state,
+			  double shape, double scale);
+					/* Lognormal distribution */
+extern double		rds_llognormal(mt_state* state,
+			  double shape, double scale);
+					/* Lognormal distribution */
+extern double		rds_triangular(mt_state* state,
+			  double lower, double upper, double mode);
+					/* Triangular distribution */
+extern double		rds_ltriangular(mt_state* state,
+			  double lower, double upper, double mode);
+					/* Triangular distribution */
+extern double		rds_empirical(mt_state* state,
+			  int n_probs, double* values, double* probs);
+					/* Empirical distribution */
+extern double		rds_lempirical(mt_state* state,
+			  int n_probs, double* values, double* probs);
+					/* Empirical distribution */
+
+/*
+ * Functions that use the default state of the PRNG.
+ */
+extern int32_t		rd_iuniform(int32_t lower, int32_t upper);
+					/* (Integer) uniform distribution */
+#ifdef INT64_MAX
+extern int64_t		rd_liuniform(int64_t lower, int64_t upper);
+					/* (Integer) uniform distribution */
+#endif /* INT64_MAX */
+extern double		rd_uniform(double lower, double upper);
+					/* (Floating) uniform distribution */
+extern double		rd_luniform(double lower, double upper);
+					/* (Floating) uniform distribution */
+extern double		rd_exponential(double mean);
+					/* Exponential distribution */
+extern double		rd_lexponential(double mean);
+					/* Exponential distribution */
+extern double		rd_erlang(int p, double mean);
+					/* p-Erlang distribution */
+extern double		rd_lerlang(int p, double mean);
+					/* p-Erlang distribution */
+extern double		rd_weibull(double shape, double scale);
+					/* Weibull distribution */
+extern double		rd_lweibull(double shape, double scale);
+					/* Weibull distribution */
+extern double		rd_normal(double mean, double sigma);
+					/* Normal distribution */
+extern double		rd_lnormal(double mean, double sigma);
+					/* Normal distribution */
+extern double		rd_lognormal(double shape, double scale);
+					/* Lognormal distribution */
+extern double		rd_llognormal(double shape, double scale);
+					/* Lognormal distribution */
+extern double		rd_triangular(double lower, double upper, double mode);
+					/* Triangular distribution */
+extern double		rd_ltriangular(double lower, double upper,
+			  double mode);	/* Triangular distribution */
+extern double		rd_empirical(int n_probs,
+			  double* values, double* probs);
+					/* Empirical distribution */
+extern double		rd_lempirical(int n_probs,
+			  double* values, double* probs);
+					/* Empirical distribution */
+
+#ifdef __cplusplus
+    }
+#endif
+
+#ifdef __cplusplus
+/*
+ * C++ interface to the random-distribution generators.  This class is
+ * little more than a wrapper for the C functions, but it fits a bit
+ * more nicely with the mt_prng class.
+ */
+class mt_distribution : public mt_prng
+    {
+    public:
+	/*
+	 * Constructors and destructors.  All constructors and
+	 * destructors are the same as for mt_prng.
+	 */
+			mt_distribution(
+					// Default constructor
+			    bool pickSeed = false)
+					// True to get seed from /dev/urandom
+					// ..or time
+			    : mt_prng(pickSeed)
+			    {
+			    }
+			mt_distribution(uint32_t seed)
+					// Construct with 32-bit seeding
+			    : mt_prng(seed)
+			    {
+			    }
+			mt_distribution(uint32_t seeds[MT_STATE_SIZE])
+					// Construct with full seeding
+			    : mt_prng(seeds)
+			    {
+			    }
+			~mt_distribution() { }
+
+	/*
+	 * Functions for generating distributions.  These simply
+	 * invoke the C functions above.
+	 */
+	int32_t		iuniform(int32_t lower, int32_t upper)
+					/* Uniform distribution */
+			    {
+			    return rds_iuniform(&state, lower, upper);
+			    }
+#ifdef INT64_MAX
+	int64_t	liuniform(int64_t lower, int64_t upper)
+					/* Uniform distribution */
+			    {
+			    return rds_liuniform(&state, lower, upper);
+			    }
+#endif /* INT64_MAX */
+	double		uniform(double lower, double upper)
+					/* Uniform distribution */
+			    {
+			    return rds_uniform(&state, lower, upper);
+			    }
+	double		luniform(double lower, double upper)
+					/* Uniform distribution */
+			    {
+			    return rds_luniform(&state, lower, upper);
+			    }
+	double		exponential(double mean)
+					/* Exponential distribution */
+			    {
+			    return rds_exponential(&state, mean);
+			    }
+	double		lexponential(double mean)
+					/* Exponential distribution */
+			    {
+			    return rds_lexponential(&state, mean);
+			    }
+	double		erlang(int p, double mean)
+					/* p-Erlang distribution */
+			    {
+			    return rds_erlang(&state, p, mean);
+			    }
+	double		lerlang(int p, double mean)
+					/* p-Erlang distribution */
+			    {
+			    return rds_lerlang(&state, p, mean);
+			    }
+	double		weibull(double shape, double scale)
+					/* Weibull distribution */
+			    {
+			    return rds_weibull(&state, shape, scale);
+			    }
+	double		lweibull(double shape, double scale)
+					/* Weibull distribution */
+			    {
+			    return rds_lweibull(&state, shape, scale);
+			    }
+	double		normal(double mean, double sigma)
+					/* Normal distribution */
+			    {
+			    return rds_normal(&state, mean, sigma);
+			    }
+	double		lnormal(double mean, double sigma)
+					/* Normal distribution */
+			    {
+			    return rds_lnormal(&state, mean, sigma);
+			    }
+	double		lognormal(double shape, double scale)
+					/* Lognormal distribution */
+			    {
+			    return rds_lognormal(&state, shape, scale);
+			    }
+	double		llognormal(double shape, double scale)
+					/* Lognormal distribution */
+			    {
+			    return rds_llognormal(&state, shape, scale);
+			    }
+	double		triangular(double lower, double upper, double mode)
+					/* Triangular distribution */
+			    {
+			    return rds_triangular(&state, lower, upper, mode);
+			    }
+	double		ltriangular(double lower, double upper, double mode)
+					/* Triangular distribution */
+			    {
+			    return rds_ltriangular(&state, lower, upper, mode);
+			    }
+	double		empirical(int n_probs, double* values, double* probs)
+					/* Empirical distribution */
+			    {
+			    return
+			      rds_empirical(&state, n_probs, values, probs);
+			    }
+	double		lempirical(int n_probs, double* values, double* probs)
+					/* Empirical distribution */
+			    {
+			    return
+			      rds_lempirical(&state, n_probs, values, probs);
+			    }
+    };
+#endif
+
+#endif /* RANDISTRS_H */
diff --git a/cvars/utils/test/.cvsignore b/cvars/utils/test/.cvsignore
new file mode 100644
index 0000000..cd4280d
--- /dev/null
+++ b/cvars/utils/test/.cvsignore
@@ -0,0 +1 @@
+sanity
diff --git a/cvars/utils/test/Makefile b/cvars/utils/test/Makefile
new file mode 100644
index 0000000..5d493b2
--- /dev/null
+++ b/cvars/utils/test/Makefile
@@ -0,0 +1,12 @@
+CC=gcc
+CFLAGS=-g -O0 -Wall
+
+.PHONEY : all
+all : sanity
+
+sanity : ../../../fb_cvar.h sanity.c
+	${CC} ${CFLAGS} -I../../../ -ldl -o sanity sanity.c
+
+.PHONEY : clean
+clean : 
+	rm -f sanity
diff --git a/cvars/utils/test/sanity.c b/cvars/utils/test/sanity.c
new file mode 100644
index 0000000..6c4f725
--- /dev/null
+++ b/cvars/utils/test/sanity.c
@@ -0,0 +1,162 @@
+/*
+ * sanity.c
+ *
+ * Sanity checker for custom libraries.
+ *
+ * Author: Santhosh Kumar Koundinya (santhosh@fsl.cs.sunysb.edu)
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <dlfcn.h>
+#include <stdint.h>
+#include <fb_cvar.h>
+
+char *pgmname;
+
+void print_usage()
+{
+	printf("Usage:   %s <library name> <parameter string> "
+			"<count>\n", pgmname);
+	printf("Example: %s librand-triangular.so.1 "
+			"'lower:1024;upper:4096;mode:4096'"
+			" 10\n", pgmname);
+	return;
+}
+
+int main(int argc, char *argv[])
+{
+	void *cvar_lib;
+	void *cvar_handle;
+	char *libname;
+	char *parameters;
+	int count;
+	int ret;
+	cvar_operations_t cvar_op;
+	double d;
+
+	/* Set the global program name. */
+	pgmname = argv[0];
+
+	if (argc < 4) {
+		printf("Insufficient parameters.\n");
+		print_usage();
+		ret = -1;
+		goto exit;
+	}
+
+	/* Load the library. */
+	libname = argv[1];
+	cvar_lib = dlopen(libname, RTLD_NOW | RTLD_GLOBAL);
+	if (!cvar_lib) {
+		printf("Unable to load library: %s.\n", dlerror());
+		ret = -2;
+		goto exit;
+	}
+
+	/* Initialize the function pointers. */
+	cvar_op.cvar_module_init = dlsym(cvar_lib, FB_CVAR_MODULE_INIT);
+
+	cvar_op.cvar_alloc_handle = dlsym(cvar_lib, FB_CVAR_ALLOC_HANDLE);
+	if (!cvar_op.cvar_alloc_handle) {
+		printf("Unable to find " FB_CVAR_ALLOC_HANDLE ": %s.\n", dlerror());
+		ret = -3;
+		goto dlclose;
+	}
+
+	cvar_op.cvar_revalidate_handle = dlsym(cvar_lib, FB_CVAR_REVALIDATE_HANDLE);
+	if (!cvar_op.cvar_revalidate_handle) {
+		printf("Unable to find " FB_CVAR_ALLOC_HANDLE ": %s.\n", dlerror());
+		ret = -4;
+		goto dlclose;
+	}
+
+	cvar_op.cvar_next_value = dlsym(cvar_lib, FB_CVAR_NEXT_VALUE);
+	if (!cvar_op.cvar_next_value) {
+		printf("Unable to find " FB_CVAR_NEXT_VALUE ": %s.\n", dlerror());
+		ret = -5;
+		goto dlclose;
+	}
+
+	cvar_op.cvar_free_handle = dlsym(cvar_lib, FB_CVAR_FREE_HANDLE);
+	if (!cvar_op.cvar_free_handle) {
+		printf("Unable to find " FB_CVAR_FREE_HANDLE ": %s.\n", dlerror());
+		ret = -6;
+		goto dlclose;
+	}
+
+	cvar_op.cvar_module_exit = dlsym(cvar_lib, FB_CVAR_MODULE_EXIT);
+
+	cvar_op.cvar_usage = dlsym(cvar_lib, FB_CVAR_USAGE);
+
+	cvar_op.cvar_version = dlsym(cvar_lib, FB_CVAR_VERSION);
+
+	if (cvar_op.cvar_module_init) {
+		ret = cvar_op.cvar_module_init();
+		if (ret) {
+			printf("Custom variable module initialization failed.\n");
+			goto dlclose;
+		}
+	}
+
+	if (cvar_op.cvar_version)
+		printf("Variable: %s (%s)\n", libname, cvar_op.cvar_version());
+	else
+		printf("Variable: %s\n", libname);
+
+	if (cvar_op.cvar_usage)
+		printf("%s\n", cvar_op.cvar_usage());
+
+	/* Allocate a new custom variable handle */
+	parameters = argv[2];
+	cvar_handle = cvar_op.cvar_alloc_handle(parameters, malloc, free);
+	if (!cvar_handle) {
+		printf("Custom variable handle allocation failed.\n");
+		ret = -7;
+		goto cvar_free;
+	}
+
+	/* Try revalidating the handle. */
+	ret = cvar_op.cvar_revalidate_handle(cvar_handle);
+	if (ret) {
+		printf("Custom variable handle revalidation failed.\n");
+		ret = -10;
+		goto cvar_free;
+	}
+
+	count = atoi(argv[3]);
+	if (count > 0) {
+		while (count > 1) {
+			ret = cvar_op.cvar_next_value(cvar_handle, &d);
+			if (ret) {
+				printf("Unable to get the next value. Error %d.\n" ,ret);
+				ret = -11;
+				goto cvar_free;
+			}
+			printf("%lf,", d);
+			count--;
+		}
+		ret = cvar_op.cvar_next_value(cvar_handle, &d);
+		if (ret) {
+			printf("Unable to get the next value. Error %d.\n" ,ret);
+			ret = -11;
+			goto cvar_free;
+		}
+		printf("%lf.\n", d);
+	}
+
+	ret = 0;
+	printf("\nAll done.\n");
+
+cvar_free:
+	cvar_op.cvar_free_handle(cvar_handle, free);
+
+	if (cvar_op.cvar_module_exit)
+		cvar_op.cvar_module_exit();
+
+dlclose:
+	dlclose(cvar_lib);
+
+exit:
+	return ret;
+}
diff --git a/cvars/utils/tokens/Makefile b/cvars/utils/tokens/Makefile
new file mode 100644
index 0000000..8a538a6
--- /dev/null
+++ b/cvars/utils/tokens/Makefile
@@ -0,0 +1,13 @@
+CC=gcc
+CFLAGS=-g -O3 -c -Wall -Werror -fPIC
+
+.PHONEY : all
+all : cvar_tokens
+
+cvar_tokens : cvar_tokens.h ../cvar_trace.h cvar_tokens.c
+	${CC} ${CFLAGS} -I.. cvar_tokens.c
+	
+.PHONEY : clean
+clean : 
+	rm -f cvar_tokens.o
+ 
\ No newline at end of file
diff --git a/cvars/utils/tokens/cvar_tokens.c b/cvars/utils/tokens/cvar_tokens.c
new file mode 100644
index 0000000..35959b1
--- /dev/null
+++ b/cvars/utils/tokens/cvar_tokens.c
@@ -0,0 +1,189 @@
+/*
+ * cvar_tokens.c
+ *
+ * Simple utilities to manipulate tokens.
+ *
+ * Author: Santhosh Kumar Koundinya (santhosh@fsl.cs.sunysb.edu)
+ */
+
+#include <stdio.h>
+#include <string.h>
+#include <cvar_trace.h>
+#include "cvar_tokens.h"
+
+/*
+ * Return 0 if tokenization was successful, non-zero otherwise. This function
+ * does not use strtok (or strtok_r) as we need to point out empty keys.
+ */
+
+int tokenize(const char *parameters, const char parameter_delimiter,
+		const char key_value_delimiter, cvar_token_t **list_head)
+{
+	char *param;
+	char *param_start, *param_end;
+	char *key_start, *key_end;
+	cvar_token_t *lhead, *prev, *curr;
+	int more_params;
+	int no_value;
+	int ret = -1;
+
+	if (!parameters)
+		goto out;
+
+	lhead = prev = NULL;
+
+	param = strdup(parameters);
+	if (!param) {
+		cvar_log_error("Out of memory");
+		goto cleanup;
+	}
+
+	param_start = param;
+	more_params = 1;
+
+	while (more_params) {
+		param_end = strchr(param_start, parameter_delimiter);
+		if (param_end)
+			*param_end = '\0';
+		else {
+			param_end = param_start + strlen(param_start);
+			more_params = 0;
+		}
+
+		if (param_start != param_end) {
+			key_start = param_start;
+			key_end = strchr(param_start, key_value_delimiter);
+			if (key_end) {
+				*key_end = '\0';
+				no_value = 0;
+			} else {
+				key_end = param_end;
+				no_value = 1;
+			}
+
+			if (key_start == key_end) {
+				cvar_log_error("Empty key at position %ud in parameter string "
+						"\"%s\"",(unsigned int) ((key_start - param)/sizeof(char) + 1),
+						parameters);
+				goto cleanup;
+			}
+
+
+			curr = (cvar_token_t *) malloc(sizeof(cvar_token_t));
+			if (!curr) {
+				cvar_log_error("Out of memory");
+				goto cleanup;
+			}
+
+			memset(curr, 0x00, sizeof(cvar_token_t));
+
+			curr->key = strdup(key_start);
+			if (!curr->key) {
+				cvar_log_error("Out of memory");
+				goto cleanup;
+			}
+
+			if (!no_value) {
+				curr->value = strdup(key_end+1);
+				if (!curr->value) {
+					cvar_log_error("Out of memory");
+					goto cleanup;
+				}
+			}
+
+			if (!prev)
+				lhead = prev = curr;
+			else {
+				prev->next = curr;
+				prev = curr;
+			}
+		}
+
+		if (more_params)
+			param_start = param_end + 1;
+	}
+
+	*list_head = lhead;
+	ret = 0;
+
+out:
+	return ret;
+
+cleanup:
+	free_tokens(lhead);
+	lhead = NULL;
+	goto out;
+}
+
+/*
+ * Finds a token with a given key. Returns NULL if the token is not found or if
+ * list_head or key is NULL.
+ */
+
+cvar_token_t *find_token(cvar_token_t *list_head, const char *key)
+{
+	cvar_token_t *t;
+
+	if (!list_head || !key)
+		return NULL;
+
+	for (t = list_head; t != NULL; t = t->next) {
+		if (t->key && !strcmp(t->key, key))
+			return t;
+	}
+
+	return NULL;
+}
+
+/*
+ * Returns a pointer to the first unused token or NULL if no unused tokens
+ * exist.
+ */
+
+cvar_token_t *unused_tokens(cvar_token_t *list_head)
+{
+	cvar_token_t *t;
+
+	for (t = list_head; t != NULL; t = t->next) {
+		if (!t->used)
+			break;
+	}
+
+	return t;
+}
+
+static void free_token(cvar_token_t *token)
+{
+	if (!token)
+		return;
+
+	if (token->key)
+		free(token->key);
+	if (token->value)
+		free(token->value);
+
+	free(token);
+
+	return;
+}
+
+/*
+ * Free up a list of tokens.
+ */
+
+void free_tokens(cvar_token_t *list_head)
+{
+	cvar_token_t *curr;
+
+	if (!list_head)
+		return;
+
+	while ((curr = list_head->next) != NULL) {
+		list_head->next = curr->next;
+		free_token(curr);
+	}
+
+	free_token(list_head);
+
+	return;
+}
diff --git a/cvars/utils/tokens/cvar_tokens.h b/cvars/utils/tokens/cvar_tokens.h
new file mode 100644
index 0000000..695628c
--- /dev/null
+++ b/cvars/utils/tokens/cvar_tokens.h
@@ -0,0 +1,48 @@
+/*
+ * cvar_tokens.h
+ *
+ * Simple utilities to manipulate tokens.
+ *
+ * Author: Santhosh Kumar Koundinya (santhosh@fsl.cs.sunysb.edu)
+ */
+
+#ifndef _CVAR_TOKENS_H
+#define _CVAR_TOKENS_H
+
+#define DEFAULT_PARAMETER_DELIMITER	';'
+#define DEFAULT_KEY_VALUE_DELIMITER	':'
+
+/* A token holds a key-value pair. */
+typedef struct cvar_token {
+	char *key;
+	char *value;
+	int used; /* Non-zero if the token is used */
+	struct cvar_token *next;
+} cvar_token_t;
+
+/*
+ * Return 0 if tokenization was successful, non-zero otherwise. This function
+ * does not use strtok (or strtok_r) as we need to point out empty keys.
+ */
+int tokenize(const char *parameters, const char parameter_delimiter,
+		const char key_value_delimiter, cvar_token_t **list_head);
+
+/*
+ * Finds a token with a given key. Returns NULL if the token is not found or if
+ * list_head or key is NULL.
+ */
+cvar_token_t *find_token(cvar_token_t *list_head, const char *key);
+
+/*
+ * Returns a pointer to the first unused token or NULL if no unused tokens
+ * exist.
+ */
+cvar_token_t *unused_tokens(cvar_token_t *list_head);
+
+/*
+ * Free up a list of tokens.
+ */
+
+void free_tokens(cvar_token_t *list_head);
+
+#endif /* _CVAR_TOKENS_H */
diff --git a/fb_cvar.c b/fb_cvar.c
new file mode 100644
index 0000000..f80d34b
--- /dev/null
+++ b/fb_cvar.c
@@ -0,0 +1,507 @@
+/*
+ * fb_cvar.c
+ *
+ * Support for custom variables in Filebench.
+ *
+ * @Author Santhosh Kumar Koundinya (santhosh@fsl.cs.sunysb.edu)
+ */
+
+#include <sys/types.h>
+#include <dirent.h>
+#include <limits.h>
+#include <dlfcn.h>
+
+#include "ipc.h"
+#include "fb_cvar.h"
+
+/* Points to the head of an array of pointers to cvar_library_t. */
+cvar_library_t **cvar_libraries;
+
+/* Some helpers. */
+static int alloc_cvar_lib_info(const char *filename);
+static char *gettype(const char *filename);
+static cvar_library_t *init_cvar_library(cvar_library_info_t *cvar_lib_info);
+static void *load_library(const char *filename);
+static void free_cvar_library(cvar_library_t *c);
+static int init_cvar_library_ops(cvar_library_t *c);
+static void exit_cvar_library(cvar_library_t *cl);
+static void unload_library(void *lib_handle);
+
+/*
+ * Allocate space for a new custom variable in the shared memory location.
+ */
+cvar_t *
+cvar_alloc(void)
+{
+	cvar_t *cvar;
+
+	if ((cvar = (cvar_t *)ipc_malloc(FILEBENCH_CVAR)) == NULL) {
+		filebench_log(LOG_ERROR, "Out of memory for custom variable");
+		return (NULL);
+	}
+
+	/* place on the head of the global list */
+	cvar->next = filebench_shm->shm_cvar_list;
+	filebench_shm->shm_cvar_list = cvar;
+
+	return (cvar);
+}
+
+/*
+ * Initialize cvar_library_info structures in the shared memory.
+ * Return 0 on success and a non zero error code on failure.
+ */
+int
+init_cvar_library_info(const char *dirpath)
+{
+	DIR *libdir = NULL;
+	struct dirent *dirent;
+	char *filename = NULL;
+	int ret = -1;
+	int dirpath_len = strlen(dirpath);
+
+	filename = (char *) malloc(dirpath_len + 1 + NAME_MAX + 1);
+	if (!filename) {
+		filebench_log(LOG_ERROR, "Out of memory");
+		goto out;
+	}
+
+	strcpy(filename, dirpath);
+	filename[dirpath_len] = '/';
+
+	filename[dirpath_len + NAME_MAX] = '\0';
+
+	libdir = opendir(dirpath);
+	if (!libdir)
+		return errno;
+
+	while ((dirent = readdir(libdir)) != NULL) {
+		if (!strcmp(".", dirent->d_name) || !strcmp("..", dirent->d_name))
+			continue;
+
+		strncpy(filename + dirpath_len + 1, dirent->d_name, NAME_MAX);
+		ret = alloc_cvar_lib_info(filename);
+		if (ret)
+			goto out;
+	}
+
+out:
+	if (filename)
+		free(filename);
+
+	if (libdir)
+		closedir(libdir);
+
+	return ret;
+}
+
+/*
+ * Return 0 on success and a non zero error code on failure.
+ */
+static int
+alloc_cvar_lib_info(const char *filename)
+{
+	int ret = -1;
+	cvar_library_info_t *cli = NULL;
+	cvar_library_info_t *t;
+
+	cli = (cvar_library_info_t *) ipc_malloc(FILEBENCH_CVAR_LIB_INFO);
+	if (!cli)
+		goto out;
+
+	cli->filename = ipc_stralloc(filename);
+	if (!cli->filename)
+		goto out;
+
+	cli->type = ipc_stralloc(gettype(filename));
+	if (!cli->type)
+		goto out;
+
+	cli->next = NULL;
+
+	if (filebench_shm->shm_cvar_lib_info_list) {
+		for (t = filebench_shm->shm_cvar_lib_info_list; t->next != NULL;
+				t = t->next); /* Seek to the last entry. */
+
+		cli->index = t->index + 1;
+		t->next = cli;
+	} else {
+		cli->index = 0;
+		filebench_shm->shm_cvar_lib_info_list = cli;
+	}
+
+	ret = 0;
+
+out:
+	if (ret && cli) {
+		/* NOTE: There is no mechanism to free cli->filename and cli->type. */
+		ipc_free(FILEBENCH_NCVAR_LIB_INFO, (char *) cli);
+	}
+
+	return ret;
+}
+
+/*
+ * Returns the 'type' name from the library.
+ */
+static char
+*gettype(const char *filename)
+{
+	char libprefix[] = "lib";
+	const char *libname;
+	char *type;
+	int type_len;
+	const char *t;
+
+	libname = strrchr(filename, '/');
+	if (!libname)
+		libname = filename; /* filename is not a fully qualified path. */
+	else {
+		libname++;
+		/* Check for a malformed filename string. */
+		if (!libname) {
+			filebench_log(LOG_ERROR, "Malformed cvar library filename");
+			return NULL;
+		}
+
+	}
+
+	/* Strip the leading "lib". */
+	if (!strncmp(libprefix, libname, sizeof(libprefix) - 1))
+		libname += sizeof(char) * (sizeof(libprefix) - 1);
+
+	if (!libname) {
+		filebench_log(LOG_ERROR, "Malformed cvar library filename");
+		return NULL;
+	}
+
+	/* Look for the first '.'. */
+	type_len = 0;
+	for (t = libname; *t != '\0' && *t != '.'; t++)
+		type_len++;
+
+	type = (char *) malloc(type_len + 1);
+	if (!type) {
+		filebench_log(LOG_ERROR, "Out of memory");
+		return NULL;
+	}
+	strncpy(type, libname, type_len);
+	type[type_len] = '\0';
+
+	return type;
+}
+
+/*
+ * Load shared objects.
+ * Returns 0 on success and non-zero on error.
+ */
+int
+init_cvar_libraries()
+{
+	int count;
+	int ret = -1;
+	int i;
+
+	cvar_library_info_t *t;
+
+	if (!filebench_shm->shm_cvar_lib_info_list) {
+		/* Nothing to do. */
+		return 0;
+	}
+
+	count = 0;
+	for (t = filebench_shm->shm_cvar_lib_info_list; t != NULL;
+			t = t->next)
+		count++;
+
+	cvar_libraries = (cvar_library_t **)
+			malloc(sizeof(cvar_library_t *) * count);
+
+	if (!cvar_libraries) {
+		filebench_log(LOG_ERROR, "Out of memory");
+		goto out;
+	}
+
+	for (t = filebench_shm->shm_cvar_lib_info_list, i = 0; t != NULL;
+			t = t->next, i++) {
+		if ((cvar_libraries[i] = init_cvar_library(t)) == NULL) {
+			goto out;
+		}
+	}
+
+	ret = 0;
+
+out:
+	return ret;
+}
+
+static cvar_library_t
+*init_cvar_library(cvar_library_info_t *cvar_lib_info)
+{
+	cvar_library_t *c = NULL;
+	int ret;
+
+	c = (cvar_library_t *) malloc(sizeof(cvar_library_t));
+	if (!c) {
+		filebench_log(LOG_ERROR, "Out of memory");
+		goto out;
+	}
+
+	c->cvar_lib_info = cvar_lib_info;
+	c->lib_handle = load_library(cvar_lib_info->filename);
+	if (!c->lib_handle)
+		goto cleanup;
+
+	ret = init_cvar_library_ops(c);
+	if (ret)
+		goto cleanup;
+
+	if (c->cvar_op.cvar_module_init) {
+		ret = c->cvar_op.cvar_module_init();
+		if (ret) {
+			filebench_log(LOG_ERROR, "Failed to initialize custom variable of type"
+					" %s. cvar_module_init failed with error %d",
+					cvar_lib_info->type, ret);
+			goto cleanup;
+		}
+	}
+
+out:
+	return c;
+
+cleanup:
+	if (c) {
+		free_cvar_library(c);
+		free(c);
+		c = NULL;
+	}
+	goto out;
+}
+
+static void
+*load_library(const char *filename)
+{
+	void *lib_handle = dlopen(filename, RTLD_LOCAL | RTLD_NOW);
+	if (!lib_handle)
+		filebench_log(LOG_ERROR, "Unable to load library %s: %s",
+				filename, dlerror());
+
+	return lib_handle;
+}
+
+static void
+free_cvar_library(cvar_library_t *c)
+{
+	if (c) {
+		if (c->lib_handle) {
+			dlclose(c->lib_handle);
+		}
+	}
+}
+
+static int
+init_cvar_library_ops(cvar_library_t *c)
+{
+	int ret = -1;
+
+	c->cvar_op.cvar_module_init = dlsym(c->lib_handle, FB_CVAR_MODULE_INIT);
+
+	c->cvar_op.cvar_alloc_handle = dlsym(c->lib_handle, FB_CVAR_ALLOC_HANDLE);
+	if (!c->cvar_op.cvar_alloc_handle) {
+		filebench_log(LOG_ERROR, "Unable to find " FB_CVAR_ALLOC_HANDLE
+				": %s.", dlerror());
+		goto out;
+	}
+
+	c->cvar_op.cvar_revalidate_handle = dlsym(c->lib_handle,
+			FB_CVAR_REVALIDATE_HANDLE);
+
+	c->cvar_op.cvar_next_value = dlsym(c->lib_handle, FB_CVAR_NEXT_VALUE);
+	if (!c->cvar_op.cvar_next_value) {
+		filebench_log(LOG_ERROR, "Unable to find " FB_CVAR_NEXT_VALUE
+				": %s.", dlerror());
+		goto out;
+	}
+
+	c->cvar_op.cvar_free_handle = dlsym(c->lib_handle, FB_CVAR_FREE_HANDLE);
+
+	c->cvar_op.cvar_module_exit = dlsym(c->lib_handle, FB_CVAR_MODULE_EXIT);
+
+	c->cvar_op.cvar_usage = dlsym(c->lib_handle, FB_CVAR_USAGE);
+
+	c->cvar_op.cvar_version = dlsym(c->lib_handle, FB_CVAR_VERSION);
+
+	ret = 0;
+
+out:
+	return ret;
+}
+
+int
+init_cvar_handle(cvar_t *cvar, const char *type, const char *parameters)
+{
+	int ret = -1;
+	cvar_library_t *cvar_lib;
+	cvar_library_info_t *t;
+
+	for (t = filebench_shm->shm_cvar_lib_info_list; t != NULL; t = t->next) {
+		if (!strcmp(type, t->type))
+			break;
+	}
+
+	if (!t) {
+		filebench_log(LOG_ERROR, "Undefined custom variable %s", type);
+		goto out;
+	}
+
+	cvar->cvar_lib_info = t;
+	ret = pthread_mutex_init(&cvar->cvar_lock, NULL);
+	if (ret) {
+		filebench_log(LOG_ERROR, "Custom variable lock initialization failed "
+				"with error %d.", ret);
+		goto out;
+	}
+
+	cvar_lib = cvar_libraries[cvar->cvar_lib_info->index];
+	cvar->cvar_handle = cvar_lib->cvar_op.cvar_alloc_handle(parameters,
+			ipc_cvar_heapalloc, ipc_cvar_heapfree);
+	if (!cvar->cvar_handle) {
+		ret = -1;
+		goto out;
+	}
+
+	ret = 0;
+
+out:
+	return ret;
+}
+
+double
+get_cvar_value(cvar_t *cvar)
+{
+	int ret;
+	double value = 0.0;
+	fbint_t round = cvar->round;
+
+	ipc_mutex_lock(&cvar->cvar_lock);
+	cvar_library_t *cvar_lib = cvar_libraries[cvar->cvar_lib_info->index];
+	ret = cvar_lib->cvar_op.cvar_next_value(cvar->cvar_handle, &value);
+	ipc_mutex_unlock(&cvar->cvar_lock);
+
+	if (ret) {
+		filebench_log(LOG_ERROR, "Unable to get next_value from custom variable"
+				" of type %s", cvar->cvar_lib_info->type);
+		filebench_shutdown(1);
+	}
+
+	if (round) {
+		fbint_t num, lower, upper;
+
+		num = (fbint_t) value;
+		lower = num - (num % round);
+		upper = lower + round;
+
+		value = (num - lower) > (upper - num) ? upper : lower;
+	}
+
+	if (value < cvar->min)
+		value = cvar->min;
+	else if (value > cvar->max)
+		value = cvar->max;
+
+	return value;
+}
+
+/*
+ * Return 0 on success and a non-zero error code on failure.
+ */
+int
+revalidate_cvar_handles()
+{
+	cvar_t *t;
+	cvar_library_t *cvar_lib;
+	int ret;
+
+	if (!filebench_shm->shm_cvar_list)
+		return 0; /* Nothing to do. */
+
+	for (t = filebench_shm->shm_cvar_list; t != NULL; t = t->next) {
+		cvar_lib = cvar_libraries[t->cvar_lib_info->index];
+		if (cvar_lib->cvar_op.cvar_revalidate_handle) {
+			ipc_mutex_lock(&t->cvar_lock);
+			ret = cvar_lib->cvar_op.cvar_revalidate_handle(t->cvar_handle);
+			ipc_mutex_unlock(&t->cvar_lock);
+
+			if (ret) {
+				filebench_log(LOG_ERROR, "Revalidation failed for cvar_handle "
+						"of type %s with error code %d", t->cvar_lib_info->type,
+						ret);
+				return ret;
+			}
+		}
+	}
+
+	return 0;
+}
+
+void
+free_cvar_handles()
+{
+	cvar_t *c;
+	cvar_library_t *cl;
+
+	for (c = filebench_shm->shm_cvar_list; c != NULL; c = c->next) {
+		cl = cvar_libraries[c->cvar_lib_info->index];
+
+		if (cl->cvar_op.cvar_free_handle)
+			cl->cvar_op.cvar_free_handle(c->cvar_handle, ipc_cvar_heapfree);
+		else
+			ipc_cvar_heapfree(c->cvar_handle);
+
+		c->cvar_lib_info = NULL;
+		c->cvar_handle = NULL;
+	}
+}
+
+void
+exit_cvar_libraries()
+{
+	cvar_library_info_t *cli;
+
+	for (cli = filebench_shm->shm_cvar_lib_info_list; cli != NULL;
+			cli = cli->next) {
+		exit_cvar_library(cvar_libraries[cli->index]);
+		free(cvar_libraries[cli->index]);
+		cvar_libraries[cli->index] = NULL;
+	}
+
+	free(cvar_libraries);
+	cvar_libraries = NULL;
+}
+
+static void
+exit_cvar_library(cvar_library_t *cl)
+{
+	if (cl->cvar_op.cvar_module_exit)
+		cl->cvar_op.cvar_module_exit();
+
+	cl->cvar_lib_info = NULL;
+
+	cl->cvar_op.cvar_module_init = NULL;
+	cl->cvar_op.cvar_alloc_handle = NULL;
+	cl->cvar_op.cvar_revalidate_handle = NULL;
+	cl->cvar_op.cvar_next_value = NULL;
+	cl->cvar_op.cvar_free_handle = NULL;
+	cl->cvar_op.cvar_module_exit = NULL;
+	cl->cvar_op.cvar_usage = NULL;
+	cl->cvar_op.cvar_version = NULL;
+
+	unload_library(cl->lib_handle);
+
+}
+
+static void
+unload_library(void *lib_handle)
+{
+	dlclose(lib_handle);
+}
diff --git a/fb_cvar.h b/fb_cvar.h
new file mode 100644
index 0000000..18945bc
--- /dev/null
+++ b/fb_cvar.h
@@ -0,0 +1,88 @@
+/*
+ * fb_cvar.h
+ *
+ * Include file for code using custom variables.
+ *
+ * @Author Santhosh Kumar Koundinya (santhosh@fsl.cs.sunysb.edu)
+ */
+
+#ifndef _FB_CVAR_H
+#define _FB_CVAR_H
+
+#include <stdint.h>
+#include <sys/types.h>
+
+/* Function (symbol) names within custom variable libraries. */
+#define FB_CVAR_MODULE_INIT			"cvar_module_init"
+#define FB_CVAR_ALLOC_HANDLE		"cvar_alloc_handle"
+#define FB_CVAR_REVALIDATE_HANDLE	"cvar_revalidate_handle"
+#define FB_CVAR_NEXT_VALUE			"cvar_next_value"
+#define FB_CVAR_FREE_HANDLE			"cvar_free_handle"
+#define FB_CVAR_MODULE_EXIT			"cvar_module_exit"
+#define FB_CVAR_USAGE				"cvar_usage"
+#define FB_CVAR_VERSION				"cvar_version"
+
+/* Information about each library supporting a custom variable. This structure
+ * is rooted in the shared memory segment. */
+typedef struct cvar_library_info {
+	char *filename; /* The fully qualified path to the library. */
+	/* The type name of the library is the soname without the "lib" prefix and
+	 * the ".so.XXX.XXX" suffix. */
+	char *type;
+	/* The index is a sequentially increasing count. It helps seek within global
+	 * variable cvar_libraries. */
+	int index;
+	struct cvar_library_info *next;
+} cvar_library_info_t;
+
+/* Structure that encapsulates access to a custom variable. A var_t points to a
+ * cvar_t (and not vice versa). */
+typedef struct cvar {
+	/* Used to provide exclusive access to this custom variable across threads
+	 * and processes. */
+	pthread_mutex_t cvar_lock;
+	/* The custom variable handle returned by cvar_alloc() */
+	void *cvar_handle;
+	double min;
+	double max;
+	uint64_t round;
+	cvar_library_info_t *cvar_lib_info;
+	struct cvar *next;
+} cvar_t;
+
+/* The operations vector for a library. Each member is populated by a call to
+ * dlsym(). */
+typedef struct cvar_operations {
+	int (*cvar_module_init)(void);
+	void *(*cvar_alloc_handle)(const char *cvar_parameters,
+			void *(*cvar_malloc)(size_t size), void (*cvar_free)(void *ptr));
+	int (*cvar_revalidate_handle)(void *cvar_handle);
+	int (*cvar_next_value)(void *cvar_handle, double *value);
+	void (*cvar_free_handle)(void *cvar_handle, void (*cvar_free)(void *ptr));
+	void (*cvar_module_exit)();
+	const char *(*cvar_usage)(void);
+	const char *(*cvar_version)(void);
+} cvar_operations_t;
+
+/* Structure that represents a library.  This structure is "per-process" and
+ * "per-library" (and not in the shared memory). There is a one to one mapping
+ * between cvar_library_t and cvar_library_info_t. */
+typedef struct cvar_library {
+	cvar_library_info_t *cvar_lib_info;
+	void *lib_handle; /* The handle returned by dlopen(). */
+	cvar_operations_t cvar_op; /* The operations vector of the library. */
+} cvar_library_t;
+
+/* Points to the head of an array of pointers to cvar_library_t. */
+extern cvar_library_t **cvar_libraries;
+
+cvar_t * cvar_alloc(void);
+int init_cvar_library_info(const char *dirpath);
+int init_cvar_libraries();
+int init_cvar_handle(cvar_t *cvar, const char *type, const char *parameters);
+double get_cvar_value(cvar_t *cvar);
+int revalidate_cvar_handles();
+void free_cvar_handles();
+void exit_cvar_libraries();
+
+#endif /* _FB_CVAR_H */
diff --git a/flowop.c b/flowop.c
index 0550f6d..c9bf633 100644
--- a/flowop.c
+++ b/flowop.c
@@ -190,7 +190,7 @@ flowop_beginop(threadflow_t *threadflow, flowop_t *flowop)
 #endif
 
 	/* Start of op for this thread */
-	threadflow->tf_stime = gethrtime();
+//	threadflow->tf_stime = gethrtime();
 }
 
 struct flowstats controlstats;
@@ -226,7 +226,8 @@ flowop_endop(threadflow_t *threadflow, flowop_t *flowop, int64_t bytes)
 	hrtime_t t = 0;
 #endif
 
-	ll_delay = (gethrtime() - threadflow->tf_stime);
+	//ll_delay = (gethrtime() - threadflow->tf_stime);
+	ll_delay = 0;
 
 	/* setting minimum and maximum latencies for this flowop */
 	if (!flowop->fo_stats.fs_minlat || ll_delay < flowop->fo_stats.fs_minlat)
diff --git a/flowop.h b/flowop.h
index 7435d35..6c2e0d7 100644
--- a/flowop.h
+++ b/flowop.h
@@ -68,6 +68,7 @@ typedef struct flowop {
 	avd_t		fo_rotatefd;	/* Attr */
 	avd_t		fo_fileindex;	/* Attr */
 	avd_t		fo_noreadahead; /* Attr */
+	avd_t		fo_offset;		/* Attr */
 	struct flowstats	fo_stats;	/* Flow statistics */
 #ifdef HAVE_PROC_PID_STAT
 	hrtime_t	fo_start_usage;	/* record CPU usage values for each flowop at the start of flowop */	
diff --git a/flowop_library.c b/flowop_library.c
index 85ac02a..5847ec9 100644
--- a/flowop_library.c
+++ b/flowop_library.c
@@ -465,7 +465,8 @@ flowoplib_iobufsetup(threadflow_t *threadflow, flowop_t *flowop,
 			return (FILEBENCH_ERROR);
 		}
 
-		fb_urandom(&memoffset, memsize, iosize, NULL);
+		//fb_urandom(&memoffset, memsize, iosize, NULL);
+		memoffset = 0;
 		*iobufp = threadflow->tf_mem + memoffset;
 
 	} else {
@@ -551,7 +552,23 @@ flowoplib_read(threadflow_t *threadflow, flowop_t *flowop)
 	    &fdesc, iosize)) != FILEBENCH_OK)
 		return (ret);
 
-	if (avd_get_bool(flowop->fo_random)) {
+	if (flowop->fo_offset) {
+		off_t fileoffset = (off_t) avd_get_int(flowop->fo_offset);
+
+		(void) flowop_beginop(threadflow, flowop);
+		if ((ret = FB_PREAD(fdesc, iobuf,
+			iosize, fileoffset)) == -1) {
+			(void) flowop_endop(threadflow, flowop, 0);
+			filebench_log(LOG_ERROR,
+				"read file %s failed, offset %llu "
+				"io buffer %zd: %s",
+				avd_get_str(flowop->fo_fileset->fs_name),
+				(u_longlong_t)fileoffset, iobuf, strerror(errno));
+			flowop_endop(threadflow, flowop, 0);
+			return (FILEBENCH_ERROR);
+		}
+		(void) flowop_endop(threadflow, flowop, ret);
+	} else 	if (avd_get_bool(flowop->fo_random)) {
 		uint64_t fileoffset;
 
 		if (iosize > wss) {
@@ -2319,7 +2336,21 @@ flowoplib_write(threadflow_t *threadflow, flowop_t *flowop)
 	    &fdesc, iosize)) != FILEBENCH_OK)
 		return (ret);
 
-	if (avd_get_bool(flowop->fo_random)) {
+  if (flowop->fo_offset) {
+    off_t fileoffset = (off_t) avd_get_int(flowop->fo_offset);
+
+    (void) flowop_beginop(threadflow, flowop);
+    if ((ret = FB_PWRITE(fdesc, iobuf,
+      iosize, fileoffset)) == -1) {
+      (void) flowop_endop(threadflow, flowop, 0);
+      filebench_log(LOG_ERROR, "write failed, "
+          "offset %llu io buffer %zd: %s",
+          (u_longlong_t)fileoffset, iobuf, strerror(errno));
+      flowop_endop(threadflow, flowop, 0);
+      return (FILEBENCH_ERROR);
+    }
+    (void) flowop_endop(threadflow, flowop, ret);
+  } else  if (avd_get_bool(flowop->fo_random)) {
 		uint64_t fileoffset;
 
 		if (wss < iosize) {
diff --git a/ipc.c b/ipc.c
index fb96500..ffb453b 100644
--- a/ipc.c
+++ b/ipc.c
@@ -37,6 +37,7 @@
 #include <pthread.h>
 #include <sys/shm.h>
 #include "filebench.h"
+#include "fb_cvar.h"
 
 filebench_shm_t *filebench_shm = NULL;
 char shmpath[128] = "/tmp/filebench-shm-XXXXXX";
@@ -471,6 +472,14 @@ preallocated_entries(int obj_type)
 		entries = sizeof(filebench_shm->shm_randdist)
 						/ sizeof(randdist_t);
 		break;
+	case FILEBENCH_CVAR:
+		entries = sizeof(filebench_shm->shm_cvar)
+						/ sizeof(cvar_t);
+		break;
+	case FILEBENCH_CVAR_LIB_INFO:
+		entries = sizeof(filebench_shm->shm_cvar_lib_info)
+						/ sizeof(cvar_library_info_t);
+		break;
 	default:
 		entries = -1;
 		filebench_log(LOG_ERROR, "preallocated_entries: "
@@ -577,6 +586,16 @@ ipc_malloc(int obj_type)
 		(void) ipc_mutex_unlock(&filebench_shm->shm_malloc_lock);
 		return ((char *)&filebench_shm->shm_randdist[i]);
 
+	case FILEBENCH_CVAR:
+		(void) memset((char *)&filebench_shm->shm_cvar[i], 0, sizeof(cvar_t));
+		(void) ipc_mutex_unlock(&filebench_shm->shm_malloc_lock);
+		return ((char *)&filebench_shm->shm_cvar[i]);
+
+	case FILEBENCH_CVAR_LIB_INFO:
+		(void) memset((char *)&filebench_shm->shm_cvar_lib_info[i], 0,
+			sizeof(cvar_library_info_t));
+		(void) ipc_mutex_unlock(&filebench_shm->shm_malloc_lock);
+		return ((char *)&filebench_shm->shm_cvar_lib_info[i]);
 	}
 
 	filebench_log(LOG_ERROR, "Attempt to ipc_malloc unknown object type (%d)!",
@@ -651,6 +670,10 @@ ipc_free(int type, char *addr)
 		size = sizeof (randdist_t);
 		break;
 
+	case FILEBENCH_CVAR:
+		base = (caddr_t)&filebench_shm->shm_cvar[0];
+		size = sizeof (cvar_t);
+		break;
 	}
 
 	offset = ((size_t)addr - (size_t)base);
@@ -668,7 +691,7 @@ ipc_free(int type, char *addr)
  * copied to the newly allocated string.
  */
 char *
-ipc_stralloc(char *string)
+ipc_stralloc(const char *string)
 {
 	char *allocstr = filebench_shm->shm_string_ptr;
 
@@ -726,6 +749,39 @@ ipc_freepaths(void)
 }
 
 /*
+ * Limited functionality allocator for use by custom variables to allocate
+ * state.
+ */
+void
+*ipc_cvar_heapalloc(size_t size)
+{
+	void *memory;
+
+	(void) ipc_mutex_lock(&filebench_shm->shm_malloc_lock);
+
+	if ((filebench_shm->shm_cvar_heapsize + size) <= FILEBENCH_CVAR_HEAPSIZE) {
+		memory = filebench_shm->shm_cvar_heap +
+				filebench_shm->shm_cvar_heapsize;
+
+		filebench_shm->shm_cvar_heapsize += size;
+	} else
+		memory = NULL;
+
+	(void) ipc_mutex_unlock(&filebench_shm->shm_malloc_lock);
+
+	return memory;
+}
+
+void
+ipc_cvar_heapfree(void *ptr)
+{
+	/* Since Filebench will shutdown when the allocation of a custom variable
+	 * handle fails, there's no immediate need to implement free functionality
+	 * here. */
+	return;
+}
+
+/*
  * Allocates a semid from the table of semids for pre intialized
  * semaphores. Searches for the first available semaphore, and
  * sets the entry in the table to "1" to indicate allocation.
diff --git a/ipc.h b/ipc.h
index d3416fb..e90cd27 100644
--- a/ipc.h
+++ b/ipc.h
@@ -64,7 +64,9 @@
 #define	FILEBENCH_VARIABLE	6
 #define	FILEBENCH_AVD		7
 #define	FILEBENCH_RANDDIST	8
-#define	FILEBENCH_MAXTYPE	FILEBENCH_RANDDIST
+#define FILEBENCH_CVAR			9
+#define FILEBENCH_CVAR_LIB_INFO	10
+#define	FILEBENCH_MAXTYPE		FILEBENCH_CVAR_LIB_INFO
 
 /*
  * The values below are selected by intuition: these limits
@@ -86,11 +88,14 @@
 #define	FILEBENCH_NVARIABLES		(1024)
 #define	FILEBENCH_NAVDS			(4096)
 #define	FILEBENCH_NRANDDISTS		(16)
+#define FILEBENCH_NCVARS			(16)
+#define FILEBENCH_NCVAR_LIB_INFO	(32)
 #define	FILEBENCH_MAXBITMAP		FILEBENCH_NFILESETENTRIES
 
 /* these below are not regular pools and are allocated separately from ipc_malloc() */
 #define	FILEBENCH_FILESETPATHMEMORY	(FILEBENCH_NFILESETENTRIES * FSE_MAXPATHLEN)
 #define	FILEBENCH_STRINGMEMORY		(FILEBENCH_NVARIABLES * 128)
+#define FILEBENCH_CVAR_HEAPSIZE		(FILEBENCH_NCVARS * 4096)
 
 typedef struct filebench_shm {
 	/*
@@ -146,6 +151,8 @@ typedef struct filebench_shm {
 	var_t		*shm_var_dyn_list; /* special system variables */
 	var_t		*shm_var_loc_list; /* variables local to comp flowops */
 	randdist_t	*shm_rand_list;	   /* random variables */
+	cvar_t		*shm_cvar_list;    /* custom variables */
+	cvar_library_info_t *shm_cvar_lib_info_list;
 
 	/*
 	 * log and statistics dumping controls and state
@@ -188,6 +195,7 @@ typedef struct filebench_shm {
 	hrtime_t	shm_starttime;
 	int		shm_utid;
 	int		osprof_enabled;
+	int		shm_cvar_heapsize;
 
 	/*
 	 * Shared memory allocation control
@@ -236,10 +244,13 @@ typedef struct filebench_shm {
 	var_t		shm_var[FILEBENCH_NVARIABLES];
 	struct avd	shm_avd_ptrs[FILEBENCH_NAVDS];
 	randdist_t	shm_randdist[FILEBENCH_NRANDDISTS];
+	cvar_t		shm_cvar[FILEBENCH_NCVARS];
+	cvar_library_info_t shm_cvar_lib_info[FILEBENCH_NCVAR_LIB_INFO];
 
 	/* these below are not regular pools and are allocated separately from ipc_malloc() */
 	char		shm_strings[FILEBENCH_STRINGMEMORY];
 	char		shm_filesetpaths[FILEBENCH_FILESETPATHMEMORY];
+	char		shm_cvar_heap[FILEBENCH_CVAR_HEAPSIZE];
 
 } filebench_shm_t;
 
@@ -255,8 +266,10 @@ pthread_mutexattr_t *ipc_mutexattr(int);
 pthread_condattr_t *ipc_condattr(void);
 int ipc_semidalloc(void);
 void ipc_semidfree(int semid);
-char *ipc_stralloc(char *string);
+char *ipc_stralloc(const char *string);
 char *ipc_pathalloc(char *string);
+void *ipc_cvar_heapalloc(size_t size);
+void ipc_cvar_heapfree(void *ptr);
 int ipc_mutex_lock(pthread_mutex_t *mutex);
 int ipc_mutex_unlock(pthread_mutex_t *mutex);
 void ipc_seminit(void);
diff --git a/misc.c b/misc.c
index 4dc6962..8276e69 100644
--- a/misc.c
+++ b/misc.c
@@ -36,6 +36,7 @@
 #include "eventgen.h"
 #include "utils.h"
 #include "fsplug.h"
+#include "fb_cvar.h"
 
 /* File System functions vector */
 fsplug_func_t *fs_functions_vec;
@@ -370,6 +371,9 @@ filebench_shutdown(int error) {
 
 	procflow_shutdown();
 
+	free_cvar_handles();
+	exit_cvar_libraries();
+
 	(void) unlink("/tmp/filebench_shm");
 	ipc_ismdelete();
 	exit(error);
diff --git a/parser_gram.y b/parser_gram.y
index 1e6b77f..0641459 100644
--- a/parser_gram.y
+++ b/parser_gram.y
@@ -31,6 +31,8 @@
 #include <stdlib.h>
 #include <stdio.h>
 #include <string.h>
+#include <float.h>
+#include <limits.h>
 #include <signal.h>
 #include <errno.h>
 #include <sys/types.h>
@@ -56,6 +58,7 @@
 #include "auto_comp.h"
 #endif
 #include "multi_client_sync.h"
+#include "fb_cvar.h"
 
 /* yacc and lex externals */
 extern FILE *yyin;
@@ -95,6 +98,8 @@ static void add_lvar_to_list(var_t *newlvar, var_t **lvar_list);
 /* Info Commands */
 static void parser_list(cmd_t *);
 static void parser_flowop_list(cmd_t *);
+static void parser_list_cvar_types(void);
+static void parser_list_cvar_type_parameters(cmd_t *);
 
 /* Define Commands */
 static void parser_proc_define(cmd_t *);
@@ -106,6 +111,7 @@ static void parser_posset_define(cmd_t *);
 static void parser_randvar_define(cmd_t *);
 static void parser_randvar_set(cmd_t *);
 static void parser_composite_flowop_define(cmd_t *);
+static void parser_cvar_define(cmd_t *);
 
 /* Create Commands */
 static void parser_proc_create(cmd_t *);
@@ -191,9 +197,9 @@ static void parser_osprof_disable(cmd_t *cmd);
 %token FSA_DSYNC FSA_TARGET FSA_ITERS FSA_NICE FSA_VALUE FSA_BLOCKING
 %token FSA_HIGHWATER FSA_DIRECTIO FSA_DIRWIDTH FSA_FD FSA_SRCFD FSA_ROTATEFD
 %token FSA_NAMELENGTH FSA_FILESIZE FSA_ENTRIES FSA_FILESIZEGAMMA FSA_DIRDEPTHRV
-%token FSA_DIRGAMMA FSA_USEISM FSA_TYPE FSA_RANDTABLE FSA_RANDSRC FSA_RANDROUND
+%token FSA_DIRGAMMA FSA_USEISM FSA_TYPE FSA_RANDTABLE FSA_RANDSRC FSA_ROUND
 %token FSA_LEAFDIRS FSA_INDEXED FSA_FSTYPE
-%token FSA_RANDSEED FSA_RANDGAMMA FSA_RANDMEAN FSA_RANDMIN FSA_RANDMAX FSA_MASTER
+%token FSA_RANDSEED FSA_RANDGAMMA FSA_RANDMEAN FSA_MIN FSA_MAX FSA_MASTER
 %token FSA_CLIENT
 %token FSS_TYPE FSS_SEED FSS_GAMMA FSS_MEAN FSS_MIN FSS_SRC FSS_ROUND
 %token FSV_SET_LOCAL_VAR FSA_LVAR_ASSIGN
@@ -202,6 +208,8 @@ static void parser_osprof_disable(cmd_t *cmd);
 %token FSA_NOREADAHEAD
 %token FSA_IOPRIO
 %token FSA_WRITEONLY
+%token FSE_CVAR FSA_PARAMETERS FSA_TYPES
+%token FSA_OFFSET
 
 %type <ival> FSV_VAL_INT
 %type <bval> FSV_VAL_BOOLEAN
@@ -231,6 +239,7 @@ static void parser_osprof_disable(cmd_t *cmd);
 %type <cmd> warmup_command fscheck_command fsflush_command
 %type <cmd> set_integer_command set_other_command
 %type <cmd> osprof_enable_command osprof_disable_command
+%type <cmd> cvar_define_command list_cvar_types_command list_cvar_type_parameters_command;
 
 %type <attr> files_attr_op files_attr_ops posset_attr_ops posset_attr_op pt_attr_op pt_attr_ops
 %type <attr> fo_attr_op fo_attr_ops ev_attr_op ev_attr_ops
@@ -239,6 +248,7 @@ static void parser_osprof_disable(cmd_t *cmd);
 %type <attr> comp_lvar_def comp_attr_op comp_attr_ops
 %type <attr> enable_multi_ops enable_multi_op multisync_op
 %type <attr> fscheck_attr_op
+%type <attr> cvar_attr_ops cvar_attr_op
 %type <list> integer_seplist string_seplist string_list var_string_list
 %type <list> var_string whitevar_string whitevar_string_list
 %type <ival> attrs_define_file attrs_define_thread attrs_flowop
@@ -248,6 +258,7 @@ static void parser_osprof_disable(cmd_t *cmd);
 %type <ival> randsrc_name FSA_RANDSRC randvar_attr_tsp em_attr_name
 %type <ival> FSS_TYPE FSS_SEED FSS_GAMMA FSS_MEAN FSS_MIN FSS_SRC
 %type <ival> fscheck_attr_name FSA_FSTYPE binary_op
+%type <ival> cvar_attr_name 
 
 %type <rndtb>  probtabentry_list probtabentry
 %type <avd> var_int_val
@@ -255,10 +266,10 @@ static void parser_osprof_disable(cmd_t *cmd);
 
 commands: commands command
 {
-	if ($2->cmd != NULL)
+	if (($2 != NULL) && ($2->cmd != NULL)) {
 		$2->cmd($2);
-
-	free($2);
+		free($2);
+	}
 }
 | commands error
 {
@@ -321,7 +332,10 @@ command:
 | osprof_disable_command
 | enable_command
 | multisync_command
-| quit_command;
+| quit_command
+| cvar_define_command
+| list_cvar_types_command
+| list_cvar_type_parameters_command;
 
 foreach_command: FSC_FOREACH
 {
@@ -1266,6 +1280,35 @@ load_command: FSC_LOAD FSV_STRING
 	yy_switchfileparent(yyin);
 };
 
+list_cvar_types_command: FSC_LIST FSE_CVAR FSA_TYPES
+{
+	$$ = NULL;
+	(void) parser_list_cvar_types();
+};
+
+list_cvar_type_parameters_command: FSC_LIST FSE_CVAR FSA_TYPE FSA_PARAMETERS 
+	FSV_STRING
+{
+	attr_t *attr;
+
+	if (($$ = alloc_cmd()) == NULL)
+		YYERROR;
+	if ((attr = alloc_attr()) == NULL)
+		YYERROR;
+
+	$$->cmd = &parser_list_cvar_type_parameters;
+	attr->attr_avd = avd_str_alloc($5);
+	$$->cmd_attr_list = attr;	
+};
+
+
+cvar_define_command: FSC_DEFINE FSE_CVAR cvar_attr_ops
+{
+	if (($$ = alloc_cmd()) == NULL)
+		YYERROR;
+	$$->cmd = &parser_cvar_define;
+	$$->cmd_attr_list = $3;
+}; 
 
 entity: FSE_PROC {$$ = FSE_PROC;}
 | FSE_THREAD {$$ = FSE_THREAD;}
@@ -1315,6 +1358,31 @@ posset_attr_ops: posset_attr_op
 	$$ = $1;
 };
 
+/* attribute parsing for custom variables */
+cvar_attr_ops: cvar_attr_op
+{
+	$$ = $1;
+}
+| cvar_attr_ops FSK_SEPLST cvar_attr_op
+{
+	attr_t *attr = NULL;
+	attr_t *list_end = NULL;
+
+	for (attr = $1; attr != NULL;
+	    attr = attr->attr_next)
+		list_end = attr; /* Find end of list */
+
+	list_end->attr_next = $3;
+
+	$$ = $1;
+}
+
+cvar_attr_op: cvar_attr_name FSK_ASSIGN attr_list_value
+{
+	$$ = $3;
+	$$->attr_name = $1;
+};
+
 posset_attr_op: posset_attr_name FSK_ASSIGN attr_list_value
 {
 	$$ = $3;
@@ -1628,15 +1696,15 @@ attrs_define_posset:
 | FSA_TYPE { $$ = FSA_TYPE;}
 | FSA_RANDSEED { $$ = FSA_RANDSEED;}
 | FSA_ENTRIES { $$ = FSA_ENTRIES;}
-| FSA_RANDMAX { $$ = FSA_RANDMAX;};
+| FSA_MAX { $$ = FSA_MAX;};
 
 randvar_attr_name:
   FSA_NAME { $$ = FSA_NAME;}
 | FSA_RANDSEED { $$ = FSA_RANDSEED;}
 | FSA_RANDGAMMA { $$ = FSA_RANDGAMMA;}
 | FSA_RANDMEAN { $$ = FSA_RANDMEAN;}
-| FSA_RANDMIN { $$ = FSA_RANDMIN;}
-| FSA_RANDROUND { $$ = FSA_RANDROUND;};
+| FSA_MIN { $$ = FSA_MIN;}
+| FSA_ROUND { $$ = FSA_ROUND;};
 
 randvar_attr_tsp:
   FSS_TYPE { $$ = FSS_TYPE;}
@@ -1677,6 +1745,14 @@ randsrc_name:
   FSV_URAND { $$ = FSV_URAND;}
 | FSV_RAND48 { $$ = FSV_RAND48;};
 
+cvar_attr_name:
+  FSA_NAME { $$ = FSA_NAME;}
+| FSA_TYPE { $$ = FSA_TYPE;}
+| FSA_PARAMETERS { $$ = FSA_PARAMETERS;}
+| FSA_MIN { $$ = FSA_MIN;}
+| FSA_MAX { $$ = FSA_MAX;}
+| FSA_ROUND { $$ = FSA_ROUND;};
+
 attrs_define_thread:
   FSA_PROCESS { $$ = FSA_PROCESS;}
 | FSA_NAME { $$ = FSA_NAME;}
@@ -1703,7 +1779,8 @@ attrs_flowop:
 | FSA_BLOCKING { $$ = FSA_BLOCKING;}
 | FSA_HIGHWATER { $$ = FSA_HIGHWATER;}
 | FSA_IOSIZE { $$ = FSA_IOSIZE;}
-| FSA_NOREADAHEAD { $$ = FSA_NOREADAHEAD;};
+| FSA_NOREADAHEAD { $$ = FSA_NOREADAHEAD;}
+| FSA_OFFSET { $$ = FSA_OFFSET;};
 
 attrs_eventgen:
   FSA_RATE { $$ = FSA_RATE;};
@@ -2074,6 +2151,7 @@ main(int argc, char *argv[])
 #else /* HAVE_LIBTECLA */
 	char line[1024];
 #endif
+	int ret;
 
 	 /* parsing the parameters */
 	while ((opt = getopt(argc, argv, cmd_options)) > 0) {
@@ -2138,20 +2216,34 @@ main(int argc, char *argv[])
 		if (ipc_attach(shmaddr) < 0) {
 			filebench_log(LOG_FATAL, "Cannot attach shm for %s",
 			    procname);
-			exit(1);
+			_exit(1);
 		}
 
 		/* get correct function pointer for each working process */
 		filebench_plugin_funcvecinit();
+		
+		/* Load custom variable libraries and re-validate handles. */
+		ret = init_cvar_libraries();
+		if (ret) {
+			filebench_log(LOG_FATAL, "Failed to initialize custom variable "
+				"libraries");
+			_exit(1);
+		}
+
+		ret = revalidate_cvar_handles();
+		if (ret) {
+			filebench_log(LOG_FATAL, "Failed to revalidate handles");
+			_exit(1);
+		}
 
 		/* execute corresponding procflow */
 		if (procflow_exec(procname, instance) < 0) {
 			filebench_log(LOG_FATAL, "Cannot startup process %s",
 			    procname);
-			exit(1);
+			_exit(1);
 		}
 
-		exit(0);
+		_exit(0);
 	}
 
 	/*
@@ -2168,7 +2260,7 @@ main(int argc, char *argv[])
 	if (cwdret != cwd) {
 		filebench_log(LOG_FATAL, "Cannot save current "
 					 "working directory!");
-		exit(1);
+		_exit(1);
 	}
 
 	fb_set_shmmax();
@@ -2181,6 +2273,21 @@ main(int argc, char *argv[])
 	flowop_init();
 	stats_init();
 	eventgen_init();
+	
+	/* Initialize custom variables. */
+	ret = init_cvar_library_info(FILEBENCHDIR "/cvars/");
+	if (ret) {
+		filebench_log(LOG_FATAL, "Unable to locate custom libraries at "
+			FILEBENCHDIR "/cvars/");
+		_exit(1);
+    }
+
+	ret = init_cvar_libraries();
+	if (ret) {
+		filebench_log(LOG_FATAL, "Unable to initialize custom libraries at "
+			FILEBENCHDIR "/cvars/");
+		_exit(1);
+	}
 
 	signal(SIGINT, parser_abort);
 
@@ -2761,7 +2868,11 @@ parser_flowop_get_attrs(cmd_t *cmd, flowop_t *flowop)
 	else
 		flowop->fo_noreadahead = avd_bool_alloc(FALSE);
 
-
+	/* Offset */
+	if ((attr = get_attr(cmd, FSA_OFFSET)))
+	   flowop->fo_offset = attr->attr_avd;
+    else
+        flowop->fo_offset = NULL;
 }
 
 /*
@@ -3291,7 +3402,7 @@ parser_posset_define(cmd_t *cmd)
 	else
 		seed = avd_int_alloc(0);
 
-	if ((attr = get_attr_integer(cmd, FSA_RANDMAX)))
+	if ((attr = get_attr_integer(cmd, FSA_MAX)))
 		max = attr->attr_avd;
 	else
 		max = avd_int_alloc(0);
@@ -4435,13 +4546,13 @@ parser_randvar_define(cmd_t *cmd)
 	}
 
 	/* Get the min value of the random distribution */
-	if ((attr = get_attr_integer(cmd, FSA_RANDMIN)))
+	if ((attr = get_attr_integer(cmd, FSA_MIN)))
 		rndp->rnd_min = attr->attr_avd;
 	else
 		rndp->rnd_min = avd_int_alloc(0);
 
 	/* Get the roundoff value for the random distribution */
-	if ((attr = get_attr_integer(cmd, FSA_RANDROUND)))
+	if ((attr = get_attr_integer(cmd, FSA_ROUND)))
 		rndp->rnd_round = attr->attr_avd;
 	else
 		rndp->rnd_round = avd_int_alloc(0);
@@ -4501,6 +4612,144 @@ parser_randvar_define(cmd_t *cmd)
 }
 
 /*
+ * Define a custom variable and validate it's parameters.
+ * TODO: Clean up state when things go wrong.
+ */
+static void
+parser_cvar_define(cmd_t *cmd)
+{
+	var_t	*var;
+	cvar_t	*cvar;
+	attr_t	*attr;
+	char	*name;
+	char	*type;
+	char	*parameters;
+	int 	ret;
+
+	/* Get the name of the custom variable */
+	if ((attr = get_attr(cmd, FSA_NAME))) {
+		name = avd_get_str(attr->attr_avd);
+	} else {
+		filebench_log(LOG_ERROR,
+		    "define cvar: no name specified");
+		return;
+	}
+
+	/* Get the type and parameters of the custom variable and initialize the
+	 * handle. */
+	if ((attr = get_attr(cmd, FSA_TYPE))) {
+		type = avd_get_str(attr->attr_avd);
+	} else {
+		filebench_log(LOG_ERROR,
+		    "define cvar: no type specified");
+		return;
+	}
+
+	if ((attr = get_attr(cmd, FSA_PARAMETERS))) {
+		parameters = avd_get_str(attr->attr_avd);
+	} else
+		parameters = NULL;
+
+	if ((var = var_define_cvar(name)) == NULL) {
+		filebench_log(LOG_FATAL, "define cvar: failed for custom variable %s",
+		    name);
+		filebench_shutdown(1);
+		return;
+	}
+
+	cvar = var->var_val.cvar;
+
+	/* Initialize the custom variable mutex. */
+	(void) pthread_mutex_init(&cvar->cvar_lock,
+			ipc_mutexattr(IPC_MUTEX_NORMAL));
+
+	/* Get the min, max and round values for the custom variable. */
+	if ((attr = get_attr(cmd, FSA_MIN)))
+		cvar->min = avd_get_dbl(attr->attr_avd);
+	else
+		cvar->min = DBL_MIN;
+
+	if ((attr = get_attr(cmd, FSA_MAX)))
+		cvar->max = avd_get_dbl(attr->attr_avd);
+	else
+		cvar->max = DBL_MAX;
+
+	if ((attr = get_attr(cmd, FSA_ROUND)))
+		cvar->round = avd_get_dbl(attr->attr_avd);
+	else
+		cvar->round = 0;
+
+	ret = init_cvar_handle(cvar, type, parameters);
+	if (ret) {
+		filebench_log(LOG_FATAL, "define cvar: failed for custom variable %s",
+		    name);
+		filebench_shutdown(1);
+		return;
+	}
+}
+
+void parser_list_cvar_types(void)
+{
+	cvar_library_info_t *t;
+
+	if (!filebench_shm->shm_cvar_lib_info_list) {
+		printf("No custom variables loaded.\n");
+		return;
+	}
+
+	for (t = filebench_shm->shm_cvar_lib_info_list; t != NULL; t = t->next)
+		printf("%s\n", t->type);
+
+	return;
+}
+
+void parser_list_cvar_type_parameters(cmd_t *cmd)
+{
+	char *type;
+	const char *version = NULL;
+	const char *usage = NULL;
+
+	cvar_library_info_t *t;
+
+	type = avd_get_str(cmd->cmd_attr_list->attr_avd);
+	if (type == NULL) { /* We will never ever be here. */
+		filebench_log(LOG_ERROR, "list cvar type parameters: internal error");
+		return;
+	}
+
+	for (t = filebench_shm->shm_cvar_lib_info_list; t != NULL; t = t->next) {
+		if (!strcmp(type, t->type))
+			break;
+	}
+
+	if (!t) {
+		printf("Unknown custom variable %s. Run 'list cvar types' to list "
+				"currently loaded custom variables.\n", type);
+		return;
+	}
+
+	if (cvar_libraries[t->index]->cvar_op.cvar_version)
+		version = cvar_libraries[t->index]->cvar_op.cvar_version();
+	
+	if (cvar_libraries[t->index]->cvar_op.cvar_usage)
+		usage = cvar_libraries[t->index]->cvar_op.cvar_usage();
+
+	printf("Supporting library: %s\n", t->filename);
+	
+	if (version)
+		printf("Version: %s\n", version);
+	else
+		printf("Oops. No version information provided.\n");
+	
+	if (usage)
+		printf("Usage:\n%s\n", usage);
+	else
+		printf("Oops. No usage information provided.\n");
+	
+	return;
+}
+
+/*
  * Set a specified random distribution parameter in a random variable.
  */
 static void
diff --git a/parser_lex.l b/parser_lex.l
index 6c47a4d..c5398ac 100644
--- a/parser_lex.l
+++ b/parser_lex.l
@@ -110,6 +110,7 @@ multidump               { return FSE_MULTIDUMP; }
 all                     { return FSE_ALL; }
 mode                    { return FSE_MODE; }
 multi			{ return FSE_MULTI; }
+cvar                    { return FSE_CVAR; }
 
 alldone                 { return FSA_ALLDONE; }
 blocking                { return FSA_BLOCKING; }
@@ -140,13 +141,15 @@ master			{ return FSA_MASTER; }
 mean                    { return FSA_RANDMEAN; }
 memsize                 { return FSA_MEMSIZE; }
 ioprio                  { return FSA_IOPRIO; }
-min                     { return FSA_RANDMIN; }
-max                     { return FSA_RANDMAX; }
+min                     { return FSA_MIN; }
+max                     { return FSA_MAX; }
 name                    { return FSA_NAME;}
 namelength              { return FSA_NAMELENGTH; }
 nice                    { return FSA_NICE;}
 opennext                { return FSA_ROTATEFD; }
+offset                  { return FSA_OFFSET; }
 paralloc                { return FSA_PARALLOC; }
+parameters              { return FSA_PARAMETERS; }
 path                    { return FSA_PATH; }
 prealloc                { return FSA_PREALLOC; }
 procname                { return FSA_PROCESS; }
@@ -157,7 +160,7 @@ rate                    { return FSA_RATE;}
 readonly		{ return FSA_READONLY; }
 writeonly		{ return FSA_WRITEONLY; }
 reuse                   { return FSA_REUSE; }
-round			{ return FSA_RANDROUND; }
+round			{ return FSA_ROUND; }
 seed			{ return FSA_RANDSEED; }
 size                    { return FSA_SIZE; }
 srcfd                   { return FSA_SRCFD; }
@@ -165,6 +168,7 @@ target                  { return FSA_TARGET;}
 timeout                 { return FSA_TIMEOUT; }
 trusttree		{ return FSA_TRUSTTREE; }
 type			{ return FSA_TYPE; }
+types					{ return FSA_TYPES; }
 useism                  { return FSA_USEISM;}
 value                   { return FSA_VALUE;}
 workingset              { return FSA_WSS; }
@@ -314,7 +318,7 @@ $[({A-Za-z][A-Za-z0-9_]*"."[A-Za-z0-9][)}]*	{
 			}
 
 
-<INITIAL>[/A-Za-z-][/A-Za-z0-9._-]*	{
+<INITIAL>[/A-Za-z-][/A-Za-z0-9._:;-]*	{
 				if ((yylval.sval = strdup(yytext)) == NULL) {
 					yyerror("Out of memory");
 					filebench_shutdown(1);
diff --git a/procflow.c b/procflow.c
index e0c4808..d091c1c 100644
--- a/procflow.c
+++ b/procflow.c
@@ -34,6 +34,7 @@
 #include "procflow.h"
 #include "flowop.h"
 #include "ipc.h"
+#include "fb_cvar.h"
 
 /* pid and procflow pointer for this process */
 pid_t my_pid;
@@ -432,12 +433,14 @@ procflow_createnwait(void *unused)
  * Called by ^c or by sig_kill
  */
 /* ARGSUSED */
-static void
+void
 procflow_cancel(int arg1)
 {
 	filebench_log(LOG_DEBUG_IMPL, "Process signal handler on pid %",
 	    my_procflow->pf_pid);
 
+	exit_cvar_libraries();
+
 	procflow_sleep(my_procflow, SHUTDOWN_WAIT_SECONDS);
 
 	threadflow_delete_all(&my_procflow->pf_threads);
diff --git a/procflow.h b/procflow.h
index 9962818..f85ef5e 100644
--- a/procflow.h
+++ b/procflow.h
@@ -50,5 +50,6 @@ void	procflow_shutdown(void);
 int	procflow_exec(char *name, int instance);
 void	procflow_usage(void);
 int	procflow_allstarted(void);
+void procflow_cancel(int arg1);
 
 #endif	/* _FB_PROCFLOW_H */
diff --git a/vars.c b/vars.c
index 9e36e37..e5aeff0 100644
--- a/vars.c
+++ b/vars.c
@@ -37,6 +37,7 @@
 #include "stats.h"
 #include "eventgen.h"
 #include "fb_random.h"
+#include "fb_cvar.h"
 
 static var_t *var_find_dynamic(char *name);
 static boolean_t var_get_bool(var_t *var);
@@ -114,6 +115,9 @@ avd_get_type_string(avd_t avd)
 	case AVD_IND_RANDVAR:
 		return ("points to var_t's random distribution object");
 
+	case AVD_IND_CVAR:
+		return ("points to a var_t's custom variable object");
+
 	default:
 		return ("illegal avd type");
 	}
@@ -142,6 +146,9 @@ var_get_type_string(var_t *ivp)
 	case VAR_TYPE_RAND_SET:
 		return ("random");
 
+	case VAR_TYPE_CVAR_SET:
+		return ("custom");
+
 	default:
 		return ("empty");
 	}
@@ -177,6 +184,14 @@ avd_get_int(avd_t avd)
 		else
 			return ((fbint_t)rndp->rnd_get(rndp));
 
+	case AVD_IND_CVAR: {
+		cvar_t *cvar = avd->avd_val.cvar;
+		if (!cvar)
+			return 0;
+		else
+			return (fbint_t) get_cvar_value(cvar);
+	}
+
 	default:
 		filebench_log(LOG_ERROR,
 		    "Attempt to get integer from %s avd",
@@ -226,6 +241,14 @@ avd_get_dbl(avd_t avd)
 		} else
 			return (rndp->rnd_get(rndp));
 
+	case AVD_IND_CVAR: {
+		cvar_t *cvar = avd->avd_val.cvar;
+		if (!cvar)
+			return 0.0;
+		else
+			return (fbint_t) get_cvar_value(cvar);
+	}
+
 	default:
 		filebench_log(LOG_ERROR,
 		    "Attempt to get floating point from %s avd",
@@ -415,6 +438,11 @@ avd_alloc_var_ptr(var_t *var)
 		avd->avd_val.randptr = var->var_val.randptr;
 		break;
 
+	case VAR_TYPE_CVAR_SET:
+		avd->avd_type = AVD_IND_CVAR;
+		avd->avd_val.cvar = var->var_val.cvar;
+		break;
+
 	case VAR_TYPE_INDVAR_SET:
 		avd->avd_type = AVD_IND_VAR;
 		if ((var->var_type & VAR_INDVAR_MASK) == VAR_IND_ASSIGN)
@@ -491,6 +519,7 @@ var_alloc_cmn(char *name, int var_type)
 
 	switch (var_type & VAR_TYPE_MASK) {
 	case VAR_TYPE_RANDOM:
+	case VAR_TYPE_CUSTOM:
 	case VAR_TYPE_GLOBAL:
 		var_listp = &filebench_shm->shm_var_list;
 		break;
@@ -1004,6 +1033,43 @@ var_ref_attr(char *name)
 }
 
 /*
+ * Allocate a variable, and set it to custom type
+ */
+var_t *
+var_define_cvar(char *name)
+{
+	var_t *newvar;
+	cvar_t *cvar;
+
+	name += 1; /* Escape the $ in front of the variable name. */
+
+	/* make sure variable doesn't already exist */
+	if (var_find(name) != NULL) {
+		filebench_log(LOG_ERROR,
+		    "variable name already in use");
+		return (NULL);
+	}
+
+	/* allocate a custom variable */
+	if ((newvar = var_alloc_cmn(name, VAR_TYPE_CUSTOM)) == NULL) {
+		filebench_log(LOG_ERROR,
+		    "failed to alloc custom variable");
+		return (NULL);
+	}
+
+	/* set cvar pointer */
+	if ((cvar = cvar_alloc()) == NULL) {
+		filebench_log(LOG_ERROR,
+		    "failed to allocate custom variable object");
+		return (NULL);
+	}
+
+	VAR_SET_CVAR(newvar, cvar);
+
+	return (newvar);
+}
+
+/*
  * Converts the contents of a var to a string
  */
 static char *
@@ -1129,6 +1195,12 @@ var_get_int(var_t *var)
 			return ((fbint_t)rndp->rnd_get(rndp));
 	}
 
+	if (VAR_HAS_CVAR(var)) {
+		cvar_t *cvar = var->var_val.cvar;
+		if (!cvar)
+			return (fbint_t) get_cvar_value(cvar);
+	}
+
 	if (VAR_HAS_BINOP(var))
 		return (var_binary_integer_op(var));
 
diff --git a/vars.h b/vars.h
index 7e7a434..7095840 100644
--- a/vars.h
+++ b/vars.h
@@ -27,6 +27,7 @@
 #define	_FB_VARS_H
 
 #include "filebench.h"
+#include "fb_cvar.h"
 
 typedef uint64_t fbint_t;
 
@@ -42,8 +43,9 @@ typedef enum avd_type {
 	AVD_VAL_DBL,		/* avd contains a double float */
 	AVD_VARVAL_DBL,		/* avd points to the double in a var_t */
 	AVD_IND_VAR,		/* avd points a var_t */
-	AVD_IND_RANDVAR		/* avd points to the randdist_t associated */
-				/* with a random type var_t */
+	AVD_IND_RANDVAR,	/* avd points to the randdist_t associated */
+						/* with a random type var_t */
+	AVD_IND_CVAR
 } avd_type_t;
 
 
@@ -61,6 +63,7 @@ typedef struct avd {
 		char		**strptr;
 		struct randdist *randptr;
 		struct var	*varptr;
+		struct cvar	*cvar;
 	} avd_val;
 } *avd_t;
 
@@ -82,6 +85,7 @@ typedef struct var {
 		char		*string;
 		struct randdist *randptr;
 		struct var	*varptr2;
+		struct cvar *cvar;
 	} var_val;
 	struct var	*var_varptr1;
 } var_t;
@@ -90,7 +94,8 @@ typedef struct var {
 #define	VAR_TYPE_GLOBAL		0x0000	/* global variable */
 #define	VAR_TYPE_DYNAMIC	0x1000	/* Dynamic variable */
 #define	VAR_TYPE_RANDOM		0x2000	/* random variable */
-#define	VAR_TYPE_LOCAL		0x3000	/* Local variable */
+#define VAR_TYPE_CUSTOM		0x3000	/* Custom variable */
+#define	VAR_TYPE_LOCAL		0x4000	/* Local variable */
 #define	VAR_TYPE_MASK		0xf000
 
 /* various var subtypes that a var can be set to */
@@ -99,6 +104,7 @@ typedef struct var {
 #define	VAR_TYPE_STR_SET	0x0300	/* var contains a string */
 #define	VAR_TYPE_DBL_SET	0x0400	/* var contains a double */
 #define	VAR_TYPE_RAND_SET	0x0500	/* var contains a randdist pointer */
+#define VAR_TYPE_CVAR_SET	0x0600	/* var contains a custom variable pointer */
 #define	VAR_TYPE_INDVAR_SET	0x0700	/* var points to another variable(s) */
 #define	VAR_TYPE_SET_MASK	0x0f00
 
@@ -156,6 +162,9 @@ typedef struct var {
 #define	VAR_HAS_RANDDIST(vp) \
 	(((vp)->var_type & VAR_TYPE_SET_MASK) == VAR_TYPE_RAND_SET)
 
+#define	VAR_HAS_CVAR(vp) \
+	(((vp)->var_type & VAR_TYPE_SET_MASK) == VAR_TYPE_CVAR_SET)
+
 #define	VAR_HAS_INDVAR(vp) \
 	((((vp)->var_type & VAR_TYPE_SET_MASK) == VAR_TYPE_INDVAR_SET) && \
 	(((vp)->var_type & VAR_INDBINOP_MASK) == VAR_IND_ASSIGN))
@@ -202,6 +211,14 @@ typedef struct var {
 		    VAR_TYPE_RAND_SET); \
 	}
 
+#define	VAR_SET_CVAR(vp, val)	\
+	{			\
+		(vp)->var_val.cvar = (val); \
+		(vp)->var_type = \
+		    (((vp)->var_type & (~VAR_TYPE_SET_MASK)) | \
+		    VAR_TYPE_CVAR_SET); \
+	}
+
 #define	VAR_SET_INDVAR(vp, val)	\
 	{			\
 		(vp)->var_varptr1 = (val); \
@@ -240,6 +257,7 @@ void var_update_comp_lvars(var_t *newlvar, var_t *proto_comp_vars,
     var_t *mstr_lvars);
 var_t *var_define_randvar(char *name);
 var_t *var_find_randvar(char *name);
+var_t *var_define_cvar(char *name);
 boolean_t var_to_boolean(char *name);
 fbint_t var_to_integer(char *name);
 double var_to_double(char *name);
