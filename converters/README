Trace-to-Dataseries folder.

This folder contains code that collect and convert traces.

This suite has a set of conversion tools from raw trace format to DataSeries.
1) csv2ds-extra special formmated CSV files that handles extra features than
	csv2ds (converting with multiple extent types, nullable fields)
		USAGE: ./csv2ds-extra <outputfile> <tablefile> <spec_string_file> <inputfiles...>

2) systrace2ds.sh - converts system call traces to Dataseries
		USAGE: ./systrace2ds.sh <outputfile> <spec_string_file> <inputfiles...>

3) blktrace2ds.sh - converts blktraces (collected by blktrace) to Dataseries
		USAGE: ./blktrace2ds.sh <outputfile> <blktrace_base_file>

4) spctrace2ds.sh - converts SPC traces to Dataseries
		USAGE: ./spc2ds.sh <outputfile> <spc_inputfile>

5) generate-xml.sh - utility that converts field tables to xml files used by
	csv2ds-extra. The files need to be generated before the run.
		USAGE: ./generate-xml.sh <tablefile> <spec-string-file>
	Before running any of the conversion tools, generate all the xml files:
	$ ./generate-xml.sh tables/snia_to_systemtap_fields_mapping.csv specstrings/systrace
	$ ./generate-xml.sh tables/snia_to_blktrace_fields_mapping.csv specstrings/blocktrace


FILE FORMATS
CSV input file
	The format for each line in the CSV file should look like
	<extent name>,<fields>
	
	where <extent name> is the name of the extent, <common fields> is the
	set of fields that's relevant for the extent - delimited by commas.
	
Specification String
	The string defines the structure of the extents and fields that the CSV
	file follows. The extents are delimited by simicolons; the fields
	specific to an extent is enclosed by parentheses; and the fields are
	delimited by commas. For example
	
	$ cat specstrings/example.string
	"open(given_pathname,full_pathname,flag_read_only,flag_write_only,flag_read_and_write,flag_append,flag_create,flag_direct);\
	 read(descriptor,bytes_requested);\
	 write(descriptor,bytes_requested);\
	 close(descriptor);"

	describes that the 'read' records in the CSV file would look like
	"read,<descriptor>,<bytes_requested>".
	
	-----------------------------------------------------------------------
	If the extent is called 'Common', the fields enclosed will be applied to
	the beginning of the subsequent extents. For example

	$ cat specstrings/example-with-Common.string
	"Common(time_called,time_returned,time_recorded,executing_pid,executing_tid,executing_uid,return_value);\
	 read(descriptor,bytes_requested);\
	 write(descriptor,bytes_requested);\
	 "

	is equivalent to
	
	$ cat specstrings/example-without-Common.string
	"read(time_called,time_returned,time_recorded,executing_pid,executing_tid,executing_uid,return_value,descriptor,bytes_requested);\
	 write(time_called,time_returned,time_recorded,executing_pid,executing_tid,executing_uid,return_value,descriptor,bytes_requested);\
	 "
	 
	 -----------------------------------------------------------------------
	For convience, there are default IO block trace and IO system call trace
	specification strings avaliable in specstrings/ that enables all extents
	and fields.


Configuration table
	The configuration table describes all fields and their types. To
	work with SNIA semantics, there are default tables
	(tables/snia_to_systemtap_fields_mapping.csv for IO system call traces;
	tables/snia_to_blktrace_fields_mapping.csv for
	block IO traces) you can use. The fields in the specification string
	needs to be in the table.
	
	The table has five fields, delimited by commas:
		1) name of the extent
		2) name of the field
		3) nullable (1) or not nullable (0)
		4) type of the field
		5) SystemTap value parameter (not relevant)


EXAMPLE
Suppose we want to trace open, fstat, read, write and close system calls with a subset of SNIA's parameters:

------------------------------------------------------------------------
<Common Fields> = time_called,time_returned,time_recorded,executing_pid,executing_tid,executing_uid,return_value

open:
<open specific fields>=given_pathname,full_pathname,flag_read_only,flag_write_only,flag_read_and_write,flag_append,flag_create,flag_direct

read:
<read specific fields>= descriptor,bytes_requested

write:
<write specific fields>= descriptor,bytes_requested

close:
<close specific fields>= descriptor

------------------------------------------------------------------------

The format for each line in the CSV file should look like
<system call name>,<common fields>,<fields specific to each system call>

The specification string should look like 

$ cat specstrings/example.string
"Common(time_called,time_returned,time_recorded,executing_pid,executing_tid,executing_uid,return_value);\
 open(given_pathname,full_pathname,flag_read_only,flag_write_only,flag_read_and_write,flag_append,flag_create,flag_direct);\
 read(descriptor,bytes_requested);\
 write(descriptor,bytes_requested);\
 close(descriptor);"

Here's an example CSV file:
$ cat tracefile/input.csv
open,1313191933879624,1313191933879634,1313191933879634,11182,11205,0,11,/proc/11205/stat,,1,0,0,0,0,0
fstat,1313191933879651,1313191933879663,1313191933879663,11182,11205,0,0,11
read,1313191933878698,1313191933879958,1313191933879958,11184,11202,0,245,11,1024
close,1313191933879977,1313191933879992,1313191933879992,11184,11202,0,0,11

From this we can see that
1. At timestamp 1313191933879624, process 11182 with thread ID 11205 opens the file "/proc/11205/stat" with O_RDONLY flag. 
	This operation is successfully completed at timestamp 1313191933879634 by returning the file descriptor 11.
	Note that null fields (in this case, the full_pathname) are represented by the null string.
2. At timestamp 1313191933879651, the same process and thread fstat file descriptor 11.
3. At timestamp 1313191933878698, the same process with a different thread (11202), read from file descriptor 11 data of size 1024 bytes.
4. At timestamp 1313191933879977, the same process and thread closes the file descriptor 11.

We run
$ ./csv2ds-extra out.ds tables/snia_to_systemtap_fields_mapping.csv specstrings/example.string tracefile/input.csv
